<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo支持数学公式</title>
    <url>/2023/11/09/Hexo/hexo%E6%94%AF%E6%8C%81%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p>参考:
https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md</p>
<p>首先，卸载原有的渲染器 <code>hexo-renderer-marked</code>,
并安装新的渲染器<code>hexo-renderer-pandoc</code></p>
<span id="more"></span>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> uninstall hexo-renderer-marked</span><br><span class="line"><span class="built_in">npm</span> install hexo-renderer-pandoc <span class="comment"># 或者 hexo-renderer-kramed</span></span><br></pre></td></tr></table></figure>
<p>然后在<code>next/_config.yml</code>中将<code>mathjax</code>的<code>enable</code>打开。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>还要本地安装<code>pandoc</code>软件,
地址:https://github.com/jgm/pandoc/releases</p>
<p>公式示例:</p>
<p><span class="math display">\[
A = \begin{bmatrix}
        a_{11}    &amp; a_{12}    &amp; ...    &amp; a_{1n}\\
        a_{21}    &amp; a_{22}    &amp; ...    &amp; a_{2n}\\
        a_{31}    &amp; a_{22}    &amp; ...    &amp; a_{3n}\\
        \vdots    &amp; \vdots    &amp; \ddots &amp; \vdots\\
        a_{n1}    &amp; a_{n2}    &amp; ... &amp; a_{nn}\\
    \end{bmatrix} , b = \begin{bmatrix}
        b_{1}  \\
        b_{2}  \\
        b_{3}  \\
        \vdots \\
        b_{n}  \\
    \end{bmatrix}
\]</span></p>
<p><span class="math display">\[
P(A_i \mid B) = \frac{P(B\mid A)P(A_i)}{\sum_{j=1}^{n}P(A_j)P(B \mid
A_j)}
\]</span></p>
<p>行内公式<span class="math inline">\(A_b\)</span>嗯.</p>
]]></content>
      <categories>
        <category>latex</category>
      </categories>
      <tags>
        <tag>latex</tag>
        <tag>数学公式</tag>
      </tags>
  </entry>
  <entry>
    <title>PlayNetMode</title>
    <url>/2023/11/09/UE/%E5%85%B6%E4%BB%96/PlayNetMode/</url>
    <content><![CDATA[<p>定义:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>()</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EPlayNetMode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** A standalone game will be started. This will not create a dedicated server, nor automatically connect to one. A server can be launched by enabling bLaunchSeparateServer if you need to test offline -&gt; server connection flow for your game. */</span></span><br><span class="line">    <span class="function">PIE_Standalone <span class="title">UMETA</span><span class="params">(DisplayName=<span class="string">&quot;Play Standalone&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    <span class="comment">/** The editor will act as both a Server and a Client. Additional instances may be opened beyond that depending on the number of clients. */</span></span></span><br><span class="line"><span class="function">    PIE_ListenServer <span class="title">UMETA</span><span class="params">(DisplayName=<span class="string">&quot;Play As Listen Server&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    <span class="comment">/** The editor will act as a Client. A server will be started for you behind the scenes to connect to. */</span></span></span><br><span class="line"><span class="function">    PIE_Client <span class="title">UMETA</span><span class="params">(DisplayName=<span class="string">&quot;Play As Client&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="pie_standalone">PIE_Standalone</h1>
<p>本地端, 没有远端. 没有DS, 只有本地一个端在跑.</p>
<h1 id="pie_listenserver">PIE_ListenServer</h1>
<p>创建一个GameInstance, 它即当DS, 又作为客户端.
并且允许多个独立的客户端与它相连.</p>
<p>可以看到, 其就有两个<code>world</code>: <code>editor</code>,
<code>Client+DS</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231012144641355.png" /></p>
<h1 id="pie_client">PIE_Client</h1>
<p>分别创建两个<code>GameIntance</code>,
客户端<code>GameInstance</code>+<code>DS GameInstance</code>.</p>
<p>可以看到, 其有三个<code>World</code>, 分别是<code>editor</code>,
<code>DS</code>, <code>Client</code>. 这种模式下,
Actor会有<code>ROLE_Authority</code>和<code>ROLE_AutonomousProxy</code>以及<code>ROLE_SimulatedProxy</code>对应的实例.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231012144447532.png"
alt="image-20231012144447532" />
<figcaption aria-hidden="true">image-20231012144447532</figcaption>
</figure>
<h1 id="创建关键函数">创建关键函数</h1>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231012144912314.png" /></p>
<p>这里不做详细解析. 只是暂时标注, 后续有时间会有详解.</p>
]]></content>
      <categories>
        <category>UE</category>
        <category>PlayNetMode</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>PlayNetMode</tag>
        <tag>NeedDoMore</tag>
      </tags>
  </entry>
  <entry>
    <title>UE SoftReference浅析</title>
    <url>/2023/11/09/UE/%E5%85%B6%E4%BB%96/UE%20SoftReference%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>资源路径: <span style="color:red;">/Game</span><span
style="color:Purple;">/ThirdPersonCPP/Maps</span><span
style="color:Blue;">/UEDPIE_0_NewMap1</span><span
style="color:Gold;">.NewMap1</span><span
style="color:Black;">:</span><span
style="color:SeaGreen;">PersistentLevel.</span><span
style="color:DarkOrange;">TestActor1_2</span></p>
<ol type="1">
<li>红色<span style="color:red;">/Game</span>: 资源分区,
<code>/Game</code>为GameContent区域,
<code>/Engine</code>为EngineContent区域,
<code>/Plugin</code>为PluginContent区域</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812153324842.png" /></p>
<ol start="2" type="1">
<li>紫色<span
style="color:Purple;">/ThirdPersonCPP/Maps</span>表示资源路径</li>
<li>蓝色<span
style="color:Blue;">UEDPIE_0_NewMap1</span>表示Package名称</li>
<li>黄色<span style="color:Gold;">NewMap1</span>表示Package内对象名称,
即World.</li>
<li>黑色<span style="color:Black;">:</span>子对象分隔符,
表明其后面的都是子对象.</li>
<li>绿色<span style="color:SeaGreen;">PersistentLevel</span>表示以<span
style="color:Gold;">NewMap1</span>作为Outer的SubObject,
World中的Level.</li>
<li>橙色<span style="color:DarkOrange;">TestActor1_2</span>表示以<span
style="color:SeaGreen;">PersistentLevel</span>为Outer的SubObject,
Level内的Actor.</li>
</ol>
<p>搜寻过程: <strong>通过资源全路径(<span
style="color:red;">/Game</span><span
style="color:Purple;">/ThirdPersonCPP/Maps</span><span
style="color:Blue;">/UEDPIE_0_NewMap1</span>)找到package(蓝色<span
style="color:Blue;">UEDPIE_0_NewMap1</span>),
通过Package找到World(黄色<span style="color:Gold;">NewMap1</span>),
通过world找到Level(绿色<span
style="color:SeaGreen;">PersistentLevel</span>),
通过Level找到Actor(橙色<span
style="color:DarkOrange;">TestActor1_2</span>).</strong></p>
<span id="more"></span>
<h1 id="查找过程">查找过程</h1>
<p>构造调试环境:
在LevelBlueprint里面添加<code>Resolve Soft Reference</code>节点,
它会将SoftRef转换成ObjRef.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812142607189.png" /></p>
<p>其中蓝图节点<code>ExpandNode</code>内的关键函数为:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812122104044-1691821775726-5.png" /></p>
<p>调试堆栈:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812122024991.png" /></p>
<p>跟随堆栈, 解析关键函数<code>ResolveObjectInternal</code>,
通过<code>FindObject&lt;UObject&gt;(nullptr, PathString)</code>根据路径查找对应UObject.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812143210853.png" /></p>
<h2 id="subobj分隔符">SubObj分隔符<code>:</code></h2>
<p><code>:</code>为SubObject分割符, 其表明后面的Obj为SubObject.
而SubObj不会有<code>FindScriptPackageName</code>查找步骤.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812151853189.png" /></p>
<p>深入函数<code>StaticFindObject</code>,
发现其调用<code>ResolveName</code>, 在<code>ResolveName</code>函数中,
首先将<code>:</code>替换成<code>..</code>,
其意思是将SubObject分隔符<code>:</code>替换成<code>..</code>.
然后资源路径由<code>/Game/ThirdPersonCPP/Maps/UEDPIE_1_NewMap1.NewMap1:PersistentLevel.TestActor1_2</code>变成了<code>/Game/ThirdPersonCPP/Maps/UEDPIE_1_NewMap1.NewMap1..PersistentLevel.TestActor1_2</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812143846817.png" /></p>
<h2 id="找到第一个package">找到第一个Package</h2>
<p>又将<code>.</code>作为分隔符, 提取左边字符串,
后得到:<code>/Game/ThirdPersonCPP/Maps/UEDPIE_1_NewMap1</code></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812144250757.png" /></p>
<p>通过<code>FindObject&lt;UPackage&gt;( InPackage, *PartialName )</code>找到了资源名对应的资源对象.
所以<code>/Game/ThirdPersonCPP/Maps/UEDPIE_1_NewMap1</code>是全路径资源对象.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812144434346.png" /></p>
<h2
id="通过package找到其内部的object">通过Package找到其内部的Object</h2>
<p>资源路径剩余字符串为<code>NewMap1..PersistentLevel.TestActor1_2</code>,
根据分割规则(取<code>.</code>左边字符串)再次分割,
提取字符串为<code>NewMap1</code></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812144838263.png" /></p>
<p>使用函数<code>FindObject&lt;UObject&gt;</code>,
根据<code>Out</code>和<code>PartialName</code>, 找到Outer中的对象.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812145345311.png" /></p>
<p>堆栈:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812145553486.png" /></p>
<p>最终, 根据Outer找到其内部的Obj(NewMap1). 所以,
<code>NewMap1</code>为Package:<code>/Game/ThirdPersonCPP/Maps/UEDPIE_1_NewMap1</code>下的Obj.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812145714910.png" /></p>
<h2 id="递归查找">递归查找</h2>
<p>根据上述流程易知:</p>
<ol type="1">
<li>以<code>NewMap1</code>为Outer,
根据SubObjectName:<code>PersistentLevel</code>, 找到SubObject对象.</li>
<li>以<code>PersistentLevel</code>为Outer,
根据SubObjectName:<code>TestActor1_2</code>, 找到SubObject对象.</li>
</ol>
<h1 id="总结">总结</h1>
<h2 id="冒号的意思">冒号的意思</h2>
<p>冒号作为SubObject分割符, 表示其后边的名字为SubObj名字,
不会进行<code>FindScriptPackageName</code>查找.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812122343966.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230812152401042.png" /></p>
<h2 id="package路径">Package路径</h2>
<p>资源名称,
中Package路径<code>/Game/ThirdPersonCPP/Maps/UEDPIE_0_NewMap1</code></p>
<h2 id="首个obj对象">首个Obj对象</h2>
<p>第一个<code>.</code>后边的名称作为第一个对象<code>NewMap1</code></p>
<h2 id="子对象">子对象</h2>
<p><code>:</code>后的内容全部作为子对象, 用<code>.</code>分隔, 递归查找.
<code>:PersistentLevel.TestActor1_2</code></p>
<h1 id="参考">参考</h1>
<ul>
<li><a
href="https://www.cnblogs.com/sin998/p/15501520.html">加载资源的方式</a></li>
</ul>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>UE SoftReference</tag>
      </tags>
  </entry>
  <entry>
    <title>Always Replicate的指针类型, 一次同步会触发两次OnRep</title>
    <url>/2023/11/29/UE/%E7%BD%91%E7%BB%9C/Always%20Replicate%E7%9A%84%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B,%20%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5%E4%BC%9A%E8%A7%A6%E5%8F%91%E4%B8%A4%E6%AC%A1OnRep/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>Replication</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>Replication</tag>
        <tag>OnRep</tag>
      </tags>
  </entry>
  <entry>
    <title>Channel的创建和销毁</title>
    <url>/2023/11/09/UE/%E7%BD%91%E7%BB%9C/Channel%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81/</url>
    <content><![CDATA[<p>客户端和DS通过Bunch.ChIndex相互映射关联.
这样同一个Actor在每个端都会通过同一个Channel进行处理.</p>
<h1 id="搭建测试用例">搭建测试用例</h1>
<p>首先搭建一个能主动创建和销毁Channel的示例.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在DS端主动创建Character</span></span><br><span class="line"><span class="keyword">if</span> (ALSVCharacter==<span class="literal">nullptr</span> &amp;&amp; CreateCharacterFrameIndex ==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    CreateCharacterFrameIndex =<span class="number">1</span>;</span><br><span class="line">    FVector Loc = FVector::ZeroVector;</span><br><span class="line">    FRotator Rot = FRotator::ZeroRotator;</span><br><span class="line">    FActorSpawnParameters Par;</span><br><span class="line">    Par.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;</span><br><span class="line">    ALSVCharacter = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AALSVCharacter&gt;(AALSVCharacter::<span class="built_in">StaticClass</span>(), Loc, Rot, Par);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在DS端主动销毁Character</span></span><br><span class="line"><span class="keyword">if</span> (CreateCharacterFrameIndex&gt;<span class="number">50</span>)</span><br><span class="line">&#123;</span><br><span class="line">    CreateCharacterFrameIndex = <span class="number">-1</span>;</span><br><span class="line">    ALSVCharacter-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line">    ALSVCharacter = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="打开">打开</h1>
<h2 id="ds打开流程">DS打开流程</h2>
<p>在DS端创建的Actor, 在属性同步时, 发现没有对应的Channel,
会进行创建并分配ChannelIndex, 与Actor绑定.
然后就能通过Channel进行通信了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DS Channel创建流程. 在SpawnActor后, 当Actor进行属性同步时, 发现缺少对应的Channel, 会进行创建.</span></span><br><span class="line">--UNetDriver.TickFlush</span><br><span class="line"> |--UNetDriver.ServerReplicateActors</span><br><span class="line"> | |--UNetDriver.ServerReplicateActors_ProcessPrioritizedActors</span><br><span class="line"> | | |--UNetConnection.CreateChannelByName</span><br><span class="line"> | | | |--GetFreeChannelIndex <span class="comment">// 获取Free ChannelIndex</span></span><br><span class="line"> | | | |--UActorChannel.Init</span><br><span class="line"> | | | | |--UChannel.Init</span><br><span class="line"> | | |--Channel-&gt;<span class="built_in">SetChannelActor</span>(Actor, ESetChannelActorFlags::None);</span><br><span class="line"> | | |--UActorChannel::ReplicateActor</span><br></pre></td></tr></table></figure>
<p>可以看到, DS端Channel主动绑定Actor的:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Channel<span class="punctuation">-&gt;</span><span class="title function_ invoke__">SetChannelActor</span>(Actor, ESetChannelActorFlags::<span class="literal">None</span>);</span><br></pre></td></tr></table></figure>
<h2 id="客户端打开流程">客户端打开流程</h2>
<p>在解析DS发来的Bunch时,
根据ChannelIndex在UNetConnection.Channels中直接索引,
如果为空会进行创建:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230707152204041.png" /></p>
<p>创建Channel:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230707152252606.png" /></p>
<p>然后处理bunch中的数据.</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// 客户端创建Channel流程</span><br><span class="line">--UIpNetDriver.TickDispatch</span><br><span class="line"> |<span class="string">--UNetConnection.ReceivedRawPacket</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedNextBunch()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UNetConnection.ReceivedPacket</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UNetConnection.CreateChannelByName</span></span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong>Channel创建后,第一个Bunch不一定是SpawnActor,
第一个bunch是需要该Index的Channel进行处理, 就创建了.
比如第一个Bunch极有可能是ExportGUIDBunch,
带有SpawnActor的Bunch在其后.</p>
<h3 id="思考">思考</h3>
<ol type="1">
<li>客户端Channel打开后会立即绑定Actor吗?</li>
</ol>
<p>答: 不会, channel的打开纯粹是依赖Bunch的ChannelIndex,
而Channel和Actor的绑定则依赖Bunch中的SpawnActor,
二者极有可能不在同一个bunch中. 例如DS先发来ExportGUIDBunch,
然后才发来属性同步的bunch(里面带有SpawnActor).</p>
<ol start="2" type="1">
<li>如果客户端Channel还没有SpawnActor(与Actor绑定),
就收到了属性同步的消息(在丢包的时候可能发生), 会怎么处理?</li>
</ol>
<p>答: 直接丢弃, 并报错:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230707154045316.png" /></p>
<h1 id="关闭">关闭</h1>
<h2 id="ds关闭channel">DS关闭Channel</h2>
<h3 id="关闭channel">关闭Channel</h3>
<p>关闭的同时会向客户端发送 CloseBunch. 注意观察,
CloseBunch的bClose为true, 并且bReliable为1, 为Reliable的Close Bunch.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆栈: DS Channel Close流程, 注意:这里只是将Channel close掉, 还没有销毁</span></span><br><span class="line">--AActor.<span class="built_in">Destroy</span>()</span><br><span class="line"> |--UNetDriver.<span class="built_in">NotifyActorDestroyed</span>()</span><br><span class="line"> | |--UActorChannel.<span class="built_in">Close</span>()</span><br><span class="line"> | | |--UChannel.<span class="built_in">Close</span>()</span><br><span class="line"> | | | |--SendCloseBunch</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230701144331989.png" /></p>
<p>并将Channel设置为Closing状态:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230701145255639.png" /></p>
<h3 id="回收channel">回收Channel</h3>
<p>DS向客户端发送close包后, 由于Close包时Reliable, 需要等Ack,
再接收到Ack后, 才能将Channel Close掉.</p>
<p>DS收到CloseBunch的ACK. 然后将Channel Close掉.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230705160113507.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230705160206847.png" /></p>
<p>Close时候是将Channel放入Pool中, 等待下次复用:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230705160254776.png" /></p>
<h3 id="思考-1">思考</h3>
<ol type="1">
<li><strong>DS在Channel关闭, 但是还没有回收过程中,
客户端发来消息会怎么处理呢?</strong></li>
</ol>
<p>根据上文已知DS将Channel关闭后会将UChannel.Closing 设置为true.
在接收到Bunch时候, 会根据当前是否为Closing状态, 处理Bunch,
如果在Closing状态, 又不是CloseBunch则直接丢弃.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230705161117562.png" /></p>
<ol start="2" type="1">
<li><strong>为什么不直接关闭, 反而要等客户端Ack呢?</strong></li>
</ol>
<p>如果直接关闭, 客户端可能还未接收到CloseBunch, 还会继续发送消息,
这时候, DS会收到很客户端发来的消息. 这时候,
Channel其实已经没了(Close时候会回收Channel), 会直接丢弃. 但是会报错.
但是, 明显直接丢弃就好, 不需要报错, 所以要Ack确认后才关闭.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230707160436569.png" /></p>
<h3 id="总结">总结</h3>
<p>DS关闭Channel分成两步, 首先将Channel Close掉,
并向客户端发送CloseBunch,
等待接收到CloseBunch的Ack才将Channel彻底清理并放入Pool中等待重复利用.</p>
<h2 id="客户端关闭channel">客户端关闭Channel</h2>
<h3
id="收到close消息主动关闭channel并回收">收到Close消息主动关闭Channel并回收</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端Channel Close并销毁流程</span></span><br><span class="line">--UNetConnection.<span class="built_in">ReceivedPacket</span>()</span><br><span class="line"> |--UChannel.<span class="built_in">ReceivedRawBunch</span>() </span><br><span class="line"> | |--UChannel.<span class="built_in">ReceivedNextBunch</span>()</span><br><span class="line"> | | |--UChannel.<span class="built_in">ReceivedSequencedBunch</span>()</span><br><span class="line"> | | | |--UChannel.<span class="built_in">ConditionalCleanUp</span>()</span><br><span class="line"> | | | | |--UNetDriver.ActorChannelPool.<span class="built_in">Push</span>(Channel);</span><br><span class="line"> | | | | |--UActorChannel.<span class="built_in">AddedToChannelPool</span>()<span class="comment">// 将channel添加到Pool池中.</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230701144748951.png" /></p>
<p>客户端收到CloseBunch之后, 直接关闭Channel, 并将Channel放入池中.</p>
<p>销毁所有SubObj和Actor:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230701145136303.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230701145200734.png" /></p>
<p>将Channel设置为Closing状态:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230701145255639.png" /></p>
<p>放入池中:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230701145027283.png" /></p>
<p>在放入Pool时, 需要重置属性:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230704204701304.png" /></p>
<p><strong>总结:</strong> 客户端会同时将Channel close和销毁掉,
一帧先后执行.</p>
<h3 id="思考-2">思考</h3>
<h4 id="客户端能否主动destroyactor呢">客户端能否主动DestroyActor呢?</h4>
<p>不能. 在UWorld.DestroyActor中,
明确指出:只有DS才能Destroy网络Actor.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230701152748387.png" /></p>
<p>仔细观察,仿佛还有一丝生机, 如果我传入了bNetForce为true呢?</p>
<p>确实删除了, 但是, DS并不知情, DS和其他端的Actor还完好的存在,
只是删除了本地Actor. 而且该Actor对应的Channel还在, 只是其Actor没了.
这样就会造成:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230701153342664.png" /></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">LogNetTraffic: Error: UActorChannel::ProcessBunch: New actor channel received non-open packet. bOpen:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">bClose:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">bReliable:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">bPartial:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">bPartialInitial:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">bPartialFinal:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">ChName:</span> <span class="string">Actor,</span> <span class="attr">ChIndex:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">Closing:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">OpenedLocally:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">OpenAcked:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">NetGUID:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p><strong>所以, 本地(非DS)销毁相当于销毁了个寂寞.</strong></p>
<h4
id="客户端收到后续该channel的包怎么处理">客户端收到后续该Channel的包怎么处理</h4>
<p>由于DS先关闭的Channel, 关闭后就不会再发送数据包了,
客户端后关闭Channel, 理论上不会收到该Channel的任何包了.
所以如果再次收到该Channel的包, 直接丢弃就好.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230707155310546.png" /></p>
<p>可以看出, 当Channel没创建时, 对Bunch的判断非常严格.
必须是Open并且Close/partial中的一种才可以, 否则直接丢弃.</p>
<h2 id="思考-3">思考</h2>
<h3
id="如果客户端发送rpc的时候ds还没有创建channel-该怎么办">如果客户端发送RPC的时候DS还没有创建Channel,
该怎么办?</h3>
<p>答: 除了默认Channel, 客户端不能自主创建Channel(配置的除外),
只能被动由DS通知创建. 其次一个Actor要想发送RPC,
必须和DS对应Actor建立关联. 所以以上问题根本不存在.
而且RPC必须由主端发送, 模拟端不能发送RPC. 客户端没有Channel,
不可能发送RPC.</p>
<h3
id="创建channel的bunch时reliable吗">创建Channel的Bunch时Reliable吗?</h3>
<p>Channel创建(第一次发包)的bunch都为Reliable</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230818212005025.png" /></p>
<h3 id="closebunch是否为reliable">CloseBunch是否为Reliable?</h3>
<p>是ReliableBunch.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230818211655965.png" /></p>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title>Component Replication归属权</title>
    <url>/2023/11/18/UE/%E7%BD%91%E7%BB%9C/Component%20Replication%E5%BD%92%E5%B1%9E%E6%9D%83/</url>
    <content><![CDATA[<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/BunchArchetype.png" /><span id="more"></span></p>
<p>创建一个Component后, 其由哪个Actor负责传输呢? <span
style="color:red;">放到其Owner的ActorChannel里面进行传输.</span></p>
<p>查看如下代码,
<code>UTestRepFlowSpawnedCmp</code>的传输由<code>ABasePlayerController</code>负责.
即其归属于<code>ABasePlayerController</code>的ActorChannel.
<code>UTestRepFlowSpawnedCmp</code>对应的<code>FObjectReplicator</code>存储在<code>ABasePlayerController ActorChannel</code>的<code>UActorChannel.ReplicationMap</code>中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118163412963.png" /></p>
<p>原因: 关键函数<code>NewObject</code>中经过层层调用,
最终调用了<code>AActor.AddOwnedComponent</code>,
将该<code>ActorComponent</code>放入了其<code>UActorComponent.OwnerPrivate</code>的<code>AActor.ReplicatedComponents</code>中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118163838301.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118164136189.png" /></p>
<p>在<code>AActor.ReplicateSubobjects</code>中,
遍历所有<code>AActor.ReplicatedComponents</code>进行<code>Replication</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118164211437.png" /></p>
<p><strong>延伸:</strong> 当其Outer不是Actor怎么办呢? 递归寻找其Outer,
直到找到一个为Actor类型的为止.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118164541957.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118164603113.png" /></p>
<p>总结: <span style="color:red;">ActorComponent的网络归属跟Outer有关,
跟谁在使用它无关.</span></p>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>UE4网络模块概述</tag>
      </tags>
  </entry>
  <entry>
    <title>NetworkGUID浅析</title>
    <url>/2023/11/09/UE/%E7%BD%91%E7%BB%9C/FNetworkGUID%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623171337907.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230629164038070.png" /></p>
<span id="more"></span>
<h1 id="思考">思考</h1>
<ol type="1">
<li><p>NetworkGUID是什么</p></li>
<li><p>动态UObject, 静态UObject是什么,
DS和客户端的Obj是怎么关联起来的?</p></li>
<li><p>Actor是怎么创建和同步的?</p></li>
<li><p>针对DefaultSubObj, 客户端和DS怎么关联起来?</p></li>
<li><p>纯UObject怎么进行网络同步, 怎么在客户端创建,
其所占用的Bunch是否变为Reliable?</p></li>
<li><p>怎么将变量的值和其对应的UObject关联起来?
例如BasePlayerController有个UMyTestObject类型变量pTestObj,
客户端的它是怎么创建,
并和BasePlayerController.pTestObj关联起来?</p></li>
</ol>
<h1 id="networkguid规则设定">NetworkGUID规则设定</h1>
<p>UE在设计网络系统时做了多个基础规则设定,
并在此基础上搭建了整个网络系统.
这篇文章仅仅阐述关于NetworkGUID的设定.</p>
<h2 id="networkguid">NetworkGUID</h2>
<p>在UE中, 假设有两个Actor A和B, 如果A和B存在于同一个World里,
那么A和B的变动可以相互感知到, 如果它们存在于不同World里,
A和B的变动就无法相互感知. 因为DS和客户端都处在各自World中,
但是可以换个角度思考,
<strong>可以将它们操控的对象理解为同一个对象不同世界的投射</strong>,
这样, 某一个world中物体的变动就会投射到其他World对应的Actor上.
那么现在需要处理的问题是怎么将同一个Actor不同World的投射关联起来呢?
NetworkGUID应运而生.</p>
<p>FNetworkGUID是一个一个结构体, 里面只有uint32类型的变量.
UE用它唯一标识一个对象(注意, 并不是所有对象都有NetworkGUID,
只有网络对象才有).</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements a globally unique identifier for network related use.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For now, this is just a uint32 with some bits meaning special things.</span></span><br><span class="line"><span class="comment"> * This may be expanded (beyond a uint32) eventually while keeping the API the same.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">FNetworkGUID</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">uint32</span> Value;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="动静态uobject">动/静态UObject</h2>
<p>UE中的UObject大致分成两种: 一种是常驻内存UObject,
一般情况下在整个World(或者Instance)生命周期内都不发生改变. 例如UClass,
UPackage, CDO(Class Default Object)等.另一种是动态创建的UObject,
生命周期一般由程序员维护.
例如程序员调用NewObject/SpawnActor创建出来对象.</p>
<h3 id="静态uobject">静态UObject</h3>
<p>常驻内存的UObject, 例如UClass, UPackage, ULevel等.
在全局范围某一种类型的常驻对象是唯一的,
例如针对PlayerController的UClass就是全局唯一的,
可以通过PathName唯一确定.</p>
<p>判断UObject类型:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615161654189-1686817030472-1.png" /></p>
<p>从上述函数中可以看出,
判断UObject是否为静态的关键函数为:<font color=#008000>UObject::IsFullNameStableForNetworking</font></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615162159874.png" /></p>
<h4 id="rf_wasloaded类型">RF_WasLoaded类型</h4>
<p>该类型表示该Obj是通过加载得到的, 加载类型全部为静态UObject:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/Image-1686885290255-15.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615162605550.png" /></p>
<p>Default__NewPlayerController_C(虽然CDO带有RF_WasLoaded flag,
但是将CDO判定为静态并不是通过RF_WasLoaded.)</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615163508119.png" /></p>
<p>顺带说一下, CDO都会附带属性:RF_WasLoaded.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615190445811.png" /></p>
<h4 id="rf_defaultsubobject类型">RF_DefaultSubObject类型</h4>
<p>使用UObject.CreateDefaultSubobject创建的DefaultSubObject.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615190843425.png" /></p>
<p>RF_DefaultSubObject的类型定义为:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/Image-1686836040943-7.png" /></p>
<p>DefaultSubObject的创建方式:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615191131555.png" /></p>
<p>示例:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615215406442.png" /></p>
<p>注意, 传入的SubObjectName必须是唯一的,
对于某一个Actor的不同SubObject名字必须唯一, 否则就会报错.
报错内容为:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/Image-1686883710960-13.png" /></p>
<p><strong>注意:动态创建的Actor里面所挂载的SubObject都是动态的,
只有当Actor本身为静态时, 其SubObject才是静态.</strong></p>
<h4 id="native类型">Native类型</h4>
<p>如果仅仅是UClass类型,
那么一定是静态Object(因为重写了IsNameStableForNetworking).
(一般不会走到这里, 大多数情况在这之前就已经确定是否为是静态UObject)</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615213834887.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/Image-1686836372885-11.png" /></p>
<p>示例:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230616145449393.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230616145844680.png" /></p>
<p>可以明显看出, UClass类型就是Native.</p>
<p><strong>由于UClass已经重写了IsNameStableForNetworking函数,
所以不会走到这里. 上面的表述只是明确UClass确实为Native类型.</strong></p>
<h4 id="defaultsubobject类型">DefaultSubobject类型</h4>
<p>可以从代码中看出,
如果Outer类型为CDO或者Outer的Archetype与其DefaultObject不同则为DefaultSubObject.一般情况都不会走到这里.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615191511810.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615191752546.png" /></p>
<h4
id="重写isnamestablefornetworking函数">重写IsNameStableForNetworking函数</h4>
<p>有些类型(UClass,UPackage等)重写了虚函数IsNameStableForNetworking,
自定义其是否为静态类型.</p>
<h5 id="upackage">UPackage:</h5>
<p>UPackage类型全部为静态UObject</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230616110825481.png" /></p>
<p>示例:/Game/GamePlay/NewPlayerController.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615163207911.png" /></p>
<h5 id="uclass">UClass</h5>
<p>UClass类型全部为静态UObject:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230616111024824.png" /></p>
<p>示例:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230616111809272.png" /></p>
<h5 id="uleve">ULeve</h5>
<p>ULevel类型全部为静态类型:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230616111100055.png" /></p>
<p>示例:PersistentLevel</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615162923664.png" /></p>
<h4 id="cdo类型">CDO类型</h4>
<p>以PlayerController的CDO类型为例:Default__NewPlayerController_C,
其根据RF_ClassDefaultObject类型判断其为静态类型.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619215617422.png" /></p>
<h4 id="放置到场景中的actor">放置到场景中的Actor</h4>
<p>如果一个Actor放置在场景中, 那么它是静态的还是动态的呢?</p>
<p>可以找到, Actor也重写了函数:IsNameStableForNetworking</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230616152140748.png" /></p>
<p>这里需要关注函数AActor::IsNetStartupActor,
里面有一个变量AActor.bNetStartup .</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230616152506060.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230616152249504.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230616152316777.png" /></p>
<p>可以得出结论, <strong>放置在地图上的Actor都是静态的</strong>.</p>
<h4 id="总结">总结</h4>
<p>概述常用UObject类型中哪些是静态的.</p>
<ol type="1">
<li>UPackage,ULevel,UClass等都重写了IsNameStableForNetworking函数,
确定为静态UObject.</li>
<li>CDO都为静态的.</li>
<li>放置在地图中的Actor都是静态的, 都是可以通过PathName直接绑定的.</li>
<li>如果一个Actor本身是静态的, 那么它所有SubObject都是静态的.</li>
</ol>
<h3 id="动态uobject">动态UObject</h3>
<p>动态Object的判断比较简单, 非静态Object全部是动态Object.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230615215711937.png" /></p>
<ol type="1">
<li>SpawnActor/NewObject出来的UObject都是动态的.</li>
<li>如果Actor本身是动态的,
那么它所有的SubObject都是动态的.(如果一个Obj的Outer为动态的,
则其本身也为动态)</li>
<li>动态Actor是在DS创建,
将Actor(GUID+Archetype)/UObject(GUID+UClass)的GUID同步到客户端后,再进行创建.
即动态Actor/UObject的创建一定是DS优先于客户端(下面会讲).</li>
</ol>
<h1 id="networkguid和uobject关联">NetworkGUID和UObject关联</h1>
<p>在序列化网络数据时, 针对UObject, 是将其转换成NetworkGUID,
传输到远端.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230617170114560.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230617170054484.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230617170125954.png" /></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">调用堆栈:</span><br><span class="line">// 序列化UObject</span><br><span class="line">--FObjectPropertyBase::NetSerializeItem()</span><br><span class="line"> |--FNetworkGUID NetGUID = GuidCache-&gt;GetOrAssignNetGUID( Object );</span><br><span class="line"> |--UPackageMapClient.SerializeObject()</span><br><span class="line"> | |--UPackageMapClient::InternalWriteObject()</span><br><span class="line"> | | |--Ar &lt;&lt; NetGUID;</span><br><span class="line"></span><br><span class="line">// 序列化Actor</span><br><span class="line">--UActorChannel.ReplicateActor()</span><br><span class="line"> |-- // 针对RepFlags.bNetInitial时, 需要序列化Actor本身, 即Actor的GUID</span><br><span class="line"> |--UPackageMapClient.SerializeNewActor()</span><br><span class="line"> | |--UPackageMapClient.SerializeObject()</span><br><span class="line"> | | |--UPackageMapClient::InternalWriteObject()</span><br><span class="line"> | | | |--Ar &lt;&lt; NetGUID;</span><br></pre></td></tr></table></figure>
<p>从上面堆栈可以看出, 序列化UObject的本质其实是将UObject转换成GUID,
然后将其序列化到网络流中, 发送给远端.
即每个GUID都唯一标识一个UObject.</p>
<p><strong>注意: 是在序列化时候进行才将UObject生成其对应的GUID.
即不提前创建, 只有在使用的时候再进行生成和处理.
这样可以把运行消耗分配到每一帧. 并且不会产生额外消耗.</strong>
它和另一种预处理(内存池, 对象池等)的思想截然不同. 引擎中根据情况不同,
需求不同, 选择不同的处理方式.</p>
<p>静态物体和动态物体的GUID类型是不同的,
静态物体是<strong>奇数</strong>, 动态物体是<strong>偶数</strong>.
并且从下文可以看出, 初始静态GUID为3, 动态GUID为2.
并且只有在初始化的时候才可能为0, 并且永远不可能为1. 并且每次递增2.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619100915561.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619101053106.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619101532660.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619101947049.png" /></p>
<p>只有大于0的GUID才是有效GUID.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619101618530.png" /></p>
<h2 id="exportbunch">ExportBunch</h2>
<p>每个Bunch中都可能会用到GUID, 如何将这些GUID的信息提前汇总起来,
发送给客户端呢? UE的解决方案是如果一个Bunch使用了GUID,
并且这个GUID客户端可能还不知道, 那么就在这个Bunch前面额外添加一个Bunch,
特殊命名为ExportBunch. 专门用于传输GUID相关信息.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">--UActorChannel.<span class="built_in">ReplicateActor</span>()</span><br><span class="line"> |--AActor.<span class="built_in">ReplicateSubobjects</span>()</span><br><span class="line"> |--FObjectReplicator.<span class="built_in">ReplicateProperties</span>()</span><br><span class="line"> |--UChannel.<span class="built_in">SendBunch</span>()</span><br><span class="line"> | |--UChannel.<span class="built_in">AppendExportBunches</span>()</span><br><span class="line"> | | |--UPackageMapClient.<span class="built_in">AppendExportBunches</span>()</span><br><span class="line"> | | |--OutgoingBunches.<span class="built_in">Add</span>(Bunch); <span class="comment">// add normal bunch</span></span><br></pre></td></tr></table></figure>
<p>可以看出, 总是先填充ExportBunch, 然后填充普通bunch.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621153642220.png" /></p>
<h3 id="填充exportbunch">填充ExportBunch</h3>
<p>递归序列化GUID+OuterGUID等信息, 填充流程图如下:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621154017561.png" /></p>
<p>当DS序列化一个UObject(将其GUID序列化到网络数据流中),
如果发现该UObject的Outer
GUID客户端可能还没收到(第一次发或者发送后DS没收到ACK),
则会将该UObject的Outer GUID等信息填充到Export中.</p>
<p>通过UPackageMapClient.ShouldSendFullPath判断是否应该填充到ExportGUIDBunch.
并通过UPackageMapClient.ExportNetGUID将GUID真正填充到ExportBunch中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620204539017.png" /></p>
<p>并且在UPackageMapClient::ExportNetGUID首先处理的就是将FOutBunch.bHasPackageMapExports
设置为true, 表明其为ExportBunch.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621171308006.png" /></p>
<p>写入ExportBunch</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620204916160.png" /></p>
<p>填入GUID:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620205013872.png" /></p>
<p>填入ExportFlages</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620205216847.png" /></p>
<p>递归填入Outer信息:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620205304767.png" /></p>
<p>最后以PathName收尾:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620205331636.png" /></p>
<p><strong>最后填充结果如图所示:</strong></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620203026589-1687265644964-4.png" /></p>
<p><strong>那么, ExportBunch里面只有奇数和0吗?</strong>
<strong>并不是.</strong></p>
<p>注意看如下代码,
UPackageMapClient::ShouldSendFullPath里面判断Object是否为静态并不是根据其GUID判断,
而是根据Object本身,
并且不检测其Outer(是否为静态Object首先判断的就是其Outer,
如果Outer为动态, 则其一定是动态). 所以Export里面是会填充偶数GUID的.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620211234970.png" /></p>
<p>比如序列化TestReplicationComp1时, 判断其需要Export,
然后递归将其本身以及其Outer等信息都填入了GUID.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620211933613.png" /></p>
<p>究其根本原因是因为如果只观察TestReplicationComp1本身,
其是通过CreateDefaultSubobject创建而来, 所以其本身是静态Object,
但是由于其Outer为动态, 才将其划为动态Object, 才会分配偶数GUID.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620212214668.png" /></p>
<p>最终序列化后的ExportBunch</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620214305116.png" /></p>
<h3 id="解析exportbunch">解析ExportBunch</h3>
<p>收到ExportGUIDBunch,
进入UPackageMapClient.ReceiveNetGUIDBunch处理.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621171858289.png" /></p>
<p>解析GUID:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621172117183.png" /></p>
<p>解析ExportFlags</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621172202283.png" /></p>
<p>如果有Path, 需要递归解析Outer信息, 并以解析pathName收尾.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621172328831.png"
alt="image-20230621172328831" />
<figcaption aria-hidden="true">image-20230621172328831</figcaption>
</figure>
<p>通过分析UPackageMapClient.InternalLoadObject中的代码, 发现,
其所有逻辑均为查询, 加载对应的UObject.</p>
<p>尝试加载:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621173010782.png" /></p>
<p>各种情况下的尝试加载等等.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621173114588.png" /></p>
<p><strong>所以, 针对ExportBunch而言, 其作用是传输GUID信息,
客户端收到信息后, 尝试在内存中查找对应的UObject,
如果查找不到则根据类型尝试进行加载.
但是永远不会创建新的Obj.</strong></p>
<p>在客户端, 如果一个GUID确实没有查找到,
会将其暂时放入FNetGUIDCache.ObjectLookup中,
但是FNetGuidCacheObject.Object不会进行赋值,
表示当前已经收到DS发来的GUID, 但是这个GUID对应的UObject还没有创建.
在稍后解析UObject的Property时候, 如果用到了该GUID, 会重新查找,
如果找到了就会进行绑定.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628171415669.png" /></p>
<h3 id="总结-1">总结</h3>
<p>在DS端网络序列化时,
发现如果客户端没有相关GUID,则序列化到ExportBunch中, 并放置在该Bunch之前.
在客户端解析的时候, 只进行查询和加载, 对GUID和UObject进行绑定,
但是并不会创建, 创建UObject是在UActorChannel::ReadContentBlockHeader,
而创建Actor是在UPackageMapClient.SerializeNewActor函数中.</p>
<h2 id="defaultguid">DefaultGUID</h2>
<p>1非常特殊, 作为defaultGUID使用.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619101655531.png" /></p>
<p>它有特殊的意义. 当主控端向DS发送RPC时, 如果RPC函数相关UObject的GUID
DS还没有发送过来, 则使用DefaultGUID.</p>
<h3 id="构造复现场景">构造复现场景</h3>
<p>在Character中CreateDefaultSubobject UTestActorComponent,
并在UTestActorComponent::BeginPlayer的时候向DS发送RPC, 这种情况下,
由于DS没有需求向主控端发送UTestActorComponent的GUID(只有用到才会发送),
所以主控端的UTestActorComponent不会有GUID,
只能使用DefaultGUID向DS发送信息.</p>
<p>创建UTestActorComponent</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/ActorComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestActorComp.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UTestActorComponent</span> : <span class="keyword">public</span> UActorComponent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC 同步给服务端拾取</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(Reliable, Server)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">C2S_Test1Func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    int32 TestIndex = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTestActorComponent::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">    <span class="built_in">C2S_Test1Func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTestActorComponent::C2S_Test1Func_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++TestIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其挂载到Character上, 并在构造函数中创建.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ALSVCharacter.h </span></span><br><span class="line"><span class="built_in">UPROPERTY</span>();</span><br><span class="line">UTestActorComponent *TestActorComponent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ALSVCharacter.cpp</span></span><br><span class="line">TestActorComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UTestActorComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;TestActorComponent&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>添加断点.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619203019292.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619202742759.png" /></p>
<h3 id="主控端发送defaultguid">主控端发送DefaultGUID</h3>
<p>主动端向DS发送RPC时, 由于UTestActorComponent没有DS同步来的GUID,
默认使用DefaultGUID, 并在ContentBlockHeader中填入PathName和Outer.</p>
<p>主控端没有找到Object对应的GUID, 则使用DefaultGUID:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619205137385.png" /></p>
<p>当为Default时, 需要填入PathName和Outer</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619205005048.png" /></p>
<p>序列化NetGUID, FExportFlags, OuterGUID以及PathName.
注意这些消息是序列化在ContentBlockHeader里面的.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619210044542.png" /></p>
<p><strong>客户端向DS发送RPC, 某个UObject的GUID为1的时,
ContentBlockHeader和一般情况下有所不同:</strong></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230915152917652.png" /></p>
<p>堆栈:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619204722209.png" /></p>
<h3 id="ds解析defaultguid">DS解析DefaultGUID</h3>
<p>DS在解析主控端发来的RPC时, 发现GUID为DefaultGUID. 就要继续往下处理.
解析ExportFlags等信息.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230915153247386.png" /></p>
<p>序列化FExportFlags</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619210319359.png" /></p>
<p>ExportFlags.bHasPath为true, 需要加载</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619210620670.png" /></p>
<p>对DefaultGUID对应的Obj进行查找, 注意这里一定是查找,
因为它不会进行创建.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619202412034.png" /></p>
<p>最后还要将该UTestActorComponent的GUID序列化到OutGUIDBunch中,
发送给主控端.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619202532713.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619202655622.png" /></p>
<p>堆栈:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619202208930.png" /></p>
<p><strong>注意:</strong> 如果该Obj没有找到, 则直接将Bunch设置为Error,
然后丢弃.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230630101058852.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230630101314582.png" /></p>
<p>发现bunch Error了, 直接close掉了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230630101407727.png" /></p>
<p>在这里加上返回代码, 会直接close connection</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230630102052996.png" /></p>
<h3 id="总结-2">总结</h3>
<p>在主控端, 如果一个Obj在没有获得DS分配的GUID时就要向DS发送RPC,
那么就会将DefaultGUID作为Obj的GUID, 并附带Flag+OuterGUID+PathName.
一同发往DS. DS解析之后, 还要将Obj的最终GUID同步到主控端. 如果解析错误,
包括但不显示DS没有找到对应的Obj, 则直接将bunch close掉.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619210044542-1687181291299-1.png" /></p>
<p>并且得出一个结论: 即使没有在属性上添加Replicated标志,
也可以通过Outer和PathName关联, 然后进行RPC.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230630102747402.png" /></p>
<p>通过上文可以知道, 如果一个Obj在发送RPC的时候,
其自身还没有GUID,则需要将OuterGUID+PathName发送给DS,
根据该信息DS可以找到对应的Obj. 但是如果客户端此时Outer也没有呢?</p>
<p>递归处理, 即在客户端没有RegisterGUID的Obj都当做DefaultGUID,
然后附加OuterGUID+PathName发送给DS.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230630114446696.png" /></p>
<h2 id="静态uobject与networkguid绑定">静态UObject与NetworkGUID绑定</h2>
<p>静态物体在World中是唯一的, 可以通过PathName唯一确定.
可以为静态物体用NetworkGUID+PathName唯一确定.</p>
<h3 id="什么情况下需要同步">什么情况下需要同步</h3>
<p>客户端和DS的两个UObject, 在什么情况下需要同步呢?</p>
<p><strong>情况1: 作为动态Object的Outer</strong></p>
<p>当一个UObject创建时,需要传入Outer,
查询一个UObject也可以根据Outer去查询. 当DS上需要创建UObject时候,
需要根据Outer进行创建. 当同步到客户端时, 也需要将Outer信息附带传过去.
所以, 当一个静态UObject作为动态UObject的Outer时候,
需要将Outer信息传输过去. 因为静态UObject是全局唯一的, 每次传输费时费力,
有没有好的方法传输一次永久使用的?</p>
<p>答案就是在客户端首次需要该静态UObject时, 为其分配GUID,
并传输到客户端, 后续可以通过GUID直接使用.</p>
<p><strong>情况2:放置类Actor需要Replicated</strong></p>
<p>如果一个Actor需要属性同步,
那么一定需要通过GUID将其在不同端的UObject绑定.</p>
<h3 id="数据传输">数据传输</h3>
<p>与<a href="#填充ExportBunch">填充ExportBunch</a>流程一致.
将需要传输的GUID序列化到ExportBunch中.</p>
<h3 id="绑定uobject">绑定UObject</h3>
<p>与<a href="#解析ExportBunch">解析Export</a>流程一致.
当解析ExportBunch时, 都通过查询或者加载找到对应的UObject,
然后将其注册到FNetGUIDCache.ObjectLookup中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621211347954.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621211305833.png" /></p>
<p>然后将UObject与GUID绑定:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621211652593.png" /></p>
<h3 id="cdo类型关联">CDO类型关联</h3>
<p>当序列化一个新的Actor时, 会将Actor+Archetype序列化到网络字节流中.
其中Actor的Archetype为CDO.</p>
<p>对于PlayerController而言,
其序列化的对象为PlayerController+Default__NewPlayerController_C,
在序列化Default__NewPlayerController_C时候,
依据RF_ClassDefaultObject将其判定位静态类型.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619215617422.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620141940779.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620142107099.png" /></p>
<p>在客户端进行反序列化时, 将Archetype序列化出来.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620142655753.png" /></p>
<p>然后根据archetype的UClass SpawnActor.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620142944464.png" /></p>
<p><strong>这里没有直接传输UClass而用的Archetype, 原因是创建的时候,
template使用了Archetype.</strong></p>
<p>并且从一下代码可以看出就是CDO:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230622155424759.png" /></p>
<p>如果DS创建一个UObject, 传递到远端. 会序列化CDO吗?</p>
<p>针对ActorComp类型, 构建测试用例, DS创建,
查看其怎么序列化到网络字节流中, 并在远端的创建方式.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ABasePlayerController::Tick</span><span class="params">(<span class="type">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaSeconds);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetLocalRole</span>() == ENetRole::ROLE_Authority)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TestReplicationComp2)</span><br><span class="line">        &#123;</span><br><span class="line">            TestReplicationComp2 = <span class="built_in">NewObject</span>&lt;UTestReplicationComp&gt;(<span class="keyword">this</span>, UTestReplicationComp::<span class="built_in">StaticClass</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>DS上, 在UActorChannel::WriteContentBlockHeader中,
序列化到网络流的内容为UObjectGUID+UClassGUID.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620144847477.png" /></p>
<p>客户端上, 反序列化在UActorChannel::ReadContentBlockHeader中,
反序列化出UObjectGUID+UClassGUID, 然后进行创建:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620145917713.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620145838758.png" /></p>
<p>自定义UObject类型在DS上创建以及同步到远端创建的流程.</p>
<p>DS将UObject的UClass序列化到网络字节流中.
UObjectGUID+UObjectClassGUID.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620150426572.png" /></p>
<p>远端通过反序列化UObjectUClass进行创建.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230620150153584.png" /></p>
<p><strong>综上, Actor会传递Archetype(CDO),
其他类型都会传递UClass.</strong></p>
<h2 id="动态uobject与networkguid绑定">动态UObject与NetworkGUID绑定</h2>
<p>动态物体一般由DS先创建, 然后在DS上分配NetworkGUID,
通过ContentBlockHeader同步给其他端, 进行创建. 但是对于DefaultSubObject,
它在客户端先进行创建, 然后通过Outer+Name与DS进行关联.</p>
<h3 id="actor与guid绑定">Actor与GUID绑定</h3>
<p>DS先进行创建, 当创建消息同步到客户端之后, 客户端才进行创建,
并同时创建ActorChannel.</p>
<h4 id="ds序列化">DS序列化</h4>
<p>在DS端, 如果Actor是第一次同步, 即初始化(RepFlags.bNetInitial为true),
则序列化Actor. 将Actor的GUID序列化到网络字节流中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230622110521487.png" /></p>
<p>序列化Actor及其GUID.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230622110618496.png" /></p>
<p>然后再序列化Actor的Archetype和ActorLevel</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230622111024318.png" /></p>
<p>这样就将Actor的GUID, Actor Archetype的GUID,
ActorLevel的GUID信息都序列化到Bunch中了, 而且该Bunch必为Reliable.</p>
<h4 id="客户端反序列化">客户端反序列化</h4>
<p>在客户端检测如果Channel的Actor为nullptr,
则直接开始反序列Actor的化逻辑:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230622154856819.png" /></p>
<p>然后根据Archetype+ActorLevel进行创建.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230622154949728.png" /></p>
<p>堆栈:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230622155035700.png" /></p>
<p>综上, 根据DS传来的信息archetype+ActorLevel创建Actor.
这里需要注意的是, ActorLevel就作为Actor Outer.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230622162545484.png" /></p>
<h3
id="createdefaultsubobject与guid绑定">CreateDefaultSubobject与GUID绑定</h3>
<p>DS和客户端各自进行创建, 通过Outer和Name查找到指定UObj,
然后进行绑定.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623171456561.png" /></p>
<p>在DS序列化UObjectGUID和ClassGUID到ContentBlockHeader中时,
有一个字段IsNameStable会标明当前UObject是否为NameStable.
<strong>对于DefaultSubObject, IsNameStable为1</strong>,
该UObject不会在序列化时候进行创建, 而是通过查询获得.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623171747680.png" /></p>
<p>由于DefaultSubObject是在构造函数中创建的,
如果一个对象在处理它属性的赋值, 那么该对象一定已经创建过了,
即其一定执行了构造函数, 那么它的DefaultSubObject一定存在, 所以,
直接查询绑定即可.</p>
<p>在<a
href="#填充ExportBunch">填充ExportBunch</a>中已经详细讲述了DefaultSubObject在ExportBunch中序列化/反序列化的流程,
这里不再赘述. 如果一个Bunch中使用了DefualtSubObject的GUID,
那么该GUID一定是已经在之前传输过了, 或者该Bunch之前一定有ExportBunch,
该GUID已经在该ExportBunch中解析过了. 结论就是, 不用创建, 一定能查到.</p>
<h3 id="动态创建的subobject绑定guid">动态创建的SubObject绑定GUID</h3>
<p>客户端解析ExportBunch的内容,
根据OuterGUID+PathName注册到FNetGUIDCache.ObjectLookup中</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621102948773.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621103529362.png" /></p>
<p>注意, 在处理ExportBunch时, 很有可能并没有找到对应的UObject, 没关系,
此时只要把解析到的GUID以及其相关信息(OuterGUID+PathName)填入FNetGUIDCache.ObjectLookup中,
等到后续使用中再次尝试与UObj绑定.</p>
<p>例如, 上面在尝试绑定GUID为2的UObj时失败. 从上帝视角知道,
2为NewPlayerController_C_0, 即PlayerController,
没有找到它的原因是客户端此时还没创建该对象,
所以在处理ExportBunch的下一个bunch时,
最开始的处理逻辑就是创建PlayerController, 并绑定对应的GUID.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621104828941.png" /></p>
<p>反序列化Item处理TestReplicationComp1时,
根据PathName+Outer查找对应的UObj.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621113448492.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230621113528133.png" /></p>
<p>这样客户端就将TestReplicationComp1与GUID(6)绑定了.</p>
<p>DS和客户端各自进行创建, 通过Outer和Name查找到指定UObj,
然后进行绑定.</p>
<h3 id="自定义uobject与guid绑定">自定义UObject与GUID绑定</h3>
<p>自定义UObject进行属性同步的方式:<a href="/2023/11/09/UE/%E7%BD%91%E7%BB%9C/%E8%87%AA%E5%AE%9A%E4%B9%89UObject%E8%BF%9B%E8%A1%8CReplicate/" title="自定义UObject进行Replicate">自定义UObject进行Replicate&#39;</a></p>
<h4 id="ds序列化uobj">DS序列化UObj</h4>
<p>DS在序列化UMyTestObject时,
会将ObjGUID+UClassGUID序列化到ContentBlockHeader中(通过函数:UActorChannel::WriteContentBlockHeader).</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623114403392.png" /></p>
<h4 id="客户端解析uobj">客户端解析UObj</h4>
<p>根据SubObj的GUID尝试寻找对应的UObj, 如果是第一次, 则这里应该是空,
因为需要客户端创建.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623142935510.png" /></p>
<p>然后根据ClassGUID查询对应的UClass</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623143343891.png" /></p>
<p>最后进行创建并注册GUID</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623143806582.png" /></p>
<h4 id="ds删除uobj">DS删除UObj</h4>
<p>每次进行Replicate时候,
都会遍历当前Channel的所有UActorChannel.ReplicationMap,
如果发现里面Obj不可用了, 就会进行销毁.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623144446834.png" /></p>
<h4 id="客户端删除uobj">客户端删除UObj</h4>
<p>客户端删除逻辑的处理是在UActorChannel::ReadContentBlockHeader函数中进行的,
即与普通ContentBlockHeader结构一样.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623172614401.png" /></p>
<p>在序列化ClassNetGUID时, 如果为0, 则将该UObject看做待删除UObject,
执行清理逻辑.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623172650998.png" /></p>
<h4 id="属性成员与uobj绑定">属性成员与UObj绑定</h4>
<h5 id="直接绑定">直接绑定</h5>
<p>当能找到GUID对应Obj时候, 直接设置对应的值.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628211319318.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628211343784.png" /></p>
<h5 id="延迟绑定">延迟绑定</h5>
<p>详情参考:<a href="/2023/11/09/UE/%E7%BD%91%E7%BB%9C/GUID%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/" title="GUID延迟绑定">GUID延迟绑定</a></p>
<h4 id="总结-3">总结</h4>
<ol type="1">
<li>注意观察ContentBlockHeader中的逻辑, 每次DS都会序列化SubObj+Class,
而客户端只是解析, 如果没有就会创建, 有就会拿出来直接使用.</li>
<li>UObject的删除逻辑掺杂在ContentBlockHeader中, 当ClassNetGUID为0时候,
即为删除. 充分复用ContentBlockHeader结构.</li>
<li>在序列化属性值后, 如果找到对应的UObj, 则直接绑定,
否则将其放入UnmappedGUID中, 每帧tick检测, 然后进行绑定,
而且延迟绑定都发生在一帧内.</li>
</ol>
<h1 id="总结-4">总结</h1>
<ul>
<li>GUID的创建永远在DS, 客户端永远是被动绑定.</li>
<li>静态UObject全部通过查找/加载找到, 然后与GUID绑定.</li>
<li>动态UObject主要通过创建并辅以查找(SubDefaultObj)方式与GUID进行绑定.
<strong>而且永远都是客户端反序列化某个GUID时候, 才会去创建或者查找.
如果是延迟创建(即没有找到对应UObj)的还要通过轮询UnmapGUID进行绑定</strong></li>
</ul>
<p>这里顺带说一下,
ExportBunch有可能仅仅只注册了GUID+OuterGUID+PathName等信息,
等到真正反序列化数据时才会将GUID和UObject绑定.</p>
<h1 id="思考-1">思考</h1>
<h2
id="放置在场景中的actor不能进行rpc-只能属性同步.">放置在场景中的Actor不能进行RPC,
只能属性同步.</h2>
<p>默认不可以, 因为其Owner没有Connection.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619163539542.png" /></p>
<p>例如:对于Pawn类型, 如果其有对应的Controller,
会通过Controller查找NetConnection,
那么其就是主角对应的Pawn(每个客户端只有一个PlayerController,
就是主角自己), 所以其可以进行属性同步.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230619164045496.png" /></p>
<p>如果将一个Actor进行RPC, 需要重写AActor::GetNetConnection(),
或者其Owner具有Connection就可以.</p>
<h2
id="当一个acotrchannel还没有创建-属性同步已经到来-会怎么处理">当一个AcotrChannel还没有创建,
属性同步已经到来, 会怎么处理?</h2>
<p>如果Actor第一次属性同步, 则会在Bunch头添加SerializeNewActor.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230630172122474.png" /></p>
<p>如果非创建Bunch, 则直接为后边的属性同步.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230630172201482.png" /></p>
<p>客户端检测, 由于不是OpenBunch, 所以直接返回了. 整个bunch直接丢弃.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230630174515701.png" /></p>
<p>日志输出如下内容, 刚好和代码中error一致.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="number">2023.06</span><span class="number">.30</span><span class="number">-17.43</span><span class="number">.39</span><span class="string">:385</span>][<span class="number">571</span>]<span class="attr">LogNetTraffic: Error: UActorChannel::ProcessBunch: New actor channel received non-open packet. bOpen:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">bClose:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">bReliable:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">bPartial:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">bPartialInitial:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">bPartialFinal:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">ChName:</span> <span class="string">Actor,</span> <span class="attr">ChIndex:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Closing:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">OpenedLocally:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">OpenAcked:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">NetGUID:</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230630174559728.png" /></p>
<h1 id="回答课前提问">回答课前提问</h1>
<ol type="1">
<li><p>NetworkGUID是什么?</p>
<p>NetworkGUID是uint32, 在网络中传输, 用来关联不同端的Obj.</p></li>
<li><p>动态UObject, 静态UObject是什么,
DS和客户端的Obj是怎么关联起来的?</p>
<p>是UE用于网络传输而特意划分的Obj类型, 是通过GUID关联起来的,
关联方式详看文中解析.</p></li>
<li><p>Actor是怎么创建, 以及其属性是怎么同步的?'</p>
<p>客户端通过SerializeActor创建,
属性同步是通过ContentBlockHeader+ContentBlockPayload进行同步.</p></li>
<li><p>针对DefaultSubObj, 客户端和DS怎么关联起来?</p>
<p>通过OuterGUID+PathName关联起来的.</p></li>
<li><p>自定义UObject怎么进行网络同步, 怎么在客户端创建,
其所占用的Bunch是否变为Reliable?</p>
<p>需要重写ReplicatedSubObj函数, 创建方式依旧通过PalyloadHeader解析,
如果没有找到Obj就会创建.
只有删除Obj的bunch才会被标记为Reliable.</p></li>
<li><p>怎么将变量的值和其对应的UObject关联起来?
例如BasePlayerController有个UMyTestObject类型变量pTestObj,
客户端的它是怎么创建, 并和BasePlayerController.pTestObj关联起来?</p>
<p>静态GUID是查询, 动态GUID是创建.
而指针是在对已有Object绑定之后的查询赋值. 即通过GUID查找后, 进行赋值.
这里值得注意的是, UE都是通过偏移直接取地址, 根据FProperty进行操作赋值的.
特别的抽象.</p></li>
</ol>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>NetworkGUID</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>NetworkGUID</tag>
      </tags>
  </entry>
  <entry>
    <title>InitOnly RPC MulticastRPC(Reliable+Unreliable) BeginPlay的执行顺序</title>
    <url>/2023/11/11/UE/%E7%BD%91%E7%BB%9C/InitOnly%20RPC%20MulticastRPC%20BeginPlay%E7%9A%84%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231119110314263.png"
alt="image-20231119110314263" />
<figcaption aria-hidden="true">image-20231119110314263</figcaption>
</figure>
<span id="more"></span>
<h1 id="导言">导言</h1>
<p>需要验证的情况大致分成两类,
开启/未开启<code>net.AllowAsyncLoading</code>,
每类又包含如下细分情况:</p>
<ol type="1">
<li><p><code>SpawnActor</code>, <code>BeginPlay</code>,
<code>InitOnly</code> <code>RPC</code>
<code>MulticastRPC(Reliable+Unreliable)</code>的详细流程</p></li>
<li><p>针对<code>Actor</code>本身, <code>InitOnly</code>
<code>RPC</code> <code>MulticastRPC(Reliable+Unreliable)</code>
<code>BeginPlay</code>的执行顺序</p>
<ul>
<li><p>动态创建的<code>Actor</code></p></li>
<li><p>场景中摆放的<code>Actor</code></p></li>
</ul></li>
<li><p>针对非指针类型的变量, 例如<code>int32</code>,
<code>float</code>等.</p></li>
<li><p>针对指针类型<code>Replicate</code>变量:</p>
<ul>
<li>指针对象已经存在.</li>
<li>指针对象不存在.</li>
<li>特殊的, 要详细说明以下类型:
<ul>
<li>针对<code>Default Sub ActorComponent</code>, <code>InitOnly</code>
<code>RPC</code> <code>MulticastRPC(Reliable+Unreliable)</code>
<code>BeginPlay</code>的执行顺序</li>
<li>针对按需创建的<code>SubActorComponent</code>, <code>InitOnly</code>
<code>RPC</code> <code>MulticastRPC(Reliable+Unreliable)</code>
<code>BeginPlay</code>的执行顺序</li>
</ul></li>
</ul></li>
</ol>
<h1 id="前置知识">前置知识</h1>
<p>想要了解清楚上述各种情况下的执行顺序,
必须先搞清楚<code>BeginPlay</code>, <code>InitOnly</code>,
<code>RPC</code>,
<code>MulticastRPC(Reliable+Unreliable)</code>自身的执行顺序,
然在再将情况变得复杂, 即<code>控制变量法</code>:先了解清楚简单情况,
再加入各种变量, 逐步扩延展到各种复杂情况.</p>
<h2 id="beginplay执行顺序"><code>BeginPlay</code>执行顺序</h2>
<p>官方给出的<code>Actor</code>生命周期中<code>BeginPlay</code>所处的时机(<a
href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/ActorLifecycle/">Actor
生命周期</a>).</p>
<figure>
<img
src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/ActorLifecycle/ActorLifeCycle1.jpg"
alt="ActorLifeCycle.png" />
<figcaption aria-hidden="true">ActorLifeCycle.png</figcaption>
</figure>
<p>UE中有三种SpawnActor的方法, 针对这三种创建Actor的方式,
依次查看其BeginPlay的时机.</p>
<ol type="1">
<li>主动创建:UWorld.SpawnActor</li>
<li>网络同步过来需要创建的Actor: SpawnActorAbsolute</li>
<li>UWorld.SpawnActorDeferred+AActor.FinishSpawning</li>
</ol>
<h3 id="spawnactor"><code>SpawnActor</code></h3>
<p>DS端, 主动使用<code>UWorld.SpawnActor</code>创建<code>Actor</code>,
<code>Actor</code>和<code>DefaultSubActorComponent</code>的<code>BeginPlay</code>执行顺序.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113162832584.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ALSV: ATestRepFlowActor::ATestRepFlowActor FrameIndex[<span class="number">1113</span>] RoleType[ROLE_Authority]</span><br><span class="line">ALSV: UTestRepFlowDefaultCmp::BeginPlay FrameIndex[<span class="number">1113</span>] RoleType[ROLE_Authority] Owner[BPTestRepFlowSpawnedActor_C_0]</span><br><span class="line">ALSV: ATestRepFlowActor::BeginPlay FrameIndex[<span class="number">1113</span>] RoleType[ROLE_Authority]</span><br></pre></td></tr></table></figure>
<p>从日志上可以看出,
在<code>DS</code>端执行顺序为:<code>UTestRepFlowDefaultCmp::BeginPlay</code>-&gt;<code>ATestRepFlowActor::BeginPlay</code>.
详细堆栈为:</p>
<table>
<tr>
<td bgcolor="#D5E8D4">
<p style="line-height:1.5;">
创建Actor的BeginPlay堆栈+DefaultSubComp BeginPlay的堆栈 <br>
--UWorld.SpawnActor <br> |--UWorld.SpawnActor <br> |
|--AActor.PostSpawnInitialize.if <br> | | |--<span
style="color:red;">AActor.FinishSpawning //
这个函数可以独立出来执行</span> <br> | | |
|--AActor.PostActorConstruction <br> | | | | |--AActor.DispatchBeginPlay
<br> | | | | | |--ATestRepFlowSpawnedActor.BeginPlay <br> | | | | | |
|--AActor.BeginPlay <br> | | | | | | | |--// for all components
BeginPlay <br> | | | | | | | |--UTestRepFlowDefaultCmp.BeginPlay &lt;br
</p>
</td>
</tr>
</table>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231114093421518.png" /></p>
<h3 id="spawnactorabsolute"><code>SpawnActorAbsolute</code></h3>
<p>当网络数据中需要创建Actor, 则会调用该函数进行创建. 详细堆栈:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 远端, 根据Bunch被动创建, 不会立即执行BeginPlay, 而是等待处理完这个Bunch的所有消息才执行BeginPlay</span></span><br><span class="line">--UActorChannel.ProcessBunch.<span class="keyword">if</span> </span><br><span class="line">|--UPackageMapClient.SerializeNewActor</span><br><span class="line">| |--UWorld.SpawnActorAbsolute </span><br><span class="line">| | |--UWorld.SpawnActor </span><br><span class="line">| | | |--AActor.PostSpawnInitialize.<span class="keyword">if</span> </span><br><span class="line">| | | | |--AActor.FinishSpawning.<span class="keyword">if</span>.&#123; </span><br><span class="line">| | | | | |--AActor.PostActorConstruction</span><br><span class="line">| | | | | | |--<span class="comment">// 对于根据Bunch创建的Actor, 不会立即执行BeginPlay</span></span><br><span class="line">| | | | | | |--<span class="type">const</span> <span class="type">bool</span> bDeferBeginPlayAndUpdateOverlaps = (bExchangedRoles &amp;&amp; RemoteRole == ROLE_Authority) &amp;&amp; !GIsReinstancing;</span><br><span class="line">| | | | | | |--<span class="type">bool</span> bRunBeginPlay = !bDeferBeginPlayAndUpdateOverlaps &amp;&amp; (BeginPlayCallDepth &gt; <span class="number">0</span> || World-&gt;<span class="built_in">HasBegunPlay</span>());</span><br><span class="line">|--<span class="comment">// 处理Bunch中ContentBlock内容</span></span><br><span class="line">|--<span class="comment">// After all properties have been initialized, call PostNetInit. This should call BeginPlay() so initialization can be done with proper starting values.</span></span><br><span class="line">|--<span class="keyword">if</span> (Actor &amp;&amp; bSpawnedNewActor)</span><br><span class="line">|--&#123;</span><br><span class="line">|--    <span class="built_in">SCOPE_CYCLE_COUNTER</span>(Stat_PostNetInit);</span><br><span class="line">|--    Actor-&gt;<span class="built_in">PostNetInit</span>();</span><br><span class="line">| |--<span class="comment">// 如果Actor没有执行BeginPlay, 就会执行BeginPlay</span></span><br><span class="line">| |--AActor.DispatchBeginPlay </span><br><span class="line">| | |--AActor.BeginPlay </span><br><span class="line">| | | |--ATestRepFlowSpawnedActor.BeginPlay </span><br><span class="line">| | |--AActor.UpdateInitialOverlaps </span><br><span class="line">|--&#125;</span><br></pre></td></tr></table></figure>
<p>UE针对依据Bunch创建的Actor, 特意将BeginPlay延迟. 但是可以看出,
即使延迟执行BeginPlay, 但是Actor和Components也立即进行了Initialize.
即调用了<code>AActor.PreInitializeComponents</code>和<code>AActor.InitializeComponents</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231114102401410.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231114202232062.png" /></p>
<h4 id="延迟原因">延迟原因</h4>
<p>最早的版本就这样, 已经无法再查了. 再查就要往UE3查了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116152504482.png" /></p>
<h3
id="spawnactordeferredfinishspawning"><code>SpawnActorDeferred+FinishSpawning</code></h3>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231115172952165.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231115173239392.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231115173340401.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231115173715899.png" /></p>
<p>从上图可以清晰看到,
<code>SpawnActorDeferred</code>不会调用<code>FinishSpawning</code>,
也就不会初始化Actor Components, 以及调用BeginPlay了.
<code>FinishSpawning</code>需要手动调用, 即逻辑分开,
UE提供了另一种方式供大家使用, 以便满足千变万化的需求.</p>
<h2
id="initonly及其onrep执行顺序"><code>InitOnly</code>及其<code>OnRep</code>执行顺序</h2>
<h3 id="onrep为何物"><code>OnRep</code>为何物</h3>
<p>OnRep为何物, 依据什么填充的, 又是怎么触发回调的, 以及怎么清除的?</p>
<h4 id="构建onrep信息">构建OnRep信息</h4>
<p>在Replayout中构建需要同步属性的Onrep信息,
<code>RepNotifyCondition</code>+<code>RepNotifyNumParams</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Replayout中OnRep相关设置初始化流程</span></span><br><span class="line">--FRepLayout.InitFromClass </span><br><span class="line">|--<span class="comment">// 遍历所有LifetimeProps, 设置其RepNotifyCondition和RepNotifyNumParams</span></span><br><span class="line">|--Parents[ParentIndex].RepNotifyCondition = LifetimeProps[i].RepNotifyCondition;</span><br><span class="line">|--<span class="keyword">if</span> (UFunction* RepNotifyFunc = InObjectClass-&gt;<span class="built_in">FindFunctionByName</span>(Parents[ParentIndex].Property-&gt;RepNotifyFunc))</span><br><span class="line">|--&#123;</span><br><span class="line">|--    Parents[ParentIndex].RepNotifyNumParams = RepNotifyFunc-&gt;NumParms;</span><br><span class="line">|--&#125;</span><br></pre></td></tr></table></figure>
<h4 id="onrep设置回调和清理">OnRep设置,回调和清理</h4>
<p>在客户端收到DS发来的Bunch解析后, 设置属性内容, 并记录其OnRep信息.
如果需要OnRep, 则放入<code>FReceivingRepState.RepNotifies</code>中.
佐证代码:</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118125441054.png"
alt="image-20231118125441054" />
<figcaption aria-hidden="true">image-20231118125441054</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OnRep设置以及回调堆栈</span></span><br><span class="line">--UNetDriver.TickFlush.<span class="keyword">if</span> </span><br><span class="line">|--UIpConnection.Tick </span><br><span class="line">| |--UNetConnection.Tick.<span class="keyword">else</span>.<span class="keyword">if</span>.<span class="keyword">for</span> </span><br><span class="line">| | |--UActorChannel.ProcessQueuedBunches.<span class="keyword">if</span>.<span class="keyword">if</span>.<span class="keyword">for</span> </span><br><span class="line">| | | |--UActorChannel.ProcessBunch.<span class="keyword">while</span> </span><br><span class="line">| | | | |--FObjectReplicator.ReceivedBunch.<span class="keyword">if</span> </span><br><span class="line">| | | | | |--FRepLayout.ReceiveProperties </span><br><span class="line">| | | | | | |--ReceiveProperties_r.<span class="keyword">for</span>.<span class="keyword">else</span>.<span class="keyword">else</span> </span><br><span class="line">| | | | | | | |--ReceivePropertyHelper.<span class="keyword">if</span> </span><br><span class="line">| | | | | | | | |--<span class="comment">// Read the property</span></span><br><span class="line">| | | | | | | | |--Cmd.Property-&gt;<span class="built_in">NetSerializeItem</span>(Bunch, Bunch.PackageMap, Data + SwappedCmd);</span><br><span class="line">| | | | | | | | |--<span class="comment">// 如果需要, 则将Property放入RepNotify中</span></span><br><span class="line">| | | | | | | | |--RepNotifies-&gt;<span class="built_in">AddUnique</span>(Parent.Property);</span><br><span class="line">| | |--UActorChannel.ProcessQueuedBunches.<span class="keyword">if</span>.<span class="keyword">if</span> </span><br><span class="line">| | | |--FObjectReplicator.CallRepNotifies </span><br><span class="line">| | | | |--FRepLayout.CallRepNotifies.<span class="keyword">for</span>.<span class="keyword">switch</span>.&#123; </span><br><span class="line">| | | | | |--<span class="keyword">for</span> (FProperty* RepProperty : RepState-&gt;RepNotifies) &#123;</span><br><span class="line">| | | | | |--    <span class="comment">// 遍历所有FReceivingRepState.RepNotifies, 执行OnRep</span></span><br><span class="line">| | | | | |--    <span class="comment">// 找到OnRep对应的UFunction</span></span><br><span class="line">| | | | | |--    UFunction* RepNotifyFunc = Object-&gt;<span class="built_in">FindFunction</span>(RepProperty-&gt;RepNotifyFunc);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="comment">// 如果0个参数, 直接调用OnRep</span></span><br><span class="line">| | | | | |--    Object-&gt;<span class="built_in">ProcessEvent</span>(RepNotifyFunc, <span class="literal">nullptr</span>);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="comment">// 如果一个参数, 则该参数为旧历史数据</span></span><br><span class="line">| | | | | |--    FRepShadowDataBuffer PropertyData = ShadowData + Parent;</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="keyword">if</span> (<span class="built_in">EnumHasAnyFlags</span>(Parent.Flags, ERepParentFlags::IsCustomDelta))</span><br><span class="line">| | | | | |--    &#123;</span><br><span class="line">| | | | | |--        Object-&gt;<span class="built_in">ProcessEvent</span>(RepNotifyFunc, PropertyData);</span><br><span class="line">| | | | | |--    &#125;</span><br><span class="line">| | | | | |--    <span class="keyword">else</span></span><br><span class="line">| | | | | |--    &#123;</span><br><span class="line">| | | | | |--        <span class="comment">// Handle bitfields.</span></span><br><span class="line">| | | | | |--        <span class="type">const</span> FBoolProperty* BoolProperty = <span class="built_in">CastField</span>&lt;<span class="type">const</span> FBoolProperty&gt;(Parent.Property);</span><br><span class="line">| | | | | |--        <span class="keyword">if</span> (BoolProperty &amp;&amp; !BoolProperty-&gt;<span class="built_in">IsNativeBool</span>())</span><br><span class="line">| | | | | |--        &#123;</span><br><span class="line">| | | | | |--            <span class="type">bool</span> BoolPropertyValue = BoolProperty-&gt;<span class="built_in">GetPropertyValue</span>(PropertyData);</span><br><span class="line">| | | | | |--            Object-&gt;<span class="built_in">ProcessEvent</span>(RepNotifyFunc, &amp;BoolPropertyValue);</span><br><span class="line">| | | | | |--        &#125;</span><br><span class="line">| | | | | |--        <span class="keyword">else</span></span><br><span class="line">| | | | | |--        &#123;</span><br><span class="line">| | | | | |--            Object-&gt;<span class="built_in">ProcessEvent</span>(RepNotifyFunc, PropertyData);</span><br><span class="line">| | | | | |--        &#125;</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--        <span class="comment">// now store the complete value in the shadow buffer</span></span><br><span class="line">| | | | | |--        <span class="keyword">if</span> (!<span class="built_in">EnumHasAnyFlags</span>(Parent.Flags, ERepParentFlags::IsNetSerialize))</span><br><span class="line">| | | | | |--        &#123;</span><br><span class="line">| | | | | |--            RepProperty-&gt;<span class="built_in">CopyCompleteValue</span>(ShadowData + Parent, ObjectData + Parent);</span><br><span class="line">| | | | | |--        &#125;</span><br><span class="line">| | | | | |--    &#125;</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="comment">// 如果为两个参数, 则</span></span><br><span class="line">| | | | | |--    <span class="built_in">check</span>(<span class="built_in">EnumHasAnyFlags</span>(Parent.Flags, ERepParentFlags::IsCustomDelta));</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="comment">// Fixme: this isn&#x27;t as safe as it could be. Right now we have two types of parameters: MetaData (a TArray&lt;uint8&gt;)</span></span><br><span class="line">| | | | | |--    <span class="comment">// and the last local value (pointer into the Recent[] array).</span></span><br><span class="line">| | | | | |--    <span class="comment">//</span></span><br><span class="line">| | | | | |--    <span class="comment">// Arrays always expect MetaData. Everything else, including structs, expect last value.</span></span><br><span class="line">| | | | | |--    <span class="comment">// This is enforced with UHT only. If a ::NetSerialize function ever starts producing a MetaData array thats not in FArrayProperty,</span></span><br><span class="line">| | | | | |--    <span class="comment">// we have no static way of catching this and the replication system could pass the wrong thing into ProcessEvent here.</span></span><br><span class="line">| | | | | |--    <span class="comment">//</span></span><br><span class="line">| | | | | |--    <span class="comment">// But this is all sort of an edge case feature anyways, so its not worth tearing things up too much over.</span></span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="function">FMemMark <span class="title">Mark</span><span class="params">(FMemStack::Get())</span></span>;</span><br><span class="line">| | | | | |--    uint8* Parms = <span class="built_in">new</span>(FMemStack::<span class="built_in">Get</span>(), MEM_Zeroed, RepNotifyFunc-&gt;ParmsSize)uint8;</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="function">TFieldIterator&lt;FProperty&gt; <span class="title">Itr</span><span class="params">(RepNotifyFunc)</span></span>;</span><br><span class="line">| | | | | |--    <span class="built_in">check</span>(Itr);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    FRepShadowDataBuffer PropertyData = ShadowData + Parent;</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    Itr-&gt;<span class="built_in">CopyCompleteValue</span>(Itr-&gt;<span class="built_in">ContainerPtrToValuePtr</span>&lt;<span class="type">void</span>&gt;(Parms), PropertyData);</span><br><span class="line">| | | | | |--    ++Itr;</span><br><span class="line">| | | | | |--    <span class="built_in">check</span>(Itr);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    TArray&lt;uint8&gt; *NotifyMetaData = RepState-&gt;RepNotifyMetaData.<span class="built_in">Find</span>(RepProperty);</span><br><span class="line">| | | | | |--    <span class="built_in">check</span>(NotifyMetaData);</span><br><span class="line">| | | | | |--    Itr-&gt;<span class="built_in">CopyCompleteValue</span>(Itr-&gt;<span class="built_in">ContainerPtrToValuePtr</span>&lt;<span class="type">void</span>&gt;(Parms), NotifyMetaData);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    Object-&gt;<span class="built_in">ProcessEvent</span>(RepNotifyFunc, Parms);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    Mark.<span class="built_in">Pop</span>();</span><br><span class="line">| | | | | |--    <span class="keyword">break</span>;</span><br><span class="line">| | | | | |--&#125;</span><br><span class="line">| | | | | |--<span class="comment">// for循环遍历之后, 清理OnRep</span></span><br><span class="line">| | | | | |--RepState-&gt;RepNotifies.<span class="built_in">Empty</span>();</span><br><span class="line">| | | | | |--RepState-&gt;RepNotifyMetaData.<span class="built_in">Empty</span>();</span><br></pre></td></tr></table></figure>
<p>通过如上堆栈可以清晰看出,
在for循环遍历所有<code>FReceivingRepState.RepNotifies</code>处理完回调之后,
调用<code>RepState-&gt;RepNotifies.Empty();</code>清理本次的OnRep数据.
这样OnRep的设置和回调是可以分开进行的.</p>
<h3 id="initonly为何物"><code>InitOnly</code>为何物</h3>
<p><code>InitOnly</code>对应的枚举类型为<code>COND_InitialOnly</code>,
只随创建<code>Actor</code>的<code>Bunch</code>一起发送,
错过了就永远不会发送(Dormancy重新唤醒<code>RepFlags.bNetInitial</code>会为true,
会触发<code>COND_InitialOnly</code>的<code>OnRep</code>). 佐证代码:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113211817531.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113212226498.png" /></p>
<p><code>CompareParentProperty</code>返回<code>true</code>,
证明变量没有发生改变, 所以不会进行属性同步, 也就不会触发OnRep.
并且也可以反推出,
创建Actor的bunch一定包含<code>InitOnly</code>的所有数据.</p>
<h3
id="initonly的onrep流程"><code>InitOnly</code>的<code>OnRep</code>流程</h3>
<p><code>InitOnly</code>的<code>OnRep</code>流程和其他属性的OnRep流程完全一样,
UE是不会区分其是否为<code>InitOnly</code>的.
只不会<code>InitOnly</code>数据会和<code>SerializeActor</code>的数据放在同一个Bunch中.
这里再贴一下Bunch的结构, 参考: :<a href="/2023/11/09/UE/%E7%BD%91%E7%BB%9C/UE%E7%BD%91%E7%BB%9C-ReplicationActor/" title="UE网络-ReplicationActor">UE网络-ReplicationActor</a>及其相关文章.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/BunchArchetype-1694577437093-1.png"
alt="整体消息框架" />
<figcaption aria-hidden="true">整体消息框架</figcaption>
</figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116095559293.png" /></p>
<p><span style="color:red;">这里要特意指出一下</span>,
<code>AActor.PostNetInit</code>是特意为网络初始化时没有进行<code>BeginPlay</code>而添加的补充阶段,
即在网路层, 根据远端创建的Actor, 在这个bunch处理的末尾, 调用BeginPlay,
但是这时候, <code>OnRep</code>可能还没有进行调用.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116100250076.png" /></p>
<h4
id="开启net.allowasyncloading">开启<code>net.AllowAsyncLoading</code></h4>
<p>开启<code>net.AllowAsyncLoading</code>后,
SpawnActor+SerializeProperty+OnRep+BeginPlay详细堆栈</p>
<table>
<tr>
<td bgcolor="#D5E8D4">
--UNetDriver.TickFlush.if <br> |--UIpConnection.Tick <br> |
|--UNetConnection.Tick.else.if.for <br> | |
|--UActorChannel.ProcessQueuedBunches <br> | | |
|--UActorChannel.ProcessBunch.if <span style="color:red;"> <br> | | | |
|--// 创建Actor <br> | | | | |--UPackageMapClient.SerializeNewActor <br>
| | | | | |--UWorld.SpawnActorAbsolute </span> <br> | | | |
|--FObjectReplicator.ReceivedBunch.if <span style="color:red;"> <br> | |
| | | |--// 根据远端数据序列化本地变量 <br> | | | | |
|--FRepLayout.ReceiveProperties <br> | | | | | |
|--ReceiveProperties_r.for.else.else <br> | | | | | | |
|--ReceivePropertyHelper.if <br> | | | | | | | |
|--FProperty.NetSerializeItem </span> <br> | |
|--UActorChannel.ProcessQueuedBunches.if.if.for <span
style="color:red;"><br> | | | |--// 调用OnRep <br> | | |
|--FObjectReplicator.CallRepNotifies<br> | | | | |-- //这里特殊说明一下,
如果为QueuedBunches(即开启了net.AllowAsyncLoading),
则会在QueuedBunches为空的时候, 才执行. <br> | | | | |--if
(bSkipIfChannelHasQueuedBunches &amp;&amp; (OwningChannel &amp;&amp;
OwningChannel-&gt;QueuedBunches.Num() &gt; 0)) <br> | | | | |--{ <br> |
| | | |-- return; <br> | | | | |--} <br> | | | | |--// 调用 OnRep <br> |
| | | |--FRepLayout.CallRepNotifies </span><br />
| | |--UActorChannel.ProcessQueuedBunches.if.if.for <br> | | |
|--UActorChannel.ProcessBunch.if <span style="color:red;"><br> | | | |
|--// 调用BeginPlay <br> | | | | |--AActor.PostNetInit.if.if<br />
| | | | | |--AActor.DispatchBeginPlay.if </span><br>
</td>
</tr>
</table>
<p><span style="color:red;">这里要特意指出一下:</span>
当开启<code>net.AllowAsyncLoading</code>后,
在<code>FObjectReplicator.CallRepNotifies</code>中,
会判断<code>QueuedBunches</code>大小, 如果为0, 才会进行OnRep回调.
佐证代码:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116110325697.png" /></p>
<p>那<code>OnRep</code>什么时候回调呢?</p>
<p>答案: <code>ActorChannel</code>内,
<code>QueuedBunches</code>为0的时候, 即当前最后一个.</p>
<h4
id="未开启net.allowasyncloading">未开启<code>net.AllowAsyncLoading</code></h4>
<p>未开启<code>net.AllowAsyncLoading</code>后,
SpawnActor+SerializeProperty+OnRep+BeginPlay详细堆栈</p>
<table>
<tr>
<td bgcolor="#D5E8D4">
// 未开启net.AllowAsyncLoading后,
SpawnActor+SerializeProperty+OnRep+BeginPlay详细堆栈 <br>
--UIpNetDriver.TickDispatch <br>
|--UNetConnection.ReceivedRawPacket.if.if.if <br> |
|--UNetConnection.ReceivedPacket.while.{ <br> | |
|--UChannel.ReceivedRawBunch.else <br> | | |
|--UChannel.ReceivedNextBunch.if <br> | | | |
|--UChannel.ReceivedSequencedBunch <br> | | | | |
|--UActorChannel.ReceivedBunch <br> | | | | | |
|--UActorChannel.ProcessBunch.if <span style="color:red;"> <br> | | | |
| | | |--// 创建Actor <br> | | | | | | |
|--UPackageMapClient.SerializeNewActor.if.if.if.if.if <br> | | | | | | |
| |--UWorld.SpawnActorAbsolute <br> | | | | | | | | |
|--UWorld.SpawnActor </span> <br> | | | | | |
|--UActorChannel.ProcessBunch.if <br> | | | | | | |
|--FObjectReplicator.ReceivedBunch.if <span style="color:red;"> <br> | |
| | | | | | |--// 根据远端数据序列化本地变量 <br> | | | | | | | |
|--FRepLayout.ReceiveProperties <br> | | | | | | | | |
|--ReceiveProperties_r.for.else.else <br> | | | | | | | | | |
|--ReceivePropertyHelper.if <br> | | | | | | | | | | |
|--FProperty.NetSerializeItem </span> <br> | | | | | |
|--UActorChannel.ProcessBunch.if <span style="color:red;"> <br> | | | |
| | | |--// 调用OnRep <br> | | | | | | |
|--FObjectReplicator.CallRepNotifies <br> | | | | | | | |
|--FRepLayout.CallRepNotifies.for.switch.{ </span> <br> | | | | | |
|--UActorChannel.ProcessBunch.if <span style="color:red;"> <br> | | | |
| | | |--// 调用BeginPlay <br> | | | | | | | |--AActor.PostNetInit.if.if
<br> | | | | | | | | |--AActor.DispatchBeginPlay.if <br> | | | | | | | |
| |--ATestRepFlowSpawnedActor.BeginPlay </span> <br>
</td>
</tr>
</table>
<h4 id="总结">总结</h4>
<p>可以看出无论是否开启<code>net.AllowAsyncLoading</code>,
调用堆栈最后都是用<code>UActorChannel.ProcessBunch</code>处理bunch.
其中有所区别的地方为:开启<code>net.AllowAsyncLoading</code>可能会导致<code>QueuedBunches</code>中有数据,
造成<code>OnRep</code>延迟回调,
最终导致OnRep回调可能晚于<code>BeginPlay</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116145654549.png" /></p>
<p><span style="color:red;">针对QueuedBunches还有数据, 就不能执行OnRep,
这段代码作用是什么呢?</span> 通过查询提交记录得知, 是为了修复Replay
scrubbing后, Actor传送问题.</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">Github上搜索这个唯一编号:db9ddd66282065b33e9b71ffb7c58ed<span class="number">5f042b146</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116144752893.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116144821213.png" /></p>
<p><span style="color:red;">所以, 对于正常不需要Replay的情景,
可以直接干掉, 对于需要Replay的, 加上Replay判定.</span></p>
<h3
id="指针类型和非指针类型的initonly">指针类型和非指针类型的<code>InitOnly</code></h3>
<p>如果一个UObject指针也设置成了<code>InitOnly</code>类型,
那么它一定会传输吗?</p>
<p>当UObject在Actor创建时候就已经设置对应的值, 那么可能会被传输.
测试代码(这里还引申出ActorComponent网络归属权问题,
详见:<a href="/2023/11/18/UE/%E7%BD%91%E7%BB%9C/Component%20Replication%E5%BD%92%E5%B1%9E%E6%9D%83/" title="Component Replication归属权">Component Replication归属权</a>):</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118170437535.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">开启net.AllowAsyncLoading后, 执行流程的一种情况为:</span><br><span class="line">ATestRepFlowSpawnedActor::ATestRepFlowSpawnedActor</span><br><span class="line">-&gt;ATestRepFlowSpawnedActor.mTestNumber Init</span><br><span class="line">-&gt;UTestRepFlowSpawnedCmp::UTestRepFlowSpawnedCmp</span><br><span class="line">-&gt;UTestRepFlowSpawnedCmp.TestNumber Init</span><br><span class="line">-&gt;AActor.PostNetInit</span><br><span class="line">-&gt;ATestRepFlowSpawnedActor.BeginPlay </span><br><span class="line">-&gt;Super::<span class="built_in">BeginPlay</span>(); <span class="comment">// Actor::BeginPlay()</span></span><br><span class="line">-&gt;UTestRepFlowSpawnedCmp.BeginPlay </span><br><span class="line">-&gt;ATestRepFlowSpawnedActor.OnRep_TestNumber </span><br><span class="line">-&gt;UTestRepFlowSpawnedCmp.OnRep_TestNumber </span><br><span class="line">-&gt;ATestRepFlowSpawnedActor.OnRep_TestRepFlowSpawnedCmp </span><br></pre></td></tr></table></figure>
<p>首先把DS端ReplicateActor时序列化各种属性的顺序贴出来;</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118171033062.png"
alt="ReplicateActor" />
<figcaption aria-hidden="true">ReplicateActor</figcaption>
</figure>
<h4 id="反序列化actor">反序列化Actor</h4>
<p>首先<code>ATestRepFlowSpawnedActor::ATestRepFlowSpawnedActor</code>执行堆栈:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// 未触发异步加载, `ATestRepFlowSpawnedActor::ATestRepFlowSpawnedActor`执行堆栈:</span><br><span class="line">--UIpNetDriver.TickDispatch </span><br><span class="line">|<span class="string">--UNetConnection.ReceivedRawPacket.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.ReceivedPacket.while.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedRawBunch.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedNextBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedSequencedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReceivedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UPackageMapClient.SerializeNewActor.if.if.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActorAbsolute </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActor </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ATestRepFlowSpawnedActor.ATestRepFlowSpawnedActor </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 触发异步加载, 创建`ATestRepFlowSpawnedActor`堆栈</span></span><br><span class="line"><span class="string">--UNetDriver.TickFlush.if </span></span><br><span class="line"><span class="string"></span>|<span class="string">--UIpConnection.Tick </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.Tick.else.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UPackageMapClient.SerializeNewActor.if.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActorAbsolute </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActor </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ATestRepFlowSpawnedActor.ATestRepFlowSpawnedActor </span></span><br></pre></td></tr></table></figure>
<p>核心关键代码: 在处理bunch时, 由于ActorChannel的Actor为空,
需要根据Bunch内容重新创建.
这也对应了图ReplicateActor内填充Bunch的顺序(第一个填充的就是SerializeActor的信息).</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118175334982.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118180126799.png" /></p>
<h4 id="初始化actor内属性">初始化Actor内属性</h4>
<p>初始化<code>ATestRepFlowSpawnedActor.mTestNumber</code>.</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// 未触发异步加载, 初始化`ATestRepFlowSpawnedActor.mTestNumber`.</span><br><span class="line">--UIpNetDriver.TickDispatch </span><br><span class="line">|<span class="string">--UNetConnection.ReceivedRawPacket.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.ReceivedPacket.while.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedRawBunch.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedNextBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedSequencedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReceivedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 触发异步加载, 初始化`ATestRepFlowSpawnedActor.mTestNumber`.</span></span><br><span class="line"><span class="string">--UNetDriver.TickFlush.if </span></span><br><span class="line"><span class="string"></span>|<span class="string">--UIpConnection.Tick </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.Tick.else.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br></pre></td></tr></table></figure>
<p>此时处理ActorProperties对应的ContentBlock.</p>
<figure>
<img src="./assets/image-20231118180041065.png"
alt="image-20231118180041065" />
<figcaption aria-hidden="true">image-20231118180041065</figcaption>
</figure>
<p>这也和代码能对应上: 循环处理ContentBlock.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118180329837.png" /></p>
<h4 id="actorcomponent序列化">ActorComponent序列化</h4>
<p>创建<code>UTestRepFlowSpawnedCmp</code>:
UTestRepFlowSpawnedCmp::UTestRepFlowSpawnedCmp</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// 未触发异步加载, 创建`UTestRepFlowSpawnedCmp`堆栈</span><br><span class="line">--UIpNetDriver.TickDispatch </span><br><span class="line">|<span class="string">--UNetConnection.ReceivedRawPacket.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.ReceivedPacket.while.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedRawBunch.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedNextBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedSequencedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReceivedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockPayload </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockHeader.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UTestRepFlowSpawnedCmp.UTestRepFlowSpawnedCmp </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 触发异步加载, 创建`UTestRepFlowSpawnedCmp`堆栈</span></span><br><span class="line"><span class="string">--UNetDriver.TickFlush.if </span></span><br><span class="line"><span class="string"></span>|<span class="string">--UIpConnection.Tick </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.Tick.else.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockPayload </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockHeader.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UTestRepFlowSpawnedCmp.UTestRepFlowSpawnedCmp </span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118180759208.png" /></p>
<h4 id="初始化actorcomponent属性">初始化ActorComponent属性</h4>
<p>UTestRepFlowSpawnedCmp.TestNumber Init</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// 未触发异步加载, UTestRepFlowSpawnedCmp.TestNumber init堆栈</span><br><span class="line">--UIpNetDriver.TickDispatch </span><br><span class="line">|<span class="string">--UNetConnection.ReceivedRawPacket.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.ReceivedPacket.while.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedRawBunch.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedNextBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedSequencedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReceivedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 触发异步加载, UTestRepFlowSpawnedCmp.TestNumber init堆栈</span></span><br><span class="line"><span class="string">--UNetDriver.TickFlush.if </span></span><br><span class="line"><span class="string"></span>|<span class="string">--UIpConnection.Tick </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.Tick.else.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br></pre></td></tr></table></figure>
<h4 id="aactor.postnetinit">AActor.PostNetInit</h4>
<p>由于开启了<code>net.AllowAsyncLoading</code>, 一般而言,
此时还会有Bunch未处理, 所以, 跳过OnRep阶段, 执行AActor.PostNetInit</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发异步加载后,ATestRepFlowSpawnedActor.BeginPlay堆栈</span></span><br><span class="line">--UNetDriver.TickFlush.<span class="keyword">if</span> </span><br><span class="line">|--UIpConnection.Tick </span><br><span class="line">| |--UNetConnection.Tick.<span class="keyword">else</span>.<span class="keyword">if</span>.<span class="keyword">for</span> </span><br><span class="line">| | |--UActorChannel.ProcessQueuedBunches.<span class="keyword">if</span>.<span class="keyword">if</span>.<span class="keyword">for</span> </span><br><span class="line">| | | |--UActorChannel.ProcessBunch.<span class="keyword">if</span> </span><br><span class="line">| | | | |--AActor.PostNetInit.<span class="keyword">if</span>.<span class="keyword">if</span> </span><br><span class="line">| | | | | |--AActor.DispatchBeginPlay.<span class="keyword">if</span> </span><br><span class="line">| | | | | | |--ATestRepFlowSpawnedActor.BeginPlay </span><br><span class="line"></span><br><span class="line"><span class="comment">// 未触发异步加载后,ATestRepFlowSpawnedActor::BeginPlay堆栈</span></span><br><span class="line">--UIpNetDriver.TickDispatch </span><br><span class="line">|--UNetConnection.ReceivedRawPacket.<span class="keyword">if</span>.<span class="keyword">if</span>.<span class="keyword">if</span> </span><br><span class="line">| |--UNetConnection.ReceivedPacket.<span class="keyword">while</span>.&#123; </span><br><span class="line">| | |--UChannel.ReceivedRawBunch.<span class="keyword">else</span> </span><br><span class="line">| | | |--UChannel.ReceivedNextBunch.<span class="keyword">if</span> </span><br><span class="line">| | | | |--UChannel.ReceivedSequencedBunch </span><br><span class="line">| | | | | |--UActorChannel.ReceivedBunch </span><br><span class="line">| | | | | | |--UActorChannel.ProcessBunch.<span class="keyword">if</span> </span><br><span class="line">| | | | | | | |--AActor.PostNetInit.<span class="keyword">if</span>.<span class="keyword">if</span> </span><br><span class="line">| | | | | | | | |--AActor.DispatchBeginPlay.<span class="keyword">if</span> </span><br><span class="line">| | | | | | | | | |--ATestRepFlowSpawnedActor.BeginPlay </span><br></pre></td></tr></table></figure>
<h4 id="总结-1">总结</h4>
<p>开启<code>net.AllowAsyncLoading</code>后, 执行顺序一定吗? 不一定,
因为开启它之后, 可能会因为异步加载导致在QueueBunch中处理,
也可能没有触发异步加载, 还在原来流程中处理. 所以各种情况都会存在.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231119110314263.png" /></p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// 触发异步加载后, 执行堆栈的一种情况</span><br><span class="line">--UNetDriver.TickFlush.if </span><br><span class="line">|<span class="string">--UIpConnection.Tick </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.Tick.else.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载, 创建`ATestRepFlowSpawnedActor`堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UPackageMapClient.SerializeNewActor.if.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActorAbsolute </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActor </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ATestRepFlowSpawnedActor.ATestRepFlowSpawnedActor </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载, 初始化`ATestRepFlowSpawnedActor.mTestNumber`.</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockPayload </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载, 创建`UTestRepFlowSpawnedCmp`堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockHeader.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UTestRepFlowSpawnedCmp.UTestRepFlowSpawnedCmp </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载, UTestRepFlowSpawnedCmp.TestNumber init堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--AActor.PostNetInit.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载后,ATestRepFlowSpawnedActor.BeginPlay堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--AActor.DispatchBeginPlay.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ATestRepFlowSpawnedActor.BeginPlay </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--AActor.BeginPlay.for.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载后,UTestRepFlowSpawnedCmp.BeginPlay堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UTestRepFlowSpawnedCmp.BeginPlay  </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.CallRepNotifies </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.CallRepNotifies.for.switch.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--AActor.ProcessEvent.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UObject.ProcessEvent.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UFunction.Invoke </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载后,ATestRepFlowSpawnedActor::OnRep_TestNumber堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ATestRepFlowSpawnedActor.OnRep_TestNumber </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.CallRepNotifies </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.CallRepNotifies.for.switch.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UObject.ProcessEvent.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UFunction.Invoke </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载后, UTestRepFlowSpawnedCmp::OnRep_TestNumber堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UTestRepFlowSpawnedCmp.OnRep_TestNumber </span></span><br><span class="line"><span class="string">--UNetDriver.TickFlush</span></span><br><span class="line"><span class="string"></span>|<span class="string">--// 处理UnmappedObject</span></span><br><span class="line"><span class="string"></span>|<span class="string">--FObjectReplicator.UpdateUnmappedObjects </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties_BackwardsCompatible_r.while.FRepLayout.UpdateUnmappedObjects.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.UpdateUnmappedObjects_r.for.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectPropertyBase.NetSerializeItem </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectProperty.SetObjectPropertyValue </span></span><br><span class="line"><span class="string"></span>|<span class="string">--FObjectReplicator.UpdateUnmappedObjects </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.CallRepNotifies </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.CallRepNotifies</span></span><br></pre></td></tr></table></figure>
<h2 id="rpc执行顺序"><code>RPC</code>执行顺序</h2>
<h2
id="multicastrpc-reliable执行顺序"><code>MulticastRPC Reliable</code>执行顺序</h2>
<h2
id="multicastrpc-unreliable执行顺序"><code>MulticastRPC Unreliable</code>执行顺序</h2>
<h1 id="actor情形"><code>Actor</code>情形</h1>
<h1
id="default-sub-actorcomponent情形"><code>Default Sub ActorComponent</code>情形</h1>
<h1
id="按需创建的subactorcomponent情形">按需创建的<code>SubActorComponent</code>情形</h1>
<p>如果<code>SpawnSubActorComponent</code>中有<code>COND_InitialOnly</code>类型的属性,
那么这类属性如果在SerializeActorBunch之前还没有设置对应的值,
那么该属性以后都无法进行同步(除非Dormancy后重新唤醒). 示例:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113210943174.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113211431219.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113211452821.png" /></p>
<p>原因: <code>COND_InitialOnly</code>的意思是,
只有网络上第一次(<code>Dormancy</code>之后再次重新使用, 也算第一次,
因为<code>Dormancy</code>是将其从网络中移除.)同步某一个<code>Actor</code>时候,
才会将这次同步的<code>Bunch</code>标记为<code>bNetInitial</code>,
并且将其设置为<code>Reliable</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113211817531.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113212226498.png" /></p>
<p>具体堆栈:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">--UActorChannel.ReplicateActor.if </span><br><span class="line">|<span class="string">--AActor.ReplicateSubobjects.for.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReplicateSubobject </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReplicateProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FNetSerializeCB.UpdateChangelistMgr </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.UpdateChangelistMgr </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.CompareProperties.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--CompareParentProperties.if.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UE4_RepLayout_Private.CompareParentPropertyHelper </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--CompareParentProperty.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--const bool bShouldSkip = !bIsLifetime </span>||<span class="string"> !bIsActive </span>||<span class="string"> (Parent.Condition == COND_InitialOnly &amp;&amp; !SharedParams.bIsInitial);</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113212448449.png" /></p>
<p>从上图也可以验证, 这个<code>ObjectReplicator</code>为新创建的,
即通过上文<code>NewObject</code>创建的.</p>
<p>那么怎么做才能针对首次动态创建的<code>SubActorComponent</code>,
也可以<code>OnRep</code> <code>COND_InitialOnly</code>属性呢?</p>
<p>答: 如果是新创建的<code>ActorComponent</code>,
将<code>RepFlags.bNetInitial</code>改成true.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113212939120.png" /></p>
<h2 id="总结-2">总结</h2>
<p>延迟创建(和SpawnActor不在同一帧, 并且创建Actor的Bunch已经同步过了),
该Component永远不会进行属性同步, 即客户端永远不会有OnRep的调用了.</p>
<h1 id="总结-3">总结</h1>
<h1 id="附言">附言</h1>
<ol type="1">
<li><code>net.AllowAsyncLoading</code>可以参考我之前的文章:<a href="/2023/11/09/UE/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E4%B8%AD,%20Package%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/" title="网络同步中, Package异步加载">网络同步中, Package异步加载</a></li>
</ol>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>时序</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>NetworkGUID</tag>
      </tags>
  </entry>
  <entry>
    <title>GUID延迟绑定</title>
    <url>/2023/11/09/UE/%E7%BD%91%E7%BB%9C/GUID%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="延迟绑定">延迟绑定</h1>
<p>UE对UObject指针的映射是通过GUID进行的,
例如当客户端ABasePlayerController.TestReplicationComp2需要根据DS传来的新数据进行赋值,
这个值就是GUID其代表一个对象.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628172027340.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628200508387.png" /></p>
<span id="more"></span>
<p>首先需要了解到, UE序列化是有顺序的,
ActorProperties-&gt;ActorComponentProperties-&gt;SelfReplicatedObjProperties.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623173331842-1687770871870-7-1687942299803-23.png" /></p>
<p>当属性的赋值在GUID对象创建之前, 因为指针对象还没有创建,
那么指针就不可能指向正确的地址. 这种情况该怎么处理呢?
例如当客户端ABasePlayerController.TestReplicationComp2需要反序列化的时候,
发现该GUID表示的对象还不存在, 这时候怎么办?</p>
<p>U根据UE处理属性同步的顺序(ActorProperties-&gt;ActorComponentProperties-&gt;SelfReplicatedObjProperties),
先反序列化属性变量, 发现没有找到GUID对应的UObj,
将其放入临时存储变量UPackageMap.TrackedUnmappedNetGuids中(<strong>详见特殊说明1</strong>).</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628200757905.png" /></p>
<p>并将结果添加到FReceivingRepState.GuidReferencesMap中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628201728804.png" /></p>
<p>并且如果检测到有Unmapped数据,
还要将其添加到UNetDriver.UnmappedReplicators中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628202112682.png" /></p>
<p>在每帧末尾会处理UNetDriver.UnmappedReplicators中未处理的UnmappedGUID.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628201922955.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623180837595-1687942299803-17.png" /></p>
<p>通过以上逻辑,
就可以将ABasePlayerController.TestReplicationComp2指向对应的Obj了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628200508387-1687955124036-34.png" /></p>
<p><strong>思考:</strong></p>
<p>如果在反序列化属性时, GUID没有找到, 那么该属性会更改吗?</p>
<p>在序列化TestReplicationComp2时, 可以看出,
当没有解析出GUID对应的Object时, Obj会设置成nullptr,
然后将nullptr设置到TestReplicationComp2中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628205526440.png" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628205408507.png"
alt="image-20230628205408507" />
<figcaption aria-hidden="true">image-20230628205408507</figcaption>
</figure>
<p>但是这种情况只是短暂存在的,
即在UNetDriver.TickFlush结尾就已经将TestReplicationComp2设置成正确的值了.</p>
<p><strong>进一步思考</strong>, 在属性同步的时候,
是否会发生将TestReplicationComp2设置成nullptr,
过了几帧才将TestReplicationComp2设置成正确的值呢?
这种情况发生的条件为GUID同步过来了, 但是其真正的对象在后续才创建.
针对Owner为Actor本身的Component不可能出现, 当一个属性发生变化,
如果查找到该GUID对象的Obj, 则直接设置,
否则后续一定会紧跟着GUID对应Obj的创建. 但是针对一个指针,
指向别的Actor/UObject, 是可能出现: GUID有了, 但是Actor/UObject还没</p>
<h1 id="特殊说明">特殊说明</h1>
<h2
id="unmappednetguids和mappeddynamicnetguids临时存储">UnmappedNetGuids和MappedDynamicNetGuids临时存储</h2>
<p>UPackageMap.TrackedUnmappedNetGuids和UPackageMap.TrackedMappedDynamicNetGuids都是临时存储数据用的,
用完即清理.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628201131153.png" /></p>
<h2 id="unmappednetguids用途">UnmappedNetGuids用途</h2>
<p>针对UnmappedGUID主要是用于延迟绑定. 绑定后, 如果GUID为Dynamic,
则将其放入MappedDynamic</p>
<p>每帧处理UnmappedGUID.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623180837595-1687942299803-17-1687958346817-37.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628212016071.png" /></p>
<h2 id="mappeddynamic用途">MappedDynamic用途</h2>
<p>收集UnmappedGUID和MappedGUID, 填充UNetDriver.GuidToReplicatorMap数据,
供后续使用.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628212205753.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230628212318266.png" /></p>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>NetworkGUID</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>NetworkGUID</tag>
      </tags>
  </entry>
  <entry>
    <title>NetDormancy</title>
    <url>/2023/11/09/UE/%E7%BD%91%E7%BB%9C/NetDormancy/</url>
    <content><![CDATA[<h1 id="dormancy定义">Dormancy定义</h1>
<p>Dormancy表示休眠, 即在Dormancy期间, Actor不进行属性同步, 直接略过.
Dormancy的对象是Actor, 和Replication(ActorChannel)的单位一致.
一般用于场景中不常发生变化的物体上, 如果预期其一定时间内不会发生变化,
即可设置为Dormancy.</p>
<p>Dormancy状态转换图:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230802161108281.png" /></p>
<span id="more"></span>
<p>Dormancy转换大致堆栈流程:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230802160012920.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Describes if an actor can enter a low network bandwidth dormant mode */</span></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ENetDormancy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** This actor can never go network dormant. */</span></span><br><span class="line">    <span class="function">DORM_Never <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Never&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    <span class="comment">/** This actor can go dormant, but is not currently dormant. Game code will tell it when it go dormant. */</span></span></span><br><span class="line"><span class="function">    DORM_Awake <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Awake&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    <span class="comment">/** This actor wants to go fully dormant for all connections. */</span></span></span><br><span class="line"><span class="function">    DORM_DormantAll <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Dormant All&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    <span class="comment">/** This actor may want to go dormant for some connections, GetNetDormancy() will be called to find out which. */</span></span></span><br><span class="line"><span class="function">    DORM_DormantPartial <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Dormant Partial&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    <span class="comment">/** This actor is initially dormant for all connection if it was placed in map. */</span></span></span><br><span class="line"><span class="function">    DORM_Initial <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;Initial&quot;</span>)</span>,</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    DORM_MAX <span class="title">UMETA</span><span class="params">(Hidden)</span>,</span></span><br><span class="line"><span class="function">&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actor中的变量</span></span><br><span class="line"><span class="comment">/** Dormancy setting for actor to take itself off of the replication list without being destroyed on clients. */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditDefaultsOnly, Category=Replication)</span><br><span class="line">TEnumAsByte&lt;<span class="keyword">enum</span> <span class="title class_">ENetDormancy</span>&gt; NetDormancy;</span><br></pre></td></tr></table></figure>
<p>可以看出, Actor使用NetDormancy变量实现Dormancy逻辑.
其中DORM_Never和DORM_Awake都表示未休眠, 会进行属性同步,
其他的变量表示休眠, 不进行属性同步.
特殊的DORM_Initial表示放在地图中进行休眠的Actor.</p>
<h1 id="dormancy使用">Dormancy使用</h1>
<p>初始化时, 默认将NetDormancy设置成DORM_Awake,
表示可以使用Dormancy.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230724161130553.png" /></p>
<p>如果想要启用Dormancy需要调用AActor.SetNetDormancy将其设置为Dormacy.
后续会根据设置的状态, 进行处理.</p>
<p>具体参考测试用例:https://github.com/fdcumt/ALSV.git</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230731153740974.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中关键代码:</span></span><br><span class="line"><span class="comment">//TestNetDormancyActor.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestNetDormancyActor.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(BlueprintType, Blueprintable)</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">ATestNetDormancyActor</span> : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Default constructor for AActor */</span></span><br><span class="line">    <span class="built_in">ATestNetDormancyActor</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaSeconds)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(Client, Unreliable)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">S2C_Unreliable_ChangeCharacterNumber</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(Client, Reliable)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">S2C_ChangeCharacterNumber</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(Server, Reliable)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">C2S_ChangeCharacterNumber</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">    int32 TestNumber = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    int32 LocalNumber = <span class="number">0</span>;</span><br><span class="line">    uint32 FrameNumber = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestNetDormancyActor.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestNetDormancyActor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Net/UnrealNetwork.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ATestNetDormancyActor::<span class="built_in">ATestNetDormancyActor</span>()</span><br><span class="line">: <span class="built_in">AActor</span>()</span><br><span class="line">&#123;</span><br><span class="line">    bReplicates = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//NetDormancy = ENetDormancy::DORM_DormantAll;</span></span><br><span class="line"></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">    PrimaryActorTick.TickGroup = TG_PrePhysics;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ATestNetDormancyActor::Tick</span><span class="params">(<span class="type">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetLocalRole</span>() == ENetRole::ROLE_Authority)</span><br><span class="line">    &#123;</span><br><span class="line">        ++FrameNumber;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (FrameNumber%20==19)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            ++TestNumber;</span></span><br><span class="line"><span class="comment">            FlushNetDormancy();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        else */</span><span class="keyword">if</span> (FrameNumber % <span class="number">20</span> == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">S2C_Unreliable_ChangeCharacterNumber</span>();</span><br><span class="line">            <span class="comment">//S2C_ChangeCharacterNumber();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">GetLocalRole</span>() == ENetRole::ROLE_AutonomousProxy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">C2S_ChangeCharacterNumber</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ATestNetDormancyActor::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">    <span class="built_in">DOREPLIFETIME</span>(ATestNetDormancyActor, TestNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ATestNetDormancyActor::S2C_Unreliable_ChangeCharacterNumber_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++LocalNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ATestNetDormancyActor::S2C_ChangeCharacterNumber_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++LocalNumber;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ATestNetDormancyActor::C2S_ChangeCharacterNumber_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++LocalNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并在ABasePlayerController.tick中添加:</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetLocalRole</span>() == ENetRole::ROLE_Authority)</span><br><span class="line">    &#123;</span><br><span class="line">        ++LocalFrameIndex;</span><br><span class="line">        <span class="keyword">if</span> (TestNetDormancyActor == <span class="literal">nullptr</span> &amp;&amp; LocalFrameIndex==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            FVector Loc = FVector::ZeroVector;</span><br><span class="line">            FRotator Rot = FRotator::ZeroRotator;</span><br><span class="line">            FActorSpawnParameters Par;</span><br><span class="line">            Par.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;</span><br><span class="line">            TestNetDormancyActor = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;ATestNetDormancyActor&gt;(ATestNetDormancyActor::<span class="built_in">StaticClass</span>(), Loc, Rot, Par);</span><br><span class="line">            TestNetDormancyActor-&gt;<span class="built_in">SetNetDormancy</span>(ENetDormancy::DORM_DormantAll);</span><br><span class="line">            TestNetDormancyActor-&gt;<span class="built_in">SetAutonomousProxy</span>(<span class="literal">true</span>);</span><br><span class="line">            TestNetDormancyActor-&gt;<span class="built_in">SetOwner</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在SpawnActor时会将其添加到指定Node节点中.
在调用UReplicationGraph::AddNetworkActor时候,
会设置Actor对应的GlobalInfo.bWantsToBeDormant,
检测其是否需要进行一次属性同步.
例如如果在构造函数中将其设置为ENetDormancy::DORM_DormantAll, 即是这样,
也应该进行一次属性同步, 将初始化的信息同步到远端.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230724171546754.png" /></p>
<p>创建之后, 然后将其设置为ENetDormancy::DORM_DormantAll.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230724163540441.png" /></p>
<p>当属性发生变化的时候调用FlushActorDormancy, 触发一次属性同步.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230726102844002.png" /></p>
<h1 id="dormancy详解">Dormancy详解</h1>
<p>那么在这期间, Dormant究竟是怎么执行的, 它有什么逻辑呢?
下面开始寻根溯源.</p>
<h2 id="addnetwork详细流程">AddNetwork详细流程</h2>
<p>根据上面的示例, 在ActorSpawn时候,
会添加到DynamicSpatializedActors中.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// ActorSpawn时候, 将Actor添加到ReplicationNode中</span></span><br><span class="line">--UWorld::<span class="built_in">SpawnActor</span>()</span><br><span class="line"> |--UWorld::<span class="built_in">AddNetworkActor</span>()</span><br><span class="line"> | |--<span class="comment">// 遍历所有NetDriver, 并将Actor添加到其中</span></span><br><span class="line"> | |--Driver-&gt;<span class="built_in">AddNetworkActor</span>(Actor);</span><br><span class="line"> | | |--UNetDriver::<span class="built_in">AddNetworkActor</span>()</span><br><span class="line"> | | | |--<span class="built_in">GetNetworkObjectList</span>().<span class="built_in">FindOrAdd</span>(Actor, <span class="keyword">this</span>);</span><br><span class="line"> | | | |--<span class="comment">// 向ReplicationGraph中添加NetworkActor</span></span><br><span class="line"> | | | |--ReplicationDriver-&gt;<span class="built_in">AddNetworkActor</span>(Actor);</span><br><span class="line"> | | | | |--<span class="comment">// 添加Actor对应的描述信息FGlobalActorReplicationInfo</span></span><br><span class="line"> | | | | |--FGlobalActorReplicationInfo&amp; GlobalInfo = GlobalActorReplicationInfoMap.<span class="built_in">Get</span>(Actor);</span><br><span class="line"> | | | | |--<span class="comment">// 设置Dormant属性</span></span><br><span class="line"> | | | | |--GlobalInfo.bWantsToBeDormant = Actor-&gt;NetDormancy &gt; DORM_Awake;</span><br><span class="line"> | | | | |--UReplicationGraph::<span class="built_in">RouteAddNetworkActorToNodes</span>()</span><br><span class="line"> | | | | | |--<span class="comment">// 针对ActorInfo.Actor-&gt;bAlwaysRelevant, 添加到AlwaysRelevantNode中</span></span><br><span class="line"> | | | | | |--AlwaysRelevantNode-&gt;<span class="built_in">NotifyAddNetworkActor</span>(ActorInfo);</span><br><span class="line"> | | | | | |--<span class="comment">// 针对ActorInfo.Actor-&gt;bOnlyRelevantToOwner, 添加到ActorsWithoutNetConnection中</span></span><br><span class="line"> | | | | | |--ActorsWithoutNetConnection.<span class="built_in">Add</span>(ActorInfo.Actor);</span><br><span class="line"> | | | | | |--<span class="comment">// 其他情况添加到GridNode中</span></span><br><span class="line"> | | | | | |--GridNode-&gt;<span class="built_in">AddActor_Dormancy</span>(ActorInfo, GlobalInfo);</span><br><span class="line"> | | | | | | |--UReplicationGraphNode_GridSpatialization2D::AddActor_Dormancy</span><br><span class="line"> | | | | | | |--<span class="comment">// 如果要想要休眠, 调用AddActorInternal_Static函数</span></span><br><span class="line"> | | | | | | |--<span class="built_in">AddActorInternal_Static</span>(ActorInfo, ActorRepInfo, <span class="literal">true</span>);</span><br><span class="line"> | | | | | | |--<span class="comment">// 否则, 调用AddActorInternal_Dynamic</span></span><br><span class="line"> | | | | | | |--<span class="built_in">AddActorInternal_Dynamic</span>(ActorInfo);</span><br><span class="line"> | | | | | | | |--<span class="comment">// 放入了UReplicationGraphNode_GridSpatialization2D.DynamicSpatializedActors中</span></span><br><span class="line"> | | | | | | | |--DynamicSpatializedActors.<span class="built_in">Emplace</span>(ActorInfo.Actor, ActorInfo);</span><br></pre></td></tr></table></figure>
<p>可以看出,
最终将Actor放入了放入了UReplicationGraphNode_GridSpatialization2D.DynamicSpatializedActors中.
在每帧tick时候, 会将同步到其他端.</p>
<h2 id="setnetdormancy详细流程">SetNetDormancy详细流程</h2>
<h3 id="startbecomingdormant">StartBecomingDormant</h3>
<p>在SetNetDormancy流程中, 有几个关键点:</p>
<ol type="1">
<li><p>将ActorRepInfo.bWantsToBeDormant设置为true.</p></li>
<li><p>将Actor放入Cell的UReplicationGraphNode_DormancyNode中.
表明不再进行Gather了.
但是会在UReplicationGraphNode_ConnectionDormancyNode中Gather</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AActor.SetNetDormancy堆栈</span></span><br><span class="line">--AActor.<span class="built_in">SetNetDormancy</span>()</span><br><span class="line"> |--NetDriver-&gt;<span class="built_in">NotifyActorDormancyChange</span>(<span class="keyword">this</span>, OldDormancy);</span><br><span class="line"> | |--ReplicationDriver-&gt;<span class="built_in">NotifyActorDormancyChange</span>()</span><br><span class="line"> | | |--ActorRepInfo-&gt;bWantsToBeDormant = bNewWantsToBeDormant;</span><br><span class="line"> | | |--ActorRepInfo-&gt;Events.DormancyChange.<span class="built_in">Broadcast</span>(Actor, *ActorRepInfo, CurrentDormancy, OldDormancyState);</span><br><span class="line"> | | | |--<span class="comment">// 在UReplicationGraphNode_GridSpatialization2D::AddActor_Dormancy中注册的回调函数</span></span><br><span class="line"> | | | |--UReplicationGraphNode_GridSpatialization2D::<span class="built_in">OnNetDormancyChange</span>()</span><br><span class="line"> | | | | |--UReplicationGraphNode_GridSpatialization2D.<span class="built_in">AddActorInternal_Static</span>()</span><br><span class="line"> | | | | | |--UReplicationGraphNode_GridSpatialization2D.<span class="built_in">AddActorInternal_Static_Implementation</span>()</span><br><span class="line"> | | | | | | |--StaticSpatializedActors.<span class="built_in">Emplace</span>(Actor, <span class="built_in">FCachedStaticActorInfo</span>(ActorInfo, bDormancyDriven));</span><br><span class="line"> | | | | | | |--UReplicationGraphNode_GridSpatialization2D.<span class="built_in">PutStaticActorIntoCell</span>()</span><br><span class="line"> | | | | | | | |--<span class="comment">// 将Actor放入对应的Cell中</span></span><br></pre></td></tr></table></figure>
<p>在同一帧的TickFlush GatherActor时候,
会在UReplicationGraphNode_ConnectionDormancyNode中将Actor Gather出来.
针对DormancyActor会有如下流程(如是DS第一帧, 会有截断, 但是一般情况不会.
这里只说一般情况). 可以看出, Gather之后,
Actor会执行StartBecomingDormant, 准备进行休眠状态.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AActor.SetNetDormancy同一帧, TickFlush GatherActor的流程</span></span><br><span class="line">--UNetDriver.<span class="built_in">TickFlush</span>()</span><br><span class="line"> |--UNetDriver.<span class="built_in">ServerReplicateActors</span>()</span><br><span class="line"> | |--UReplicationGraph.<span class="built_in">ServerReplicateActors</span>()</span><br><span class="line"> | | |--UReplicationGraphNode_GridSpatialization2D.<span class="built_in">GatherActorListsForConnection</span>()</span><br><span class="line"> | | | |--UReplicationGraphNode_ActorList.<span class="built_in">GatherActorListsForConnection</span>()</span><br><span class="line"> | | | | |--UReplicationGraphNode_DormancyNode.<span class="built_in">GatherActorListsForConnection</span>()</span><br><span class="line"> | | | | | |--<span class="comment">// 如果ConnectionNode为空还要进行创建</span></span><br><span class="line"> | | | | | |--ConnectionNode = <span class="built_in">CreateConnectionNode</span>(Params);</span><br><span class="line"> | | | | | | |--这里会将UReplicationGraphNode_DormancyNode中UReplicationGraphNode_ActorList.ReplicateActorList完全拷贝一份</span><br><span class="line"> | | | | | | |--ConnectionNode-&gt;<span class="built_in">DeepCopyActorListsFrom</span>(<span class="keyword">this</span>);</span><br><span class="line"> | | | | | | |--ConnectionNode-&gt;<span class="built_in">InitConnectionNode</span>(RepGraphConnection, Params.ReplicationFrameNum);</span><br><span class="line"> | | | | | |--<span class="comment">//UReplicationGraphNode_ConnectionDormancyNode收集Actor</span></span><br><span class="line"> | | | | | |--ConnectionNode-&gt;<span class="built_in">GatherActorListsForConnection</span>(Params);</span><br><span class="line"> | | | | | | |--UReplicationGraphNode_ConnectionDormancyNode.<span class="built_in">ConditionalGatherDormantActorsForConnection</span>()</span><br><span class="line"> | | | | | | | |--<span class="comment">// 将node添加到OutGatheredReplicationLists中</span></span><br><span class="line"> | | | | | | | |--Params.OutGatheredReplicationLists.<span class="built_in">AddReplicateActorList</span>(ConnectionList);</span><br><span class="line"> | | |--UReplicationGraph.<span class="built_in">ReplicateActorListsForConnections_Default</span>()</span><br><span class="line"> | | | |--UReplicationGraph.<span class="built_in">ReplicateSingleActor</span>()</span><br><span class="line"> | | | | |--<span class="comment">// 针对GlobalActorInfo.bWantsToBeDormant要进行StartBecomingDormant</span></span><br><span class="line"> | | | | |--UActorChannel.<span class="built_in">StartBecomingDormant</span>()</span><br><span class="line"> | | | | | |--FObjectReplicator::<span class="built_in">StartBecomingDormant</span>()</span><br><span class="line"> | | | | | | |--bLastUpdateEmpty = <span class="literal">false</span>;</span><br><span class="line"> | | | | | |--bPendingDormancy = <span class="literal">true</span>;</span><br><span class="line"> | | | | | |--bIsInDormancyHysteresis = <span class="literal">false</span>;</span><br><span class="line"> | | | | | |--Connection-&gt;<span class="built_in">StartTickingChannel</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>DS第一帧截断原因:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230727164750246.png" /></p>
<h4 id="问-已经startbecomingdormant的actor还会进行属性同步吗">问:
已经StartBecomingDormant的Actor还会进行属性同步吗?</h4>
<p>每帧还会将BecomeDormant的Actor Gather出来. 但是, 不会进行属性同步了.
因为, 他没有发生变化:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230728172151474.png" /></p>
<p>如果发生丢包, 还会进行同步, 并且这里BitsWritten会大于0,
有数据进行网络传输.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230728172233340.png" /></p>
<h3 id="becomedormant">BecomeDormant</h3>
<p>在ActorChannelTick的时候, 每帧检测是否满足Dormancy的条件, 如果满足,
直接进入Dormancy.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AActor.SetNetDormancy之后的BecomeDormant流程</span></span><br><span class="line">--UNetDriver.<span class="built_in">TickFlush</span>()</span><br><span class="line"> |--<span class="comment">// 针对所有ClientConnection, 都会进行tick</span></span><br><span class="line"> |--UIpConnection.<span class="built_in">Tick</span>()</span><br><span class="line"> | |--UNetConnection.<span class="built_in">Tick</span>()</span><br><span class="line"> | | |--<span class="comment">// 遍历所有需要Tick的Channel, 进行tick</span></span><br><span class="line"> | | |--UActorChannel.<span class="built_in">Tick</span>()</span><br><span class="line"> | | | |--UChannel.<span class="built_in">Tick</span>()</span><br><span class="line"> | | | | |--<span class="comment">// 当满足条件bPendingDormancy &amp;&amp; ReadyForDormancy() 时候, 进行BecomeDormant</span></span><br><span class="line"> | | | | |--UChannel.<span class="built_in">BecomeDormant</span>()</span><br><span class="line"> | | | | | |--bPendingDormancy = <span class="literal">false</span>;</span><br><span class="line"> | | | | | |--bIsInDormancyHysteresis = <span class="literal">false</span></span><br><span class="line"> | | | | | |--Dormant = <span class="literal">true</span></span><br><span class="line"> | | | | | |--UActorChannel.<span class="built_in">Close</span>(EChannelCloseReason::Dormancy);</span><br><span class="line"> | | | | | | |--Connection-&gt;Driver-&gt;<span class="built_in">NotifyActorFullyDormantForConnection</span>(Actor, Connection);</span><br><span class="line"> | | | | | | | |--UReplicationDriver.<span class="built_in">NotifyActorFullyDormantForConnection</span>()</span><br><span class="line"> | | | | | | | | |--<span class="comment">// 遍历所有UReplicationGraph.Connections, 将FConnectionReplicateActorInfo.bDormantOnConnection设置为true</span></span><br><span class="line"> | | | | | | | | |--FConnectionReplicateActorInfo.bDormantOnConnection </span><br><span class="line"> | | | | | | | | |-- <span class="comment">// 至此, 该Actor进入Dormancy.</span></span><br></pre></td></tr></table></figure>
<p>这里着重说一下ReadyForDormancy:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FObjectReplicator::ReadyForDormancy</span><span class="params">(<span class="type">bool</span> bSuppressLogs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetObject</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogRep, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;ReadyForDormancy: Object == nullptr&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;		<span class="comment">// Technically, we don&#x27;t want to hold up dormancy, but the owner needs to clean us up, so we warn</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can&#x27;t go dormant until last update produced no new property updates</span></span><br><span class="line">    <span class="comment">// 上一次Update必须是空的, 即上一次没有任何更新</span></span><br><span class="line">    <span class="keyword">if</span> (!bLastUpdateEmpty)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bSuppressLogs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">UE_LOG</span>(LogRepTraffic, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;    [%d] Not ready for dormancy. bLastUpdateEmpty = false&quot;</span>), OwningChannel-&gt;ChIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FSendingRepState* SendingRepState = RepState.<span class="built_in">IsValid</span>() ? RepState-&gt;<span class="built_in">GetSendingRepState</span>() : <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SendingRepState-&gt;HistoryStart != SendingRepState-&gt;HistoryEnd)</span><br><span class="line">        &#123; <span class="comment">// 所有数据都ack了</span></span><br><span class="line">            <span class="comment">// We have change lists that haven&#x27;t been acked</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SendingRepState-&gt;NumNaks &gt; <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 没有丢包</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!SendingRepState-&gt;bOpenAckedCalled)</span><br><span class="line">        &#123; <span class="comment">// 没有调用过OpenAckedCalled</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SendingRepState-&gt;PreOpenAckHistory.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">// 没有调用过OpenAckedCalled</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can&#x27;t go dormant if there are unAckd property updates</span></span><br><span class="line">        <span class="keyword">for</span> (FPropertyRetirement&amp; Retirement : SendingRepState-&gt;Retirement)</span><br><span class="line">        &#123; <span class="comment">// 针对Delta Properties类型, 所有消息也要被Ack才可以</span></span><br><span class="line">            <span class="keyword">if</span> (Retirement.Next != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!bSuppressLogs)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">UE_LOG</span>(LogRepTraffic, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;    [%d] OutAckPacketId: %d First: %d Last: %d &quot;</span>), OwningChannel-&gt;ChIndex, OwningChannel-&gt;Connection-&gt;OutAckPacketId, Retirement.OutPacketIdRange.First, Retirement.OutPacketIdRange.Last);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>bLastUpdateEmpty为true, 下图是bLastUpdateEmpty刷新的地方</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729143356134-1690612543416-1.png" /></p>
<ol start="2" type="1">
<li>SendingRepState-&gt;HistoryStart必须和SendingRepState-&gt;HistoryEnd相同</li>
</ol>
<p>即已经发送的数据全部被ack了, 并且没有丢包情况.
因为History代表已经发送的历史, 每次UpdateChangelistHistory时候,
会根据AckPacketId清理History数据. 当所有history数据清理干净之后,
就表示所有数据都已经发送完成了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729145842644.png" /></p>
<ol start="3" type="1">
<li>SendingRepState必须全部都Ack了. 这里处理丢包情况,
即所有丢包数据都已经重发了.</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729144839069.png" /></p>
<p>重发丢包数据:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729145012879.png" /></p>
<ol start="4" type="1">
<li><p>bOpenAckedCalled和PreOpenAckHistory:
所有SpawnActor的ack都收到了.</p></li>
<li><p>SendingRepState-&gt;Retirement用于记录DeltaProperty的历史.
这个也要全部ack后才能Dormancy.</p></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729150134647.png" /></p>
<p>并且根据上述堆栈,
可以看到BecomeDormant最后设置FConnectionReplicateActorInfo.bDormantOnConnection为true.
即GatherActor也不会收集到DormancyActor了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729151417230.png" /></p>
<h2 id="flushactordormancy详细流程">FlushActorDormancy详细流程</h2>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// Actor调用AActor.FlushNetDormancy详细堆栈</span><br><span class="line">--AActor.FlushNetDormancy()</span><br><span class="line"> |<span class="string">--UNetDriver.FlushActorDormancy()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string">--UReplicationDriver.FlushNetDormancy()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--GlobalInfo.LastFlushNetDormancyFrame = ReplicationGraphFrame;</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--GlobalInfo.Events.DormancyFlush.Broadcast(Actor, GlobalInfo);</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UReplicationGraphNode_DormancyNode.OnActorDormancyFlush()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-- // 针对所有DormancyNode中存储的UReplicationGraphNode_ConnectionDormancyNode, 进行处理</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UReplicationGraphNode_ConnectionDormancyNode::NotifyActorDormancyFlush()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReplicateActorList.Add(ActorInfo.Actor);</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 遍历所有Connection, 设置bDormantOnConnection为false</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--Info-&gt;bDormantOnConnection = false</span></span><br></pre></td></tr></table></figure>
<p>触发下图这些DormancyNode的回调</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729151645834.png" /></p>
<p>从上图可以看出,
FlushActorDormancy会将Actor放入UReplicationGraphNode_ConnectionDormancyNode的ReplicateActorList中,
然后和StartBecomingDormant类似, 进行同步后,
等待该Actor所有数据同步完成之后, 进入休眠.</p>
<h2 id="channel的dormancyclose流程">Channel的DormancyClose流程</h2>
<p>通过如下堆栈可以看出Dormancy CloseBunch并不会将Actor等对象销毁,
仅仅是将Channel回收了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ActorChannel进入DormancyClose流程, 向客户端发送DormancyClose Bunch</span></span><br><span class="line">--UNetDriver.<span class="built_in">TickFlush</span>()</span><br><span class="line"> |--<span class="comment">// 针对所有ClientConnection, 都会进行tick</span></span><br><span class="line"> |--UIpConnection.<span class="built_in">Tick</span>()</span><br><span class="line"> | |--UNetConnection.<span class="built_in">Tick</span>()</span><br><span class="line"> | | |--<span class="comment">// 遍历所有需要Tick的Channel, 进行tick</span></span><br><span class="line"> | | |--UActorChannel.<span class="built_in">Tick</span>()</span><br><span class="line"> | | | |--UChannel.<span class="built_in">Tick</span>()</span><br><span class="line"> | | | | |--<span class="comment">// 当满足条件bPendingDormancy &amp;&amp; ReadyForDormancy() 时候, 进行BecomeDormant</span></span><br><span class="line"> | | | | |--UChannel.<span class="built_in">BecomeDormant</span>()</span><br><span class="line"> | | | | | |--bPendingDormancy = <span class="literal">false</span>;</span><br><span class="line"> | | | | | |--bIsInDormancyHysteresis = <span class="literal">false</span></span><br><span class="line"> | | | | | |--Dormant = <span class="literal">true</span></span><br><span class="line"> | | | | | |--UActorChannel.<span class="built_in">Close</span>(EChannelCloseReason::Dormancy);</span><br><span class="line"> | | | | | | |--UChannel::<span class="built_in">Close</span>()</span><br><span class="line"> | | | | | | | |--UChannel::<span class="built_in">Close</span>()</span><br><span class="line"> | | | | | | | | |--CloseBunch.bReliable = <span class="number">1</span>;</span><br><span class="line"> | | | | | | | | |--CloseBunch.CloseReason = Reason;</span><br><span class="line"> | | | | | | | | |--<span class="built_in">SendBunch</span>( &amp;CloseBunch, <span class="number">0</span> );</span><br><span class="line"> | | | | | | |--Connection-&gt;Driver-&gt;<span class="built_in">NotifyActorFullyDormantForConnection</span>(Actor, Connection);</span><br><span class="line"> | | | | | | | |--UReplicationDriver.<span class="built_in">NotifyActorFullyDormantForConnection</span>()</span><br><span class="line"> | | | | | | | | |--<span class="comment">// 遍历所有UReplicationGraph.Connections, 将FConnectionReplicateActorInfo.bDormantOnConnection设置为true</span></span><br><span class="line"> | | | | | | | | |--FConnectionReplicateActorInfo.bDormantOnConnection </span><br><span class="line"> | | | | | | | | |-- <span class="comment">// 至此, 该Actor进入Dormancy.</span></span><br></pre></td></tr></table></figure>
<p>回收Channel:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729160949280.png" /></p>
<h3 id="客户端调用closeup-进行清理">客户端调用CloseUp, 进行清理</h3>
<p>在清理的过程中, 需要清理Channel的所有资源, 然后将Channel回收.
这些资源包括但不限于ReplicationMap, ActorReplication数据等.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729154619790.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729154133521.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729154332928.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729154353306.png" /></p>
<h3 id="ds收到ack-closechannel">DS收到Ack, CloseChannel</h3>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729154810659.png" /></p>
<p>DS收到Ack后, 根据ChannelIndex对Channel进行Close.
清理并回收Channel.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729154922529.png" /></p>
<p>触发UNetReplicationGraphConnection::NotifyActorChannelCleanedUp进行清理:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729155152475.png" /></p>
<p>清理ReplicatorMap相关信息.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729155216575.png" /></p>
<h3
id="ds调用flushactordormancy-replicateactor会重新打开channel">DS调用FlushActorDormancy,
ReplicateActor会重新打开Channel</h3>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729161125894.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729161117873.png" /></p>
<h3
id="客户端收到bunch查找对应的channel-没有就创建">客户端收到Bunch,查找对应的channel,
没有就创建</h3>
<p>根据ChannelIndex索引Channel, 由于Channel时新建的,
所以其对应的Actor为空, 然后根据GUID去查找对应的Actor.
最后将Actor和Channel绑定.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729161341483.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729161334222.png" /></p>
<h2
id="如果在构造函数中将netdormancy设置为dorm_dormantall呢">如果在构造函数中将NetDormancy设置为DORM_DormantAll呢?</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230727111411075.png" /></p>
<p>和SetNetDormancy流程一样, 这里不再赘述.</p>
<h1 id="问">问</h1>
<h2 id="dormancy期间能否rpc">Dormancy期间,能否RPC?</h2>
<h3 id="能否s2c">能否S2C</h3>
<p>能进行RPC, 并且会创建新的Channel,
而且在RPC之前还会进行ReplicateActor.</p>
<p>构建测试用例:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230731152252964.png" /></p>
<p>并且, S2C_ChangeCharacterNumber为Reliable.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230731152322984.png" /></p>
<p>在RPC过程中, 会首先创建ActorChannel, 然后ReplicateActor,
最后才会RPC.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729163913372.png"
alt="image-20230729163913372" />
<figcaption aria-hidden="true">image-20230729163913372</figcaption>
</figure>
<p>只要是Channel刚创建的, 就会首先进行ReplicateActor.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729164013067.png" /></p>
<p>注意在这这个过程中, 是不会触发Dormancy流程的,
只进行了ReliableReplicateActor+Reliable/UnReliable的RPC.</p>
<p>这里还要特意说一下, 针对Dormancy期间的S2C,
都会发送Reliable的ReplicateActor包, 由于是ReliableBunch,
其可靠性由Driver自己保证. 针对UnreliableRPC, 其Bunch为非Reliable,
所以丢就丢了, 不会重发.</p>
<h3
id="为什么属性没有变化还会replicateactor呢">为什么属性没有变化还会ReplicateActor呢?</h3>
<p>由于为新打开的Channel, 所以设置为Init, 并设定为ReliableBunch.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230731155041019.png" /></p>
<p>序列化Actor的GUID, 并强制设置为Dirty.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230731155009635.png" /></p>
<p>填充Bunch中的SerializeNewActor消息, 然后进行发送.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230731162337718.png" /></p>
<h3 id="能否c2s">能否C2S</h3>
<p>不能, 因为Dormancy, 会销毁Channel, 无法进行RPC.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729164830954.png" /></p>
<p>测试关键代码:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230729164937129.png" /></p>
<h1 id="总结">总结</h1>
<p>Dormancy的单位是Actor, 当其休眠的时候, 不会发生属性同步, 如果发送RPC,
只有DS向客户端发送的RPC可以执行, C2S会直接丢弃.
并且所有S2C的RPC都会调用, ReplicateActor 进行一次属性同步.</p>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>NetDormancy</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>NetDormancy</tag>
      </tags>
  </entry>
  <entry>
    <title>ReliableBunch溢出处理</title>
    <url>/2023/11/27/UE/%E7%BD%91%E7%BB%9C/ReliableBunch%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="什么是reliablebunch溢出">什么是ReliableBunch溢出</h1>
<p>当DS日志显示:<code>SendBunch: Reliable partial bunch overflows reliable buffer!</code>,
即当前未响应的<code>ReliableBunch</code>过多, 造成DS关闭了连接.</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="symbol">SendBunch:</span> Reliable <span class="keyword">partial</span> bunch overflows reliable buffer!</span><br></pre></td></tr></table></figure>
<p>SendBunch时触发Overflow.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127211542330.png" /></p>
<p>SendRPC时触发Overflow</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231129091215487.png" /></p>
<span id="more"></span>
<h1 id="溢出后怎么调试">溢出后怎么调试</h1>
<p>溢出原因是<code>Unack ReliableBunch</code>过多造成的, 那么,
我怎么才能知道当前有哪些<code>ReliableBunch</code>没有<code>ACK</code>呢?
UE本身已经有相关功能: 当溢出时,
打印出所有<code>ReliableBunch</code>信息.
如果知道当前有哪些<code>ReliableBunch</code>, 那么就可以通过查看逻辑,
来排查为什么会突然发送过多的<code>ReliableBunch</code>,
再进一步处理.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127211647465.png" /></p>
<p>进一步分析发现, 其打印的是<code>FOutBunch.DebugString</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127114143774.png" /></p>
<h2 id="开启命令">开启命令</h2>
<p>开启命令:<code>net.Reliable.Debug</code>后,
在非<code>UE_BUILD_SHIPPING || UE_BUILD_TEST</code>下会记录<code>ReliableBunch</code>
<code>Debug</code>信息.</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">TAutoConsoleVariable&lt;int32&gt; CVarNetReliableDebug(</span><br><span class="line">    <span class="name">TEXT</span>(<span class="string">&quot;net.Reliable.Debug&quot;</span>),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    TEXT(<span class="string">&quot;Print all reliable bunches sent over the network\n&quot;</span>)</span><br><span class="line">    TEXT(<span class="string">&quot; 0: no print.\n&quot;</span>)</span><br><span class="line">    TEXT(<span class="string">&quot; 1: Print bunches as they are sent.\n&quot;</span>)</span><br><span class="line">    TEXT(<span class="string">&quot; 2: Print reliable bunch buffer each net update&quot;</span>),</span><br><span class="line">    ECVF_Default)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127115328314.png" /></p>
<ul>
<li><code>net.Reliable.Debug 0</code>: 默认, 不记录,
也不输出任何信息.</li>
<li><code>net.Reliable.Debug 1</code>:
仅仅输出当前<code>ReliableBunch</code>信息, 并且在Overflow时候,
会输出当前具体有哪些ReliableBunch没有ACK.</li>
<li><code>net.Reliable.Debug 2</code>: 每次发送ReliableBunch时,
都会输出当前<code>ActorChannel</code>没有ACK的ReliableBunch信息.
并且在Overflow时候, 会输出当前具体有哪些ReliableBunch没有ACK.</li>
<li><code>net.Reliable.Debug 3</code>: 仅仅在Overflow时候,
输出当前具体有哪些ReliableBunch没有ACK.(任何大于2的数值都可以,
这里选择3)</li>
</ul>
<h2
id="填充foutbunch.debugstring">填充<code>FOutBunch.DebugString</code></h2>
<h3 id="发送rpc时填充">发送RPC时填充</h3>
<p><code>UNetDriver.ProcessRemoteFunctionForChannelPrivate</code></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127115028558.png" /></p>
<h3 id="replicateactor时填充"><code>ReplicateActor</code>时填充</h3>
<p><code>UActorChannel.ReplicateActor</code></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127115059988.png" /></p>
<h3 id="分包时候填充">分包时候填充</h3>
<p><code>UChannel.SendBunch</code>. <span style="color:red;">注意:
一个分Bunch是1M的. </span></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">日志:</span><br><span class="line"><span class="symbol">LogNetTraffic:</span> Warning: <span class="keyword">Out</span>: Partial[<span class="number">1</span>]: <span class="number">2.28</span> RPC: ...</span><br><span class="line"><span class="symbol">LogNetTraffic:</span> Warning: <span class="keyword">Out</span>: Partial[<span class="number">2</span>]: <span class="number">2.28</span> RPC: ...</span><br><span class="line"><span class="symbol">LogNetTraffic:</span> Warning: <span class="keyword">Out</span>: Partial[<span class="number">3</span>]: <span class="number">2.28</span> RPC: ...</span><br><span class="line"><span class="symbol">LogNetTraffic:</span> Warning: <span class="keyword">Out</span>: Partial[<span class="number">4</span>]: <span class="number">2.28</span> RPC: ...</span><br><span class="line"><span class="symbol">LogNetTraffic:</span> Warning: <span class="keyword">Out</span>: Partial[<span class="number">5</span>]: <span class="number">2.28</span> RPC: ...</span><br><span class="line"><span class="symbol">LogNetTraffic:</span> Warning: <span class="keyword">Out</span>: Partial[<span class="number">6</span>]: <span class="number">2.28</span> RPC: ...</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231128170608865.png" /></p>
<h2 id="溢出时-输出信息">溢出时, 输出信息</h2>
<p>当Unack ReliableBunch超过<code>RELIABLE_BUFFER</code>(256)时,
会将Connection关闭.</p>
<h3 id="sendbunch时溢出">SendBunch时溢出</h3>
<p>如果一个Bunch含有GUID, 当发送Bunch时候, 会生成GUIDBunch+Bunch,
如果此时超过256,
会在<code>UChannel::SendBunch</code>中CloseConnection.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UE_LOG</span>(LogNetPartialBunch, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;SendBunch: Reliable partial bunch overflows reliable buffer! %s&quot;</span>), *<span class="built_in">Describe</span>() );</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogNetPartialBunch, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Num OutgoingBunches: %d. NumOutRec: %d&quot;</span>), OutgoingBunches.<span class="built_in">Num</span>(), NumOutRec );</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127115600544.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127115610697.png" /></p>
<h3 id="发送rpc时溢出">发送RPC时溢出</h3>
<p>当发送RPC时候, 也有可能触发Overflow.
会在<code>UNetDriver::ProcessRemoteFunctionForChannelPrivate</code>函数中CloseConnection.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231128200046379.png" /></p>
<p>Bunch
Error的原因是在FOutBunch构造函数中判断当前ActorChannel的NumOutRec是否overflow,
:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231128215941365.png" /></p>
<h1 id="溢出原因">溢出原因</h1>
<p>从代码上看, 是因为<code>UChannel.NumOutRec</code>过多了,
即没有<code>ACK</code>的<code>ReliableBunch</code>累计到一定程度了,
很严重, 需要关闭<code>Connection</code>. <span
style="color:red;">任意一个ActionChannel累计的<code>Unack</code> <code>ReliableBunch</code>过多都会造成整个<code>Connection</code>的关闭. </span></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127121847298.png" /></p>
<h2 id="重连还会溢出吗">重连还会溢出吗</h2>
<p>由于溢出后, <code>Connection</code>已经关闭(销毁了),
重连后会新建Connection, 之前Connection的数据全部丢失, 所以,
重连后会不会溢出全看重连逻辑.</p>
<h1 id="合并reliablebunch">合并<code>ReliableBunch</code></h1>
<p>是不是每个<code>ReliableBunch</code>都独占一个<code>NumOutRec</code>呢?
即每发送一个<code>ReliableBunch</code>,
都会将<code>NumOutRec</code>加1?</p>
<p>答: 不是的. 如果可以合并, 会优先合并Bunch, 佐证代码:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127140519900.png" /></p>
<h2 id="是否可以合并">是否可以合并</h2>
<p>判断ReliableBunch是否可以合并是多方面的.</p>
<h3 id="函数允许merge">函数允许Merge</h3>
<p>调用该函数, 必须允许Merge:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127200059782.png" /></p>
<h3
id="具有exportguid的bunch不能合并">具有ExportGUID的Bunch,不能合并</h3>
<p>如果一个Bunch需要ExportGUID, 会在该Bunch之前放一个ExportBunch.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127200535283.png" /></p>
<h3
id="含有foutbunch.bhasmustbemappedguids不能合并">含有<code>FOutBunch.bHasMustBeMappedGUIDs</code>不能合并</h3>
<p><code>MustBeMappedGUID</code>用于加载资源.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127202859798.png" /></p>
<h3 id="chindexreliable">ChIndex+Reliable</h3>
<p>ChannelIndex必须相同, 必须是Relaible的.
即必须是同一个ActorChannel的ReliableBunch才能合并</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127203040518.png" /></p>
<h3 id="connection开启allowmerge">Connection开启AllowMerge</h3>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127203108290.png" /></p>
<h3 id="其他条件">其他条件</h3>
<ol type="1">
<li><p>合并前提必须是之前就存数据, 否则没有合并目标.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127203209146.png" /></p></li>
<li><p>记录的待发送的SendBuffer必须和之前一致.
必须是连续的ReliableBunch,
如果中间插入UnreliableBunch则不能合并.</p></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127203541982.png" /></p>
<ol start="3" type="1">
<li>有可合并的空间, 即合并之后不能超过bunch的最大限度.</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127203751480.png" /></p>
<h3 id="总结">总结</h3>
<table>
<tr>
<td bgcolor="#D5E8D4">
可以合并的条件: <br>   1. 函数输入开启Merge <br>   2.
Connection允许Merge <br>   3. 同一个ActorChannel,
ReliableBunch必须是连续的, 中间不能插入任何其他Bunch <br>   4.
之前必须有Bunch, 才能将当前Bunch合并到之前的Bunch. <br>   5.
合并后大小必须小于单个Bunch上限(如果超了还得分Bunch, 就没必要合并了)
<br>
</td>
</tr>
</table>
<h2 id="旧bunch怎么和新bunch合并">旧Bunch怎么和新Bunch合并</h2>
<p>使用<code>UNetConnection.LastOut</code>存储之前的Bunch, 如果条件允许,
将当前Bunch与之前bunch合并, 并替代之前的bunch. 详见:<a
href="#UNetConnection.LastOut">UNetConnection.LastOut</a></p>
<h2 id="reliablebunch链表怎么处理">ReliableBunch链表怎么处理</h2>
<p>使用<code>UNetConnection.LastOutBunch</code>代表ReliableBunch链表中最后一个Bunch,
如果可以合并,
将<code>UNetConnection.LastOutBunch</code>赋值为此Bunch和新Bunch合并后的bunch.
详见: <a
href="#UNetConnection.LastOutBunch">UNetConnection.LastOutBunch</a>.</p>
<h2 id="sendbuffer中数据怎么处理">SendBuffer中数据怎么处理</h2>
<p>使用<code>UNetConnection.LastStart</code>记录可合并Bunch之前的SendBuffer数据,
每当有可合并Bunch到来时,
可以根据<code>UNetConnection.LastStart</code>把SendBuffer中之前可合并的Bunch剔除掉.
详见: <a
href="#UNetConnection.LastStart">UNetConnection.LastStart</a>.</p>
<h2 id="相关变量">相关变量</h2>
<h3 id="unetconnection.lastend">UNetConnection.LastEnd</h3>
<p>记录之前的<code>UNetConnection.SendBuffer</code>.
用于和当前的SendBuffer比较, 如果一致, 则表示可以合并, 不一致则不能合并.
<span style="color:red;">用该变量限制ReliableBunch必须是连续的,
比如中间插入了一个UnreliableBunch则不能合并. </span></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">FBitWriterMark  LastEnd; <span class="comment">// Most recently sent bunch end.</span></span><br></pre></td></tr></table></figure>
<p>在<code>UChannel.SendBunch</code>时,
<code>UNetConnection.LastEnd</code>会设置成<code>UNetConnection.SendBuffer</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127172114128.png" /></p>
<p>在<code>UNetConnection::FlushNet</code>时,
会将<code>UNetConnection.LastEnd</code>置空, 意思是, 如果真的发送了,
lastEnd就是空的.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127171938260.png" /></p>
<p>但是为什么还要和<code>UNetConnection.SendBuffer</code>比较呢?
能合并的条件必须是上次的SendBuffer还没发送出去,
可以将当前的Bunch合并到这个SendBuffer里面.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127173258040.png" /></p>
<h3 id="unetconnection.lastout">UNetConnection.LastOut</h3>
<p>可以把它看成已经存储到SendBuffer中, 但是还没有发送出去的Bunch,
这个bunch可能是单个Bunch, 也可能是合并后的Bunch, 并且如果条件允许,
还可以和当前Bunch合并成新的Bunch. 将新Bunch
merge到<code>UNetConnection.LastOut</code>中,
然后UNetConnection.LastOut又指向Merge后的bunch.</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">FOutBunch    LastOut<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127174947503.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127175949744.png" /></p>
<h3 id="unetconnection.laststart">UNetConnection.LastStart</h3>
<p>最近发送的Bunch, 用它记录之前的SendBuffer.
每当一个可与之前Bunch合并的Bunch到来时,
将SendBuffer中之前Bunch的数据清除掉,
然后发送之前Bunch和新Bunch合并的Bunch. 这个行为是可重复的.</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">FBitWriterMark  LastStart;    <span class="comment">// Most recently sent bunch start.</span></span><br></pre></td></tr></table></figure>
<p>记录之前SendBuffer数据.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127190200001.png" /></p>
<p>将SendBuffer恢复到发送上一个Bunch之前的样子,
即在SendBuffer中剔除上一个Bunch.
因为新的Bunch已经和上一个Bunch合并成最新的Bunch, 一起发送.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127190602662.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127190743463.png" /></p>
<p>合并之后, 将之前的Bunch从SendBuffer中剔除.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127191119723.png" /></p>
<h3 id="unetconnection.lastoutbunch">UNetConnection.LastOutBunch</h3>
<p>UE中每个ActorChannel都有一个ReliableBunch链表,
里面存储着待Ack的ReliableBunch, 以便丢包后重发. 针对可合并的bunch,
需要记录链表中最后一个bunch, 如果有一个可以合并的Bunch来到,
可以将其合并到链表的最后一个Bunch中. 具体逻辑就是:</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Most recent outgoing bunch.</span></span><br><span class="line">FOutBunch*        LastOutBunch;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231127194317192.png" /></p>
<h1 id="总结-1">总结</h1>
<p>由于远端没有及时响应, 导致<code>ReliableBunch</code>积累过多,
当超过256时, UE会关闭连接. UE为了减少ReliableBunch个数,
默认增加了合并机制.
当同一个ActorChannel处理的ReliableBunch可合并时(ReliableBunch必须是连续的),
进行合并. 合并后作为一个Bunch进行发送.</p>
<h1 id="测试用例">测试用例</h1>
<p>构建重现Overflow的测试代码:</p>
<h2 id="两个actor交替发送rpc">两个Actor交替发送RPC</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FVector Loc = FVector::ZeroVector;</span><br><span class="line">FRotator Rot = FRotator::ZeroRotator;</span><br><span class="line">FActorSpawnParameters Par;</span><br><span class="line">Par.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;</span><br><span class="line">UClass* pClass = <span class="built_in">LoadObject</span>&lt;UClass&gt;(<span class="keyword">this</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Blueprint&#x27;/Game/Test/TestRepFlow/BPTestRepFlowSpawnedActor.BPTestRepFlowSpawnedActor_C&#x27;&quot;</span>));</span><br><span class="line">TestRepFlowSpawnedActor = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AActor&gt;(pClass, Loc, Rot, Par);</span><br><span class="line">TestRepFlowSpawnedActor-&gt;<span class="built_in">SetAutonomousProxy</span>(<span class="literal">true</span>);</span><br><span class="line">TestRepFlowSpawnedActor-&gt;<span class="built_in">SetOwner</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">TestRepFlowSpawnedActor12 = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AActor&gt;(pClass, Loc, Rot, Par);</span><br><span class="line">TestRepFlowSpawnedActor12-&gt;<span class="built_in">SetAutonomousProxy</span>(<span class="literal">true</span>);</span><br><span class="line">TestRepFlowSpawnedActor12-&gt;<span class="built_in">SetOwner</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ATestRepFlowSpawnedActor *pTestRepFlowSpawnedActor = <span class="built_in">Cast</span>&lt;ATestRepFlowSpawnedActor&gt;(TestRepFlowSpawnedActor))</span><br><span class="line">&#123;</span><br><span class="line">    ATestRepFlowSpawnedActor* pTestRepFlowSpawnedActor12 = <span class="built_in">Cast</span>&lt;ATestRepFlowSpawnedActor&gt;(TestRepFlowSpawnedActor12);</span><br><span class="line">    pTestRepFlowSpawnedActor-&gt;mTestNumber = <span class="number">998</span>;</span><br><span class="line">    pTestRepFlowSpawnedActor-&gt;TestRepFlowSpawnedCmp = <span class="built_in">NewObject</span>&lt;UTestRepFlowSpawnedCmp&gt;(pTestRepFlowSpawnedActor, UTestRepFlowSpawnedCmp::<span class="built_in">StaticClass</span>());</span><br><span class="line">    pTestRepFlowSpawnedActor-&gt;TestRepFlowSpawnedCmp-&gt;<span class="built_in">RegisterComponent</span>();</span><br><span class="line">    pTestRepFlowSpawnedActor-&gt;TestRepFlowSpawnedCmp-&gt;TestNumber = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; <span class="number">300</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// for test overflow</span></span><br><span class="line">        pTestRepFlowSpawnedActor-&gt;<span class="built_in">S2C_TestRealiableFunc</span>();</span><br><span class="line">        <span class="comment">//pTestRepFlowSpawnedActor-&gt;S2C_TestRealiableFunc();</span></span><br><span class="line">        pTestRepFlowSpawnedActor12-&gt;<span class="built_in">S2C_TestRealiableFunc</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//pTestRepFlowSpawnedActor-&gt;ServerMulti_TestReliableFunc();</span></span><br><span class="line">        <span class="comment">//pTestRepFlowSpawnedActor-&gt;ServerMulti_TestUnreliableFunc();</span></span><br><span class="line">    &#125;</span><br><span class="line">    pTestRepFlowSpawnedActor-&gt;<span class="built_in">S2C_TestRealiableFunc</span>();</span><br><span class="line">    <span class="built_in">DebugLogALSV</span>(<span class="string">&quot;ATestRepFlowActor::Tick Spawn TestRepFlowSpawnedCmp FrameIndex[%lu]&quot;</span>, GFrameNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行堆栈后,
会在函数<code>UNetDriver.ProcessRemoteFunctionForChannelPrivate</code>中CloseConnection:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231128195854028.png" /></p>
<p>BunchError的原因:ActorChannel内ReliableBunch Overflow了</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231128200315759.png" /></p>
<h2
id="一个actor交替发送reliablerpc和unreliablerpc不行">一个Actor交替发送ReliableRPC和UnreliableRPC(不行)</h2>
<p><span style="color:red;">这种方法不会造成ReliableBunch Overflow.
</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FVector Loc = FVector::ZeroVector;</span><br><span class="line">FRotator Rot = FRotator::ZeroRotator;</span><br><span class="line">FActorSpawnParameters Par;</span><br><span class="line">Par.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;</span><br><span class="line">UClass* pClass = <span class="built_in">LoadObject</span>&lt;UClass&gt;(<span class="keyword">this</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Blueprint&#x27;/Game/Test/TestRepFlow/BPTestRepFlowSpawnedActor.BPTestRepFlowSpawnedActor_C&#x27;&quot;</span>));</span><br><span class="line">TestRepFlowSpawnedActor = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AActor&gt;(pClass, Loc, Rot, Par);</span><br><span class="line">TestRepFlowSpawnedActor-&gt;<span class="built_in">SetAutonomousProxy</span>(<span class="literal">true</span>);</span><br><span class="line">TestRepFlowSpawnedActor-&gt;<span class="built_in">SetOwner</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">TestRepFlowSpawnedActor12 = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AActor&gt;(pClass, Loc, Rot, Par);</span><br><span class="line">TestRepFlowSpawnedActor12-&gt;<span class="built_in">SetAutonomousProxy</span>(<span class="literal">true</span>);</span><br><span class="line">TestRepFlowSpawnedActor12-&gt;<span class="built_in">SetOwner</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ATestRepFlowSpawnedActor *pTestRepFlowSpawnedActor = <span class="built_in">Cast</span>&lt;ATestRepFlowSpawnedActor&gt;(TestRepFlowSpawnedActor))</span><br><span class="line">&#123;</span><br><span class="line">    ATestRepFlowSpawnedActor* pTestRepFlowSpawnedActor12 = <span class="built_in">Cast</span>&lt;ATestRepFlowSpawnedActor&gt;(TestRepFlowSpawnedActor12);</span><br><span class="line">    pTestRepFlowSpawnedActor-&gt;mTestNumber = <span class="number">998</span>;</span><br><span class="line">    pTestRepFlowSpawnedActor-&gt;TestRepFlowSpawnedCmp = <span class="built_in">NewObject</span>&lt;UTestRepFlowSpawnedCmp&gt;(pTestRepFlowSpawnedActor, UTestRepFlowSpawnedCmp::<span class="built_in">StaticClass</span>());</span><br><span class="line">    pTestRepFlowSpawnedActor-&gt;TestRepFlowSpawnedCmp-&gt;<span class="built_in">RegisterComponent</span>();</span><br><span class="line">    pTestRepFlowSpawnedActor-&gt;TestRepFlowSpawnedCmp-&gt;TestNumber = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; <span class="number">300</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// for test overflow</span></span><br><span class="line">        pTestRepFlowSpawnedActor-&gt;<span class="built_in">S2C_TestRealiableFunc</span>();</span><br><span class="line">        <span class="comment">//pTestRepFlowSpawnedActor-&gt;S2C_TestRealiableFunc();</span></span><br><span class="line">        pTestRepFlowSpawnedActor12-&gt;<span class="built_in">S2C_TestRealiableFunc</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//pTestRepFlowSpawnedActor-&gt;ServerMulti_TestReliableFunc();</span></span><br><span class="line">        <span class="comment">//pTestRepFlowSpawnedActor-&gt;ServerMulti_TestUnreliableFunc();</span></span><br><span class="line">    &#125;</span><br><span class="line">    pTestRepFlowSpawnedActor-&gt;<span class="built_in">S2C_TestRealiableFunc</span>();</span><br><span class="line">    <span class="built_in">DebugLogALSV</span>(<span class="string">&quot;ATestRepFlowActor::Tick Spawn TestRepFlowSpawnedCmp FrameIndex[%lu]&quot;</span>, GFrameNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因: 在发送UnreliableRPC时候, 直接丢弃了. 丢弃的原因是流量超发了,
DS端一次性发这么多对方接受不了.</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// Bunch Overflow, 不能发送unreliable RPC堆栈</span><br><span class="line">--ABasePlayerController.Tick</span><br><span class="line">|<span class="string">--AActor.ProcessEvent.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UObject.ProcessEvent.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--AActor.CallRemoteFunction.if.for.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UNetDriver.ProcessRemoteFunction.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UReplicationGraph.ProcessRemoteFunction.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// If we&#x27;re saturated and it&#x27;s not a reliable multicast, drop it.</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--if (!(bIsReliable </span>||<span class="string"> IsConnectionReady(Connection)))</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--&#123;</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--    return true;</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="unetconnection.queuedbits">UNetConnection.QueuedBits</h3>
<p>为了更好理解<code>UReplicationGraph::IsConnectionReady</code>函数,
这里单门说一下<code>UNetConnection.QueuedBits</code>.
它是为了限制带宽用的. 即不能超量发送, 要适应接受方的带宽.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UReplicationGraph::IsConnectionReady</span><span class="params">(UNetConnection* Connection)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CVar_RepGraph_DisableBandwithLimit)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Connection-&gt;QueuedBits + Connection-&gt;SendBuffer.<span class="built_in">GetNumBits</span>() &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化">初始化</h4>
<p>初始化时为0.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231129092418257.png" /></p>
<h4 id="更改">更改</h4>
<p>在<code>UNetConnection.FlushNet</code>中,
发送<code>SendBuffer</code>之后, 会将当前Packet的bit数,
累加到<code>UNetConnection.QueuedBits</code>中.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231128204057394.png"
alt="image-20231128204057394" />
<figcaption aria-hidden="true">image-20231128204057394</figcaption>
</figure>
<p>并且在每次Tick时候, 根据网络Tick频率和当前网络速度,
预计后续能发送的数据大小.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231128204547769.png" /></p>
<h3 id="总结-2">总结</h3>
<p>一个Actor交替发送ReliableRPC和UnreliableRPC, 不能触发Overflow,
在发送Unreliable RPC的时候, 由于远端带宽限制,
DS检测到<code>IsConnectionReady</code>为false, 即流量超发了,
远端无法收到. 进而直接丢弃UnreliableRPC.
导致看似ReliableRPC与UnreliableRPC交替发送, 其实只发送了ReliableRPC.
而ReliableBunch如果满足条件会合并的, 恰好测试用例满足了合并的条件,
即合并了. 所以, 没有触发Overflow</p>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>ReliableBunch溢出</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>ReliableBunch溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4消息结构</title>
    <url>/2023/11/09/UE/%E7%BD%91%E7%BB%9C/UE%20%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/BunchArchetype.png"
alt="BunchArchetype" />
<figcaption aria-hidden="true">BunchArchetype</figcaption>
</figure>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>UE4消息结构</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC浅析</title>
    <url>/2023/11/09/UE/%E7%BD%91%E7%BB%9C/RPC%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/BunchArchetype.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712154008824.png" /></p>
<span id="more"></span>
<h1 id="发送rpc">发送RPC</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送RPC堆栈</span></span><br><span class="line">--APlayerController::<span class="built_in">ClientSetHUD</span>()</span><br><span class="line"> |--AActor::<span class="built_in">ProcessEvent</span>() </span><br><span class="line"> | |--UObject.<span class="built_in">ProcessEvent</span>()</span><br><span class="line"> | | |--AActor.<span class="built_in">CallRemoteFunction</span>()</span><br><span class="line"> | | | |--UNetDriver.<span class="built_in">ProcessRemoteFunction</span>() </span><br><span class="line"> | | | | |--UNetDriver.<span class="built_in">InternalProcessRemoteFunctionPrivate</span>()</span><br><span class="line"> | | | | | |--UNetDriver.<span class="built_in">ProcessRemoteFunctionForChannelPrivate</span>()</span><br><span class="line"> | | | | | | |--<span class="comment">// 如果该Channel第一次发送消息, 则首先进行属性同步, 创建对应的Actor.</span></span><br><span class="line"> | | | | | | |--Ch-&gt;<span class="built_in">ReplicateActor</span>(); <span class="comment">// UActorChannel.ReplicateActor()</span></span><br><span class="line"> | | | | | | |--FRepLayout.<span class="built_in">SendPropertiesForRPC</span>()</span><br><span class="line"> | | | | | | | |-- 遍历所有参数, 对参数进行序列化.</span><br><span class="line"> | | | | | | | |-- 如果该参数不需要序列化, 则将send标记为<span class="number">0</span>, 表示后边无数据</span><br><span class="line"> | | | | | | | |-- 如果该参数需要序列化, 则将send标记为<span class="number">1</span>, 表示后边有数据.</span><br><span class="line"> | | | | | | | |-- 由于两端使用同一个版本的函数, 所以直接按照类型解析即可.</span><br><span class="line"> | | | | | | |-- 添加FieldHeader--WriteFieldHeaderAndPayload</span><br><span class="line"> | | | | | | |-- 添加ContentBlockHeader</span><br></pre></td></tr></table></figure>
<p>从上面堆栈可以看出, 任何一个UObj RPC时候,
需要找到使用哪个Channel发送数据. Channel和Actor绑定,
所以需要找到对应的Actor, UObj找Actor的方法一般是通过Outer. 所以,
这里引出<a href="/2023/11/09/UE/%E7%BD%91%E7%BB%9C/%E8%87%AA%E5%AE%9A%E4%B9%89UObject%E8%BF%9B%E8%A1%8CReplicate/" title="自定义UObject进行Replicate">自定义UObject进行Replicate</a>的时候,
需要重写CallRemoteFunction和GetFunctionCallspace(用于识别本地执行还是远端执行).</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712114033485.png" /></p>
<h2 id="识别本地执行还是远端执行.">识别本地执行还是远端执行.</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711153024568.png" /></p>
<h2 id="使用actor归属的netdriver-执行该函数.">使用Actor归属的NetDriver,
执行该函数.</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711153217877.png" /></p>
<h2 id="处理multicast">处理Multicast</h2>
<p>如果是Multicast, 需要遍历所有Connection依次发送.,
因为所有Connection共用同一套参数,
可以使用SharedSerialization对参数进行优化.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711154724281.png" /></p>
<h2
id="如果channel第一次发送数据-要首先进行属性同步">如果Channel第一次发送数据,
要首先进行属性同步</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711193002238.png" /></p>
<h2 id="填充消息代码">填充消息代码</h2>
<p>body结构: bSend+属性</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711193541016.png" /></p>
<h2 id="填充rpc消息头">填充RPC消息头</h2>
<p>RPC消息头是由ContentBlockHeader+FileHeader组成.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711193423959.png" /></p>
<p>相关代码:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711193135874.png" /></p>
<p>注意, 这里还会填入Payload的bit大小, 用于远端处理该数据包.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712154111630.png" /></p>
<h1 id="接收rpc">接收RPC</h1>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// 接收RPC堆栈</span><br><span class="line">--UIpNetDriver.TickDispatch()</span><br><span class="line"> |<span class="string">--UNetConnection.ReceivedRawPacket() </span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string">--UNetConnection.ReceivedPacket()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedRawBunch()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedNextBunch() </span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedSequencedBunch()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReceivedBunch()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedRPC()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceivePropertiesForRPC()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.SerializeProperties_r()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--AActor.ProcessEvent()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UObject.ProcessEvent()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UFunction.Invoke()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ABasePlayerController.execChangeControllerNumber()</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ABasePlayerController.ChangeControllerNumber_Implementation </span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712104528401.png" /></p>
<h2 id="解析contentblock">解析ContentBlock</h2>
<p>解析ContentBlockHeader, 提取出Obj, 然后将Payload传递下去.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712103608109.png"
alt="image-20230712103608109" />
<figcaption aria-hidden="true">image-20230712103608109</figcaption>
</figure>
<p>在提取Payload时, 还要设置PayloadData的大小. 在后面解析PayloadData时,
用于判断data数据是否结束.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711200652815.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711200817679.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711200905448.png" /></p>
<h2 id="先处理属性同步">先处理属性同步</h2>
<p>如果该Bunch中有属性同步, 则先解析属性同步.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712103912077.png" /></p>
<h2 id="解析每个参数">解析每个参数</h2>
<p>首先为每个参数赋默认值.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712104049928.png" /></p>
<p>然后根据Send比特位数据, 解析参数.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712104158605.png" /></p>
<h2 id="调用rpc函数">调用RPC函数</h2>
<p>如果一切顺利, 则最终会调用这里:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712104622743.png" /></p>
<h1 id="rpc-queuebunch">RPC QueueBunch</h1>
<ol type="1">
<li>QueueBunch一般针对UnReliable FUNC_NetMulticast RPC.</li>
<li>QueueBunch时UObject级别,
因为Actor/ActorComponent/ReplicationUObject都可能有自己的UnReliable
FUNC_NetMulticast RPC.</li>
<li>QueueBunch会放入RemoteFunctions中,
在ReplicateProperty时候将<code>RemoteFunctions</code>放入<code>Bunch</code>中,
进而发送.</li>
<li>QueueBunch是一种优化, 将RPC信息随ReplicationBunch一同发送,
目的是减少流量.</li>
</ol>
<h2 id="确定为queuebunch">确定为QueueBunch</h2>
<p>首先根据类型确定其是否为<code>QueueBunch</code>,
默认情况下<code>UnReliable FUNC_NetMulticast RPC</code>为QueueBunch.
仅仅填充<code>FieldHeaderAndPayload</code>然后放入Replicator的RemoteFunctions中</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230907112900166.png" /></p>
<h2 id="缓存rpc信息">缓存RPC信息</h2>
<p>每个<code>PendingNetRPC</code>维护一个<code>FRPCCallInfo</code>,
里面记录着RPC的名字和调用次数. 如果超过一定限度, 会直接丢弃.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230907111559173.png"
alt="如果超过一定限度, 会直接丢弃." />
<figcaption aria-hidden="true">如果超过一定限度,
会直接丢弃.</figcaption>
</figure>
<p>如果满足条件,
则将QueueBunch放入<code>FObjectReplicator.RemoteFunctions</code>中,
等待发送.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230907111857135.png" /></p>
<h2
id="将remotefunctions合入replicationbunch中">将RemoteFunctions合入ReplicationBunch中</h2>
<p>在<code>FObjectReplicator.ReplicateProperties</code>时候,
将<code>RemoteFunctions</code>信息合入Bunch中.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230907112035162.png"
alt="image-20230907112035162" />
<figcaption aria-hidden="true">image-20230907112035162</figcaption>
</figure>
<h2 id="当没有onrep时候-怎么处理呢">当没有OnRep时候, 怎么处理呢?</h2>
<h1 id="思考">思考</h1>
<h2
id="属性同步会执行readfieldheaderandpayload吗">属性同步会执行ReadFieldHeaderAndPayload吗?</h2>
<p>会的, 但是如果发现Bunch已经到结尾了, 就直接返回了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230710191046485.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230710191103391.png" /></p>
<h2 id="ds和客户端的函数不匹配">DS和客户端的函数不匹配</h2>
<h3 id="客户端向ds发送rpc">客户端向DS发送RPC</h3>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 主端代码:</span><br><span class="line">UFUNCTION(Server, Reliable)</span><br><span class="line">void ChangeControllerNumber(int32 InNumber, int32 InNumber2);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> DS端代码:</span><br><span class="line">UFUNCTION(Server, Reliable)</span><br><span class="line">void ChangeControllerNumber(int32 InNumber);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> tick时候, 主端向DS发送消息:</span><br><span class="line"><span class="keyword">if</span> (GetLocalRole() == ENetRole::ROLE_AutonomousProxy)</span><br><span class="line">&#123;</span><br><span class="line">    ++LocalControllerNumber;</span><br><span class="line">    ChangeControllerNumber(LocalControllerNumber, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 报错:</span><br><span class="line">[<span class="number">2023.07</span>.<span class="number">11</span>-<span class="number">16.56</span>.<span class="number">32</span>:<span class="number">153</span>][<span class="number">161</span>]LogNet: Error: ReceivedRPC: ReceivePropertiesForRPC - Mismatch read. Function: ChangeControllerNumber, Object: NewPlayerController_C <span class="regexp">/Game/</span>ThirdPersonCPP<span class="regexp">/Maps/</span>ThirdPersonExampleMap.ThirdPersonExampleMap:PersistentLevel.NewPlayerController_C_2147482552</span><br><span class="line">[<span class="number">2023.07</span>.<span class="number">11</span>-<span class="number">16.56</span>.<span class="number">32</span>:<span class="number">158</span>][<span class="number">161</span>]LogNet: Error: UActorChannel::ProcessBunch: Replicator.ReceivedBunch failed.  Closing connection. RepObj: NewPlayerController_C <span class="regexp">/Game/</span>ThirdPersonCPP<span class="regexp">/Maps/</span>ThirdPersonExampleMap.ThirdPersonExampleMap:PersistentLevel.NewPlayerController_C_2147482552, Channel: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>FObjectReplicator::ReceivedRPC里面有各种检测.
只有完全匹配的函数才能执行.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711170636947.png" /></p>
<p>踢掉连接的原因为FObjectReplicator.ReceivedRPC()函数返回false,
并一路返回false之后, DS直接关闭连接.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712110658509.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712110837061.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712110854484.png" /></p>
<p>结果: DS直接关闭链接, 踢掉客户端.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711170811825.png" /></p>
<h3 id="ds向客户端发送rpc">DS向客户端发送RPC</h3>
<p>首次接收到RPC时, 在解析属性时候,
如果解析过程出了问题(ReaderBit到了Reader结尾, 读取参数个数错误等),
会直接将FieldCache-&gt;bIncompatible设置为true,
表示该结构体在DS与客户端不兼容, 后边所有收到该函数的RPC都会直接丢弃.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711175722045.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711175552179.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230712104908630.png" /></p>
<p>丢弃逻辑: DS再次发来RPC, 发现其FFieldNetCache.bIncompatible为true,
则直接忽略.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711175424928.png" /></p>
<p>总结: DS向客户端发送RPC, 如果不匹配, 客户端只是丢弃该RPC,
其他正常执行.</p>
<h2
id="每个bunch最多只能包含一个rpc吗">每个Bunch最多只能包含一个RPC吗?</h2>
<p>这个是根据bunch类型决定的, 首先来看一下Bunch的填充流程:</p>
<p>声明bunch:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711201941211.png" /></p>
<p>填充bunch body:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711202339200.png" /></p>
<p>如果是QueueBunch, 则将bunch拼接, 注意:这里只填充了FileHeader+Body.
而且QueueBunch是需要满足特殊条件的:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711204811520.png" /></p>
<p>如果不是QueueBunch,则需要填充ContentBlock+FileHeader+Body.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711202007878.png" /></p>
<p>发送bunch:</p>
<p><strong>如果是QueueBunch则</strong>,
将其放入FObjectReplicator.RemoteFunctions中.
最终会在FObjectReplicator.ReplicateProperties时候一同发送给客户端.
所以从这一点还可以看出, 只有DS才能有QueueBunch.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711205142296.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711205519636.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711205602645.png" /></p>
<p><strong>如果不是则直接发送:</strong></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711202249276.png" /></p>
<p><strong>从解析RPC代码来看,
是允许多个RPC组合在一个Bunch里面的.</strong></p>
<p>循环处理FileHeader+Body.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230711202732725.png" /></p>
<h2 id="ffieldnetcache">FFieldNetCache</h2>
<p>在发送RPC过程中将FieldNetIndex序列化到Bunch中.
在接收RPC时,通过FieldNetIndex找到对应的处理函数, 然后调用.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230713104043916.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230713104204410.png" /></p>
<p>其数据结构如下:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230713143443034.png" /></p>
<p>其中:</p>
<ol type="1">
<li>FClassNetCache.FieldsBase:该FClassNetCache所描述的类的起始索引</li>
<li>FClassNetCache.Super: 其对应Class的父类的FClassNetCache</li>
<li>FClassNetCache.Fields:所有能进行网络传输的数据, 包括变量和函数.</li>
<li>FClassNetCache.FieldMap: 函数/UObj地址-FFieldNetCache指针,
可以通过变量或者函数地址查询其FClassNetCache</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230713144713000.png" /></p>
<p>DS和客户端能够构建一套相同结构的类,
就可以通过只传输Index就能索引对应的属性, 然后进行操作.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230713145000205.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230713150329279.png" /></p>
<h3 id="注意">注意</h3>
<p>在UClass中, 将网络同步的变量放在了<code>UClass.ClassReps</code>中,
将网络同步的函数放在了<code>UClass.NetFields</code>中,
并且他们的初始化全部都在<code>Class-&gt;SetUpRuntimeReplicationData();</code>中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230814110023022.png" /></p>
<h1 id="总结">总结</h1>
<ol type="1">
<li>RPC Bunch由ContentBlockHeader+[FileHeader+ParamList] list构成</li>
<li>DS与客户端函数不匹配---如果DS向客户端发送RPC, 客户端只报一次错误,
并将FieldCache-&gt;bIncompatible设置为true, 后续遇到该RPC直接丢弃.</li>
<li>DS与客户端函数不匹配---如果客户端向DS发送RPC,
DS直接踢掉该Connection.</li>
</ol>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4 FastArray</title>
    <url>/2023/11/09/UE/%E7%BD%91%E7%BB%9C/UE%20FastArray/</url>
    <content><![CDATA[<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/UE4%E7%BD%91%E7%BB%9C-CustomDeltaProperty%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.drawio1.png"
alt="FastArray处理流程" />
<figcaption aria-hidden="true">FastArray处理流程</figcaption>
</figure>
<span id="more"></span>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/FastArrayMsgArchitecture.png"
alt="FastArray消息架构图" />
<figcaption aria-hidden="true">FastArray消息架构图</figcaption>
</figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230906145455490.png" /></p>
<h1 id="提问">提问</h1>
<ol type="1">
<li><p>普通TArray和FastArray的增删改查有什么区别?
(文中有FastArray详细讲解)</p></li>
<li><p>普通TArray有哪些缺点, FastArray优化了哪些点? (文末指出)</p></li>
<li><p>类似于HistoryChangedList, FastArray怎么实现的?
(Retirement+HistoryList)</p></li>
<li><p>ReceivingRepState, SendingRepState, FastArray又是怎么实现的?
(存放在自身结构体<code>FFastArraySerializer</code>中)</p></li>
<li><p>UnmapedGUID, FastArray怎么实现的?
(存放在<code>FFastArraySerializer.GuidReferencesMap</code>中)</p></li>
<li><p>FastArray第一次同步和谁对比, 是全量同步吗?(和Archetype对比,
根据Changelist同步)</p></li>
</ol>
<h1 id="关键变量">关键变量</h1>
<h2 id="ffastarrayserializer">FFastArraySerializer</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230817160941280.png" /></p>
<h3 id="itemmap">ItemMap</h3>
<p>存储<code>Item.ReplicationID</code>到<code>FastArray数组中的Index</code>的映射关系.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Maps Element ReplicationID to Array Index.*/</span></span><br><span class="line">TMap&lt;int32, int32&gt; ItemMap;</span><br></pre></td></tr></table></figure>
<h3 id="idcounter">IDCounter</h3>
<p>IDCounter初始化为0, 每次有Item初始化(新Item)时候自增,
该变量用于Item.ReplicationID初始化.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Counter used to assign IDs to new elements. */</span></span><br><span class="line">int32 IDCounter;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230817161027755.png" /></p>
<h2 id="ffastarrayserializeritem">FFastArraySerializerItem</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230817160405050.png" /></p>
<h3 id="replicationid">ReplicationID</h3>
<p>唯一标志Item的ID, 一旦赋值, 终生不变. 一般用做Key, 查询该Item.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(NotReplicated)</span><br><span class="line">int32 ReplicationID;</span><br></pre></td></tr></table></figure>
<h3 id="replicationkey">ReplicationKey</h3>
<p>每次Item修改都会+1. 用于对比Item是否发生变化.</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">UPROPERTY(NotReplicated)</span></span><br><span class="line"><span class="built_in">int32</span> ReplicationKey;</span><br></pre></td></tr></table></figure>
<h3
id="mostrecentarrayreplicationkey">MostRecentArrayReplicationKey</h3>
<p>只在客户端使用, 用于记录最近更新时候的FastArrayReplicationKey.
用于Replay时候, 剔除不正确的数据.</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">UPROPERTY(NotReplicated)</span></span><br><span class="line"><span class="built_in">int32</span> MostRecentArrayReplicationKey;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230901103236701.png" /></p>
<h2 id="fnetfasttarraybasestate">FNetFastTArrayBaseState</h2>
<p>存放在FSendingRepState.RecentCustomDeltaState中,
用于存储历史数据.</p>
<h3 id="idtoclmap">IDToCLMap</h3>
<p>一个Map,
存储<code>element's ReplicationID</code>到<code>ReplicationKey</code>的映射.
该数据时历史数据, 用于和当前数据进行对比, 进而只发送dirty数据.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Maps an element&#x27;s Replication ID to Index. */</span></span><br><span class="line">TMap&lt;int32, int32&gt; IDToCLMap;</span><br></pre></td></tr></table></figure>
<h3 id="arrayreplicationkey">ArrayReplicationKey</h3>
<p>历史的ArrayReplicationKey数据. 如果ArrayReplicationKey没有发生变化,
则不需要重建.</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int32 ArrayReplicationKey<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230817171359598.png" /></p>
<p>不需要重建, 则直接返回.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230817171447065.png" /></p>
<p>如果需要重建, 则直接创建新的, 并重新赋值.
相关函数:<code>FFastArraySerializer.FastArrayDeltaSerialize_DeltaSerializeStructs</code></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230817172036683.png" /></p>
<h2
id="ffastarrayserializerheader.basereplicationkey">FFastArraySerializerHeader.BaseReplicationKey</h2>
<p>赋值. 在序列化FastArray数据的时候,
将<code>OldState</code>的<code>ArrayReplicationKey</code>写入<code>DeltaHeader</code>的<code>BaseReplicationKey</code>中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904092544905.png" /></p>
<p>在序列化<code>DeltaHeader</code>时,
将<code>BaseReplicationKey</code>序列化到Bunch中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904092251768.png" /></p>
<p>客户端在解析<code>DeltaHeader</code>时,
将<code>BaseReplicationKey</code>解析出来.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904092336722.png" /></p>
<p><span style="color:red;"><strong>总结:
<code>BaseReplicationKey</code>是<code>OldState</code>的<code>ArrayReplicationKey</code>,
和<code>DeltaHeader.ArrayReplicationKey</code>联合起来表示当前比较的范围:<span
class="math inline">\([BaseReplicationKey,
ArrayReplicationKey]\)</span>.
BaseReplicationKey是用来处理Replay的.</strong> </span></p>
<p>目前只有处理Replay时候用到了BaseReplicationKey.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905110148582.png" /></p>
<h1 id="ds处理fastarray">DS处理FastArray</h1>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/CustomDeltaPropertyFlow.png" /></p>
<h2 id="fastarray-layout">FastArray Layout</h2>
<p>ParentCmd存储顶层数据结构,
在此处为<code>FExampleFastArray</code>成员变量,
<code>FRepLayoutCmd</code>存储ParentCmd展开后的属性.
而Handle存储了数组对象展开后成员的<code>FRepLayoutCmd</code>索引值.
序列化时只序列化RelativeHandle,
客户端根据RelativeHandle就可以知道当前消息处理的是哪个成员.</p>
<p>下图中,
Cmd可以根据<code>RelativeHandle</code>定位到<code>FHandleToCmdIndex数组</code>中的Item,
<code>FHandleToCmdIndex数组</code>可以通过Item中的<code>CmdIndex</code>定位到对应的Cmd.
<code>FRepLayoutCmd.RelativeHandle</code>和<code>FHandleToCmdIndex.CmdIndex</code>是他们二者相互查找的方式.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230901104719738.png"
alt="image-20230901104719738" />
<figcaption aria-hidden="true">image-20230901104719738</figcaption>
</figure>
<p>Parent结构:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230819145629344.png" /></p>
<p>Cmd结构:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230819145830221.png" /></p>
<p>RelativeHandle:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230819150029059.png" /></p>
<h3 id="fastarray-layout的构建">FastArray Layout的构建</h3>
<p>在初始化Replayout(FRepLayout.InitFromClass),会创建属性的描述类型:
<code>FRepParentCmd</code>和<code>FRepLayoutCmd</code>.</p>
<p>针对IsCustomDelta类型,在遍历<code>UClass.ClassReps</code>时,
将其<code>FRepParentCmd.Flags</code>设置为<code>IsStructProperty|IsCustomDelta|IsFastArray</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230815161149063.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230815160639716.png" /></p>
<p>此时, FastArray的FRepParentCmd.Flags为</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230815160722915.png" /></p>
<p>针对LifetimeProps,
还要附加<code>ERepParentFlags::IsLifetime</code>属性,
但是要排除<code>ERepParentFlags::IsCustomDelta</code>类型. 所以, <span
style="color:red;">FastArray的<code>FRepParentCmd.Flags</code>并不包含<code>ERepParentFlags::IsLifetime</code></span>,
这样后续对于<code>IsCustomDelta</code>类型, 不进行Compare.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230815161252153.png" /></p>
<h2
id="特殊处理isfastarray类型">特殊处理<code>IsFastArray</code>类型</h2>
<p>特殊的, 针对<code>IsFastArray</code>类型,
要将其放入<code>FRepLayout.LifetimeCustomPropertyState</code>中.
一定是<code>IsCustomDelta</code>中的<code>IsCustomDelta</code>类型.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230815162039997.png" /></p>
<p><strong>不进行Compare</strong></p>
<p>在<code>FNetSerializeCB::UpdateChangelistMgr</code>和<code>FRepLayout.ReplicateProperties</code>执行时时会过滤掉<code>IsCustomDelta</code>类型,
因为
<code>IsCustomDelta</code>类型的<code>FRepParentCmd.Flags</code>不包含<code>ERepParentFlags::IsLifetime</code>,
不会进入比较函数,
进而比较结果ChangedList中不会包含<code>CustomDeltaProperty</code>,
所以<code>CustomDeltaProperty</code>不会在<code>FRepLayout.ReplicateProperties</code>中被序列化.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230815155143872.png"
alt="image-20230815155143872" />
<figcaption aria-hidden="true">image-20230815155143872</figcaption>
</figure>
<h2
id="预先处理customdeltaproperty-changelist">预先处理CustomDeltaProperty
ChangeList</h2>
<p>保证提取一个可用的HistoryItem, 供这次修改使用.
从下图可以看出<code>FRepLayout::PreSendCustomDeltaProperties</code>主要是处理<code>FastArray</code>中的<code>HistoryItemList</code>,
如果没有可用的<code>HistoryItem</code>,
则将<code>EndItem</code>强制<code>Reset</code>, 用于填充此次比较的结果.
注意, 该行为是每帧最多执行一次, 即所有Connection共用一个HistoryList.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230901114618904.png" /></p>
<h2
id="处理所有customdeltaproperty">处理所有<code>CustomDeltaProperty</code></h2>
<p>遍历所有<code>CustomDeltaProperty</code>, 依次进行处理.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230815163839963.png" /></p>
<p><strong>RecentCustomDeltaState</strong>:使用<code>RecentCustomDeltaState</code>作为OldState,
与新创建的NewState进行比较.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230901115040299.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905214601917.png" /></p>
<h3 id="清理retirementlist">清理<code>RetirementList</code></h3>
<p>根据LastAckPacketID, 删除已经无用的<code>RetirementItem</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230901115245653.png" /></p>
<h3
id="自定义实现比较并获得changedelements">自定义实现比较并获得ChangedElements</h3>
<h4 id="关键数据idtoclmap">关键数据IDToCLMap</h4>
<p>IDToCLMap: ReplicationID到数组中ReplicationKey的映射.
在数组发生变化时候, 进行重建, 并且根据Old和New的IDToCLMap比较,
得出删除的数据. <span
style="color:red;">如果数组中Item只是位置发生了变化无任何影响. </span></p>
<p>每个需要<code>Replication</code>的<code>UObject</code>都有一个<code>FObjectReplicator</code>与之相对应.
每个<code>Connection</code>都有一份<code>RetirementList</code>.
<code>RetirementItem</code>中就包括<code>IDToCLMap</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/HistoryListArchitecture-1693985095439-16.png" /></p>
<p>NewState是每次比较时候, 新创建的:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230821162654878.png" /></p>
<p>等到数据比较完成之后, 将旧数据放入了FSendingRepState.Retirement中, ,
新数据变成旧数据,
放入ReplicateCustomDeltaProperties.UsingCustomDeltaStates中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230821164004265.png" /></p>
<h4
id="填充newstate的idtoclmap-对比replicationkey-填充changedelementlist">填充NewState的IDToCLMap,
对比ReplicationKey, 填充changedElementList</h4>
<p>在处理FastArray的属性同步时, 如果数组内容发生变化, 会重建IDToCLMap.
并对比ReplicationKey, 填充ChangedList</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230821200155740.png" /></p>
<h4
id="计算changeditems和deleteditems">计算ChangedItems和DeletedItems</h4>
<p>根据<code>ReplicationID</code>将新旧<code>IDToCLMap</code>进行对比,
计算已经删除Item. 注意, 这里只是根据ReplicationID进行比较,
并没有根据数组的位置比较.
而且是旧的<code>IDToCLMap</code>中存在某个<code>ReplicationID</code>,但是新的中没有,
就代表删除.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230821151944608.png" /></p>
<h3 id="核心计算changedlist">核心:计算ChangedList</h3>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904220130324.png" /></p>
<h4 id="构建shadow">构建Shadow</h4>
<p><strong>背景知识:
C++可以通过对象地址+Offset唯一确定某个对象的成员变量, 取址后,
可以根据该地址直接对该成员进行操作. UE使用该特性,
对Property进行各种直接操作.</strong></p>
<p>初始化<code>FastArray</code>对应的<code>FLifetimeCustomDeltaProperty</code>,
并存放在<code>FRepLayout.LifetimeCustomPropertyState</code>中.
其中关键变量为:<code>FastArrayArrayReplicationKeyName</code>和<code>FastArrayItemReplicationIDName</code>的<code>Offset</code>,
为后续查询做准备.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904211937206.png" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904212225203.png"
alt="结构引用图" />
<figcaption aria-hidden="true">结构引用图</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904202334312.png"
alt="VS中内存分布" />
<figcaption aria-hidden="true">VS中内存分布</figcaption>
</figure>
<p>通过对象指针+成员偏移, 找到对应的成员地址,
在通过成员对象提取出其存储数据的起始地址.
这块地址为存放着连续Item的数组.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904212831009.png" /></p>
<p>可以通过<code>TScriptArray.Insert</code>探究出其内存分布.
即所有Item存储在一块连续内存中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904213312499.png" /></p>
<p>Shadow变更流程: 首先将Shadow中数据调整成和当前ItemArray数组一致,
即shadow中Index位置存储的ReplicationID要和当前Item数组中Index位置的ReplicationID一致.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904214423464.png" /></p>
<p>然后, 如果Shadow数组大小小于ObjectArrayNumber, 要扩充Shadow数组大小.
并且如果需要扩充shadow, 则需要将Shadow中扩充的部分填充好ReplicationID,
并全部设置为New.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904214916457.png"
alt="image-20230904214916457" />
<figcaption aria-hidden="true">image-20230904214916457</figcaption>
</figure>
<p>经过上述调整, 最终ShadowArray和ObjectArray大小一致,
并且Index位置所对应Item的ReplicationID都是一样的.</p>
<h4
id="计算出这一帧和上一帧的changelist">计算出这一帧和上一帧的ChangeList</h4>
<p>构建完成Shadow, 就可以用它和ObjectArray进行比较了, 并且在比较的同时,
会将Shadow值更到最新. <strong>而且会得出ChangeList.</strong></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904215354796.png" /></p>
<h4 id="合并历史需要resend数据">合并历史需要Resend数据</h4>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904215559014.png" /></p>
<h4 id="如果changelist为空-重发所有数据">如果ChangeList为空,
重发所有数据</h4>
<p>这种情况发生在超高丢包率情况下, 64个ChangeList已经不够用了,
导致该帧比较结果+历史比较结果已经不能正确表示真是的修改值.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904215629575.png" /></p>
<h3 id="发送数据">发送数据</h3>
<p>根据收集到的ChangeList发数据, 并且结尾添加结束符:0.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904215943556.png" /></p>
<h2 id="ds填充消息">DS填充消息</h2>
<h3 id="消息结构图">消息结构图</h3>
<ol type="1">
<li><p><code>Bunch=BunchHeader+BunchBody</code>,
<code>BunchHeader</code>唯一确定该<code>Bunch</code>处理的对象是哪个<code>Actor</code>.</p></li>
<li><p><code>BunchBody=ContentBlockHeader+ContentBlockBody</code>,
<code>ContentBlockHeader</code>:唯一确定当前处理的是哪个<code>UObject</code></p></li>
<li><p><code>ContentBlockBody=FieldHeader+FieldBody</code>,
<code>FieldHeader</code>唯一标识当前要处理的是哪个<code>Property</code>.</p></li>
<li><p><code>FieldBody=FastArrayHeader+FastArrayBody</code>,
<code>FastArrayHeader</code>有当前<code>FastArray</code>的信息,
比如修改的梳理, FastArrayReplicationID,
删除元素的ReplicationID列表等.</p></li>
<li><p><code>FastArrayBody</code>是由一个list组成,
<code>ListItem=ReplicationID+bDirty+Item详细内容</code>.</p></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904103159640.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/FastArrayMsgArchitecture-1693793883814-6.png" /></p>
<h3 id="填充deltaheader">填充DeltaHeader</h3>
<p>遍历当前所有Item,
填充<code>NewState.IDToCLMap</code>(ReplicationID2ReplicationKey),
然后将<code>NewState</code>和<code>OldState</code>中的<code>IDToCLMap</code>进行比较,
统计DeletedIndices(<strong>已删除Item的ReplicationID</strong>),
<code>NumChanged</code>(变化的Item),
记录<code>BaseReplicationKey</code>(<code>OldState.ArrayReplicationKey</code>)和<code>ArrayReplicationKey</code>(<code>NewState.ArrayReplicationKey</code>).</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904111805357.png" /></p>
<p>序列化Header信息</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230904112009536.png" /></p>
<h3 id="序列化需要发送的数据">序列化需要发送的数据</h3>
<p>数据格式:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905093705264.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905093818819.png" /></p>
<h2 id="添加和修改">添加和修改</h2>
<p>默认流程是支持增加和修改的, 上述流程已经说的很详细了,
这里不再赘述.</p>
<h2 id="删除">删除</h2>
<p><strong>DS上构建删除元素(ReplicationIDList),
序列化到<code>FastArrayHeader</code>中, 发送到客户端.</strong></p>
<p>逻辑上DS删除元素是直接删除的,
在<code>TickFlush</code>-<code>SerializeDeltaCustomData</code>期间,
会根据<code>OldState(RecentCustomDelta)</code>和NewState
<code>ReplicationID-ReplicationKey</code>的比较结果,
得出DS上删除的元素的<code>ReplicationID</code>. 将ID序列化到Header中,
然后发送的客户端.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831201801056.png" /></p>
<p><strong>客户端解析收到的<code>FastArrayHeader</code>,
找到<code>ReplicationID</code>对应的Index, 然后删除之.</strong></p>
<p>在客户端,
反序列化<code>FastArrayHeader</code>得到删除的ReplicationID,
根据ReplicationID找到对应的Index,</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831202232817.png" /></p>
<p>删除前回调:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831204759315.png" /></p>
<p>客户端真正触发删除操作:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831204825582.png" /></p>
<h1 id="客户端处理fastarray">客户端处理FastArray</h1>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905110421239.png" /></p>
<table>
<tr>
<td bgcolor="#D5E8D4">
<p style="line-height:1.5;">
// 客户端在RecvBunch时,调用NetDeltaSerialize调用堆栈 <br>
--UIpNetDriver.TickDispatch() <br> |--UNetConnection.ReceivedRawPacket()
<br> | |--UNetConnection.ReceivedPacket() <br> | |
|--UChannel.ReceivedRawBunch <br> | | | |--UChannel.ReceivedNextBunch
<br> | | | | |--UChannel.ReceivedSequencedBunch <br> | | | | |
|--UActorChannel.ReceivedBunch <br> | | | | | |
|--UActorChannel.ProcessBunch <br> | | | | | | |
|--FObjectReplicator.ReceivedBunch <br> | | | | | | | |
|--FNetSerializeCB.ReceiveCustomDeltaProperty <br> | | | | | | | | |
|--FRepLayout.ReceiveCustomDeltaProperty <br> | | | | | | | | | |
|--<span style="color:red;">// 执行NetDeltaSerialize函数, 注意,
这里是被动调的, 无感知的. 即:
Recv时无感知调用NetDeltaSerialize函数.</span> <br> | | | | | | | | | |
|--<span style="color:red;">CppStructOps-&gt;NetDeltaSerialize(Params,
Params.Data)</span><br> | | | | | | | | | | | |--<span
style="color:red;">FFastArraySerializer.FastArrayDeltaSerialize</span>
<br> | | | | | | | | | | | |
|--FFastArraySerializer.FastArrayDeltaSerialize_DeltaSerializeStructs
<br> | | | | | | | | | | | | |
|--FFastArraySerializer.TFastArraySerializeHelper&lt;Type,
SerializerType&gt;.ReadDeltaHeader<br> | | | | | | | | | | | | |
|--Parms.NetSerializeCB-&gt;NetDeltaSerializeForFastArray(DeltaSerializeParams)<br>
| | | | | | | | | | | | | |
|--FRepLayout.DeltaSerializeFastArrayProperty()<br> | | | | | | | | | |
| | | | | |-- // 解析DS发来的Properties的数据 | | | | | | | | | | | | |
|--Helper.template PostReceiveCleanup() <br> | | | | | | | | | | | | | |
|--// for all deleted items <br> | | | | | | | | | | | | | |
|--FFastArraySerializerItem.PreReplicatedRemove() <br> | | | | | | | | |
| | | | | |--FFastArraySerializer.PreReplicatedRemove() <br> | | | | | |
| | | | | | | | |--// for all added items <br> | | | | | | | | | | | | |
| |--FFastArraySerializerItem.PostReplicatedAdd() <br> | | | | | | | | |
| | | | | |--FFastArraySerializer.PostReplicatedAdd() <br> | | | | | | |
| | | | | | | |--// for all changed items <br> | | | | | | | | | | | | |
| |--FFastArraySerializerItem.PostReplicatedChange() <br> | | | | | | |
| | | | | | | |--FFastArraySerializer.PostReplicatedChange() <br> | | |
| | | | | | | | | | | |--<span style="color:red;">//
调用RemoveAtSwap删除DeletedItems.
注意:经过此操作后不能保证顺序一致</span> <br> | | | | | | | | | |
|--<span style="color:red;">//
将Property添加到RepNotifyQueue中</span><br> | | | | | | | | | |
|--UE4_RepLayout_Private.QueueRepNotifyForCustomDeltaProperty<br> | | |
| | | | | | | | |--<span style="color:red;">//
将Property添加到RepNotifies中</span><br> | | | | | | | | | | |
|--ReceivingRepState-&gt;RepNotifies.AddUnique(Property);<br> | | | | |
| | |--<span style="color:red;">// 遍历所有Replicator,
执行PostReceivedBunch, 其中就包括OnRep函数</span> <br> | | | | | | |
|--for (auto RepComp = ReplicationMap.CreateIterator(); RepComp;
++RepComp)<br> | | | | | | | |--<span style="color:red;">
ObjectReplicator-&gt;PostReceivedBunch()</span><br> | | | | | | | |
|--<span style="color:red;">// !bIsServer &amp;&amp;
bHasReplicatedProperties:客户端并且有ReplicatedProerties才会执行FObjectReplicator.PostNetReceive
</span><br> | | | | | | | | |--FObjectReplicator.PostNetReceive() <br> |
| | | | | | | | |--<span
style="color:red;">Object-&gt;PostNetReceive();</span><br> | | | | | | |
| |--<span style="color:red;">FObjectReplicator::CallRepNotifies</span>
<br> | | | | | | | | | |--FReceivingRepState* ReceivingRepState =
RepState-&gt;GetReceivingRepState();<br> | | | | | | | | |
|--RepLayout-&gt;CallRepNotifies(ReceivingRepState, Object);<br> | | | |
| | | | | | |--Object-&gt;ProcessEvent(RepNotifyFunc, nullptr);<br> | |
| | | | | | | | | |--AActor.ProcessEvent<br> | | | | | | | | | | | |
|--UObject.ProcessEvent<br> | | | | | | | | | | | | |
|--UFunction.Invoke<br> | | | | | | | | | | | | | | |--<span
style="color:red;">ABasePlayerController.OnRep_ExampleFastArray </span>
<br>
</p>
</td>
</tr>
</table>
<h2 id="解析deltaheader">解析DeltaHeader</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905105917803.png" /></p>
<h2 id="解析changeditem">解析ChangedItem</h2>
<p>先解析出ReplicationID:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905110610147.png" /></p>
<p>解析是否有数据修改:bDirty, 如果有数据修改,
则开始递归解析该Item的属性.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905110711659.png" /></p>
<h2 id="postreceivecleanup回调处理">PostReceiveCleanup回调处理</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905120138880.png" /></p>
<p>删除之前, 回调PreRemove函数:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905120217945.png" /></p>
<p>添加之后, 回调PostAdd函数:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905120304973.png" /></p>
<p>修改之后, 调用PostChanged函数:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905120346014.png" /></p>
<p>执行删除操作:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905120413399.png" /></p>
<h1 id="客户端更新guid">客户端更新GUID</h1>
<p>DS不需要更新GUID, 因为DS都赋值者,
所有UObject对应的GUID都是在DS上赋值(Replication/RPC的时候注册到FNetGUIDCache中).
这种情况只可能发生在客户端. 客户端需要更新的原因:
客户端处理消息是有先后顺序的, 有的时候某些对象在序列化GUID的时候,
对应的UObject(Actor)还没有创建出来, 就无法找到对应UObject(Actor),
所以需要对于UmmapedGUID进行延迟绑定.</p>
<p><strong>这里需要关注两个变量:
<code>FReceivePropertiesSharedParams.bOutHasUnmapped</code>和<code>FReceivePropertiesSharedParams.bOutGuidsChanged</code>.</strong></p>
<p>在处理收到的属性消息时, 如果返回值为true,
则表示具有Unmaped的GUID.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905172307975.png" /></p>
<p>进一步深究发现,
在<code>ReceivePropertyHelper</code>序列化属性时会传入<code>PackageMap</code>,
如果发现有Umapped的GUID就会将其放入<code>UPackageMap.TrackedUnmappedNetGuids</code>中,
然后根据<code>TrackedUnmappedGuids</code>数量来确定是否有UmappedGUID(<code>TrackedUnmappedGuids</code>数量大约0).</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905172955366.png" /></p>
<p>并且在处理结果中, 我们还看到, 在这份代码中还有比较,
如果发现与之前的有不同, 则将<code>bOutGuidsChanged</code>设置为true.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905184838514.png" /></p>
<p>在FastArray反序列化(<code>FRepLayout.DeltaSerializeFastArrayProperty</code>)完成之后,
会将<code>bOutGuidsChanged</code>和<code>bOutHasUnmapped</code>合并到<code>FNetDeltaSerializeInfo.bGuidListsChanged</code>和<code>FNetDeltaSerializeInfo.bOutHasMoreUnmapped</code>中.
因为有其他模块也有可能含有Unmapped和Changed数据, 所以需要合并.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905191551916.png" /></p>
<p>FastArray反序列化,
会将计算得到的<code>bOutHasUnmapped</code>和<code>bOutGuidsChanged</code>传递出来.
如果<code>bOutGuidsChanged</code>为true,
则会调用<code>FObjectReplicator.UpdateGuidToReplicatorMap</code>,
即调用<code>INetSerializeCB.GatherGuidReferencesForFastArray</code>函数.
当<code>bOutHasUnmapped</code>为true, 则最终会将</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905192229648.png" /></p>
<p>将<code>bHasUnmapped</code>信息传递出来,
如果<code>bHasUnmapped</code>为true,
则会将其放入<code>UNetDriver.UnmappedReplicators</code>中,
等待<code>TickFlush</code>时候调用.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905192716712.png" /></p>
<h2
id="反序列化gatherguidreferencesupdateunmappedobjects流程">反序列化+GatherGuidReferences+UpdateUnmappedObjects流程</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905213036141.png" /></p>
<p>客户端会先执行反序列化, 然后会得出bHasUnmappedGUID和bChangedGUID.
如果bChangedGUID为true, 则进行Gather流程, 即重新收集GUID.
如果bHasUnmappedGUID为true, 则进行UpdateUnmappedObject流程,
即尝试重新将GUID映射到对应的Object上.</p>
<table>
<tr>
<td bgcolor="#D5E8D4">
<p style="line-height:1.5;">
// FastArray GatherGuidReferences+反序列化+UpdateUnmappedObjects流程
<br> --UIpNetDriver.TickDispatch <br>
|--UNetConnection.ReceivedRawPacket <br> |
|--UNetConnection.ReceivedPacket <br> | | |--UChannel.ReceivedRawBunch
<br> | | | |--UChannel.ReceivedNextBunch <br> | | | |
|--UChannel.ReceivedSequencedBunch <br> | | | | |
|--UActorChannel.ReceivedBunch <br> | | | | | |
|--UActorChannel.ProcessBunch <br> | | | | | | |
|--FObjectReplicator.ReceivedBunch <br> | | | | | | | |
|--FNetSerializeCB.ReceiveCustomDeltaProperty() <br> | | | | | | | | |
|--FNetSerializeCB.ReceiveCustomDeltaProperty() <br> | | | | | | | | | |
|--FRepLayout.ReceiveCustomDeltaProperty() <br> | | | | | | | | | | |
|--<span
style="color:red;">FFastArraySerializer.FastArrayDeltaSerialize()</span>
<br> | | | | | | | | | | | |
|--FFastArraySerializer.FastArrayDeltaSerialize_DeltaSerializeStructs()
<br> | | | | | | | | | | | | |
|--FNetSerializeCB.NetDeltaSerializeForFastArray <br> | | | | | | | | |
| | | | | |--FRepLayout.DeltaSerializeFastArrayProperty <br> | | | | | |
| | | | | | | | | |--//
根据ReplicationID,向GuidReferencesMap_StructDelta中添加元素 <br> | | | |
| | | | | | | | | | | |--FGuidReferencesMap&amp; GuidReferences =
ArraySerializer.GuidReferencesMap_StructDelta.FindOrAdd(ID); <br> | | |
| | | | | | | | | | | | |--ReceiveProperties_r() <br> | | | | | | | | |
| | | | | | | |--ReceivePropertyHelper() <br> | | | | | | | | | | | | |
| | | | |--//在反序列化Item时候,
会将UnmappedGUID放入UPackageMap.TrackedUnmappedNetGuids中. <br> | | | |
| | | | | | | | | | | | | |--Cmd.Property-&gt;NetSerializeItem(); <br> |
| | | | | | | | | | | | | | | | |--//
如果TrackedUnmappedNetGuids中不为空, 则证明有UnmappedGUID,
会将bHasUnmapped设置为true <br> | | | | | | | | | | | | | | | | | |--//
如果新旧UnmappedGUID(FGuidReferences.UnmappedGUIDs和TrackedUnmappedGuids)不一致,则证明GUID发生了变化,会将bOutGuidsChanged设置为true
<br> | | | | | | | | | | | | | | | | |--//
如果ReceivePropertyHelper的返回值为true,
会将Params.bOutHasUnmapped设置为true,证明有Unmapped的数据 <br> | | | | |
| | | | | | | | | | | |--Params.bOutHasUnmapped = true; <br> | | | | | |
| | | | | |
|--FFastArraySerializer.TFastArraySerializeHelper.PostReceiveCleanup()
<br> | | | | | | | | |--if (Parms.bOutHasMoreUnmapped) <br> | | | | | |
| | |--{ <br> | | | | | | | | |-- bOutHasUnmapped = true; <br> | | | | |
| | | |--} <br> | | | | | | | | |-- <br> | | | | | | | | |--if
(Parms.bGuidListsChanged) <br> | | | | | | | | |--{ <br> | | | | | | | |
|-- bGuidsChanged = true; <br> | | | | | | | | |--} <br> | | | | | | | |
|---<span
style="color:red;">//如果bGuidsChanged为true,则将执行FObjectReplicator.UpdateGuidToReplicatorMap
</span><br> | | | | | | | | |--<span
style="color:red;">FObjectReplicator.UpdateGuidToReplicatorMap() </span>
<br> | | | | | | | | | |--<span
style="color:#f400a1;">FRepLayout.GatherGuidReferences</span> <br> | | |
| | | | | | | |--FFastArraySerializer.FastArrayDeltaSerialize <br> | | |
| | | | | | | |
|--FFastArraySerializer.FastArrayDeltaSerialize_DeltaSerializeStructs
<br> | | | | | | | | | | | |
|--FNetSerializeCB.GatherGuidReferencesForFastArray <br> | | | | | | | |
| | | | | |--FRepLayout.GatherGuidReferencesForFastArray <br> | | | | |
| | | | | | | | | |--//
将FFastArraySerializer.GuidReferencesMap_StructDelta中的信息放入FFastArraySerializer.GuidReferencesMap中
<br> | | | | | | | | | | | | | | |--FRepLayout.GatherGuidReferences_r()
<br> | | | | | | | |--//
如果bHasUnmapped为true,会将Replicator放入UnmappedReplicators中 <br> | |
| | | | | |--<span
style="color:Maroon;">Connection-&gt;Driver-&gt;UnmappedReplicators.Add(&amp;Replicator.Get());</span>
<br> |--//
遍历AllReplicators,如果为UnmappedReplicators,则UpdateUnmappedObjects
<br> |--<span
style="color:#f400a1;">FObjectReplicator.UpdateUnmappedObjects()</span>
<br> | |--FRepLayout.UpdateUnmappedObjects <br> | |
|--ReceiveProperties_r.FRepLayout.UpdateUnmappedObjects <br> | | |
|--FFastArraySerializer.FastArrayDeltaSerialize_DeltaSerializeStructs
<br> | | | | |--INetSerializeCB.UpdateUnmappedGuidsForFastArray <br> | |
| | | |--FRepLayout.UpdateUnmappedGuidsForFastArray <br> | | | | | |
|--//
遍历所有ArraySerializer.GuidReferencesMap_StructDelta,执行UpdateUnmappedObjects_r操作
<br> | | | | | | |--FRepLayout.UpdateUnmappedObjects_r() <br> | | | | |
| | |-- // 遍历所有UnmappedGUID进行查询, 如果找到了对应Object,进行序列化
<br> | | | | | | | |--Cmd.Property-&gt;NetSerializeItem(Reader,
PackageMap, Data + AbsOffset); <br> | | | | | | | |-- //
如果还有UnmappedGUID, 会将<span
style="color:Olive;">bOutHasMoreUnmapped</span>设置成true <br> |
|--FObjectReplicator.PostNetReceive <br> |
|--FObjectReplicator.UpdateGuidToReplicatorMap() <br> |
|--FObjectReplicator.CallRepNotifies <br> | |
|--FRepLayout.CallRepNotifies() <br> | | |
|--遍历所有FReceivingRepState.RepNotifies,回调其对应的UFunction <br>
|--if ( !<span style="color:Olive;">bHasMoreUnmapped</span> ) <br> |--{
<br> |-- <span style="color:Maroon;">UnmappedReplicators.Remove(
Replicator ); </span> <br> |--} <br>
</p>
</td>
</tr>
</table>
<h2 id="moveguidtounmapped流程">MoveGuidToUnmapped流程</h2>
<p>当ActorChannel销毁时候, 触发MoveGuidToUnmapped.</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// FastArray MoveGuidToUnmapped流程</span><br><span class="line">--UIpNetDriver.TickDispatch.for</span><br><span class="line">|<span class="string">--UNetConnection.ReceivedRawPacket</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.ReceivedPacket </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedRawBunch</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedNextBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedSequencedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ConditionalCleanUp</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.CleanUp </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.DestroyActorAndComponents</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.MoveMappedObjectToUnmapped</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UNetDriver.MoveMappedObjectToUnmapped</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.MoveMappedObjectToUnmapped </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.MoveMappedObjectToUnmapped</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FFastArraySerializer.FastArrayDeltaSerialize</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FFastArraySerializer.FastArrayDeltaSerialize_DeltaSerializeStructs</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FNetSerializeCB.MoveGuidToUnmappedForFastArray </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.CreateReplicationChangelistMgr</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.MoveMappedObjectToUnmapped_r</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--GuidReferences.MappedDynamicGUIDs.Remove(GUID);</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--GuidReferences.UnmappedGUIDs.Add(GUID);</span></span><br></pre></td></tr></table></figure>
<p>从上述流程可以看出, 当一个Actor销毁时候,
会将其Actor内部所OwnedGUID所关联的对象对应的GUID,
全部从MappedGUID移动到UnmappedGUID, 而不是删除. 那什么时候删除呢?
对于DS来讲, 当发生变化时候, 会将设置成全新的,
然后将新的GUID同步到客户端. 客户端发起新的流程,
会走一遍序列化+UpdateUnmappedObjects流程.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905205822327.png" /></p>
<p>那么客户端呢? 如果一个客户端主动将一个Actor销毁,
UnmappedGUID还会清理吗? 不会了, 从堆栈中可以看出,
MoveMappedObjectToUnmapped都是通过ActorChannel调用的,
客户端销毁一个Actor, 并不会将其ActorChannel销毁, 所以,
不会触发MoveMappedObjectToUnmapped.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230905212028573.png" /></p>
<h1 id="问">问</h1>
<h2 id="fastarray相互套用怎么传输">FastArray相互套用怎么传输</h2>
<p>被嵌套的<code>FastArray</code>会被当做普通结构图进行传输,
失去了其本身FastArray对比等功能. 所以嵌套能用,
但是会被当做普通数组一样对待.</p>
<p>这里注意以下几点, 证明FastArray是不能被嵌套的.</p>
<ol type="1">
<li>在遍历所有ParentCmd时候,
针对每个<code>IsCustomDelta</code>的ParentCmd会遍历其Cmd,
在这些cmd中如果发现一个是FastArray,就会break,
导致Replayout中没有被嵌套FastArray的信息,
即其属性成员的各种Offset无法被找到. 而且, 可以注意到,
如果FastArray被其他结构嵌套,
由于其ParentCmd不是<code>IsCustomDelta</code>,
则其也不会存在FLifetimeCustomDeltaProperty结构.
即FastArray不能被嵌套.</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230906093859228.png" /></p>
<p>FLifetimeCustomDeltaProperty记录FastArray的各种属性成员的Offset,
如果没有<code>FLifetimeCustomDeltaProperty</code>, 很多操作无法执行.
比如说在<code>FRepLayout::DeltaSerializeFastArrayProperty</code>中用到的函数<code>FLifetimeCustomDeltaState.GetCustomDeltaProperty</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230906094208157.png" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230906094512029.png"
alt="image-20230906094512029" />
<figcaption aria-hidden="true">image-20230906094512029</figcaption>
</figure>
<ol start="2" type="1">
<li>FastArray的比较是自定义实现的, 如果FastArray嵌套FastArray,
那么其内容的递归比较也不支持</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230906094947644.png"
alt="调用通用比较函数" />
<figcaption aria-hidden="true">调用通用比较函数</figcaption>
</figure>
<p>但是通用比较函数没有针对FastArray进行特殊处理:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230906095054849.png" /></p>
<h2
id="如果数组中两个item位置发生变化-会传输数据吗">如果数组中两个Item位置发生变化,
会传输数据吗?</h2>
<h3 id="如果调用的时memcopy-则不会传输数据">如果调用的时Memcopy,
则不会传输数据:</h3>
<p>示例:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230821172756085.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230821172105044.png" /></p>
<p>可以清晰的看到, 在传输数据的时候, 发现其没有任何变化,
不会序列化数据.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230821173400498.png" /></p>
<h3 id="如果调用-则会">如果调用<code>=</code>, 则会</h3>
<p>由于FFastArraySerializerItem重写了操作符<code>=</code>,
在复制的时候会将ReplicationID和ReplicationKey重置, 所以相当于全新数据,
会全部同步.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230821172343849.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230821171413652.png" /></p>
<h3 id="总结">总结</h3>
<p><span style="color:red;">如果仅仅是数组位置发生变化
而Item内容没有发生任何变化, 则会不进行任何数据传输.</span>
在使用FastArray时候, 交换两个Item位置的时候, 不要使用<code>=</code>,
否则会发生无意义的数据传输. UE原生的<code>TArray.Swap</code>,
<code>TArray.RemoveAt</code>,
<code>TArray.RemoveAtSwap</code>等都不会调用<code>=</code>,
直接进行内存级别的赋值, 推荐使用.</p>
<h2
id="fastarray有使用shadedserialized吗">FastArray有使用<code>ShadedSerialized</code>吗?</h2>
<p><span style="color:red;"><strong>首先,
看一下什么是<code>ShadedSerialized</code></strong>:</span>
<code>ShadedSerialized</code>是在多个Connection之间共用一份数据,
省去其中重复执行序列化操作的时间. 同一帧之内起效果, 隔帧失效. <span
style="color:red;"><strong>其次,
看一下<code>ShadedSerialized</code>是怎么使用的</strong>:</span>
在属性比较之后, Gather出ChangedList(里面存储着RelativeHandle),
针对每个RelativeHandle, 如果该属性开启<code>ShadedSerialized</code>,
并且该帧已经序列化了, 则取出其序列化结果直接使用.</p>
<p>好了, 有了以上基础, 可以看看FastArray了. 针对FastArray,
其调用序列化并发送数据的接口为:<code>FRepLayout::SendProperties_r</code>,
观察期传入参数<code>SharedInfo</code>为空,
则一定不会有<code>ShadedSerialized</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230906110729892.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230906111001623.png" /></p>
<p>那么能不能改造成支持<code>ShadedSerialized</code>呢?</p>
<p><span style="color:red;">答案肯定是能的,
参考普通属性的<code>ShadedSerialized</code>,
在<strong>FDeltaArrayHistoryState</strong>中添加一个成员,
用于存储FastArray的数据, 从目前来看, 其要存放成一个Map成员,
ReplicationID-ShadedInfo,
即针对每个Item,都要建立一个ShadedInfo数据.</span></p>
<h2
id="fastarray每帧最多只进行一次比较吗-怎么去重的">FastArray每帧最多只进行一次比较吗?
怎么去重的?</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/HistoryListArchitecture.png" /></p>
<p><span style="color:red;">针对FastArray, 这一帧和上一帧的内容比较次数,
在一帧内, 最多只执行一次. </span></p>
<p>在<code>FRepLayout::PreSendCustomDeltaProperties</code>阶段,
会记录每次执行比较操作的帧数<code>CustomDeltaChangelistState.CompareIndex</code>,
如果该帧执行过比较, 则直接略过. 这里特殊说一下, 如果是第一次执行,
会取出一个新的HistoryItem, 重置, 然后用作这次比较.
如果HistoryList环形buffer超标了, HistoryEnd和HistoryStart重合了,
强制重置第一个HistoryStartItem, 然后将HistoryStart后延,
即强制提供一个可用的HistoryItem.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230906105452551.png" /></p>
<p>在比较过程中, 取出History数据, 如果HistoryItem执行过比较, 就直接略过.
如果是第一次, 则<code>FDeltaArrayHistoryItem.bWasUpdated</code>为false,
则进行比较并更新historyList, 否则直接跳过了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230906105629093.png" /></p>
<h2 id="fastarray第一次和谁比较">FastArray第一次和谁比较?</h2>
<p>和Archetype对比, 根据Changelist同步.</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">// FastArray RecentDeltaCustom初始化, RecentDeltaCustom每个Connection独一份</span><br><span class="line">--UNetConnection.CreateReplicatorForNewActorChannel </span><br><span class="line">|<span class="string">--FObjectReplicator.InitWithObject </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.InitRecentProperties // 注意这里传入的UObject为CDO</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 遍历所有CustomDeltaProperty, 执行SendCustomDeltaProperty, 这里会初始化FSendingRepState.RecentCustomDeltaState .</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.SendCustomDeltaProperty </span></span><br></pre></td></tr></table></figure>
<p>这样, 在创建Replicator时候, 使用CDO,
对FSendingRepState.RecentCustomDeltaState进行初始化.
所以后续对比的其实是CDO内的FastArray数据.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230907131227381.png" /></p>
<p>使用CDO初始化<code>FSendingRepState.RecentCustomDeltaState</code>数据.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230907131254116.png" /></p>
<h1 id="总结-1">总结</h1>
<h2 id="fastarray快在哪里">FastArray快在哪里</h2>
<p>快在Array中间一个元素发生变化, 不会影响其他元素.
而TArray会重传变动后面的所有数据. 因为TArray是按照位置进行比较的,
而FastArray是按照ReplicationID进行比较的.</p>
<h2 id="fastarray本身有哪些问题">FastArray本身有哪些问题</h2>
<ol type="1">
<li>如果大量连续丢包, 并超过64(HistoryList环形buffer大小),
则传输的数据只能保证最终数据一致, 而不能保证过程中,
某些数据的顺序.例如FastArray中只有Item1和Item2两个元素, 当遇到连续丢包,
并且已经超过了64(HistoryList环形buffer大小), 那么在比较过程中,
就不会从HistoryList中获取数据, 只发送本帧修改的数据,
这样会导致一段时间内只能收到当帧修改的数据. 只有当帧没有数据变化,
才会触发ChangedItem全部发送的逻辑, 即保证最后数据的正确性.</li>
<li>没有使用<code>ShadedSerialized</code>, 当Connection较多时候,
大量使用FastArray会造成性能问题.</li>
<li>不能保证数组顺序, 例如DS数组中内容为 <code>0,1,2</code>,
同步到客户端就可能是<code>1,2,0</code>.</li>
<li>FastArray内部不支持嵌套FastArray, 如果嵌套了,
会被当做普通结构体进行同步</li>
<li>任何数据中嵌套了FastArray,
都会被当做普通结构体进行传输(可以认为是普通数据).
只有FastArray在ParentCmd层级, 才会被真正当做FastArray使用.</li>
<li>如果Item过多, 每个RelativeHandle都使用uint32进行数据传输,
那么会非常耗费. <span style="color:red;">方法1:</span>
可以考虑使用bit替换, 每个成员变量都会用一个bit表示其是否发生了变化,
如果有变化则进行序列化(参考RPC参数的发送).<span
style="color:red;">方法2:</span> 或者限制范围, 比如该结构体参数个数为5,
那么可以将RelativeHandle限制在3个bit内. <span
style="color:red;">总结:</span>还要结合项目具体情况使用,
比如某些结构体频繁改动, 并且结构体内部成员很多, 可以使用方法1.
如果某些结构体成员很多, 但内部只有少量数据变动, 但是变动很频繁,
可以使用方法2. 还可以二者结合使用, 动态方式, 比如统计之前的使用状态,
预计下次最优的使用方式.</li>
</ol>
<h2 id="注意">注意</h2>
<p>FastArray没有<code>HistoryChangedList</code>,
只有<code>RetirementList</code>,
并且它只存储<code>ReplicationID-Replicationkey</code>.</p>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>FastArray</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>FastArray</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4网络中UObject创建和销毁</title>
    <url>/2023/11/09/UE/%E7%BD%91%E7%BB%9C/UE4%E7%BD%91%E7%BB%9C%E4%B8%ADUObject%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81/</url>
    <content><![CDATA[<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/BunchArchetype.png" /></p>
<p>本文中我们专注ContentBlockPayloadHeader和DeleteObject信息.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831143414189.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831154959105.png" /></p>
<span id="more"></span>
<h1 id="问">问</h1>
<ol type="1">
<li>UObject DS怎么序列化的? (ContentBlockHeader)</li>
<li>客户端怎么创建的? (ContentBlockHeader)</li>
<li>既不序列化也不创建, 仅仅是持有指针, 怎么映射的? (GUID)</li>
<li>DS是怎么判断需要根据GUID创建, 而不是映射呢?
(ContentBlockHeader)</li>
</ol>
<h1 id="简述">简述</h1>
<p>首先我们看一下ReplicationActor的简要流程, 从下图可以看出,
其一个Actor进行Replication的时候分成三部分: <span
style="color:red;">Replicate自身属性+Replicate
ActorComponent属性+Replicate SubObject属性</span>.
但是最终都会调用核心函数<span
style="color:red;">FObjectReplicator::ReplicateProperties</span>对属性进行处理.
<span
style="color:red;">FObjectReplicator::ReplicateProperties</span>流程也是四部曲:<span
style="color:red;">UpdateChangeList(更新属性:这帧和上一帧对比)+UpdateChangedHistory(清理合并历史变化)+更新CustomDeltaProperty(FastArray类型)+合并UnreliableFunction</span>.</p>
<p><span
style="color:red;">ContentBlockHeader:</span>但是我们今天要讲的不是这些,
而是<code>ContentBlockHeader</code>. 它又是何方神圣呢?
先思考一个问题:如果标志当前修改的属性归属于哪个UObject?
只有知道当前要修改哪个UObject, 然后根据属性信息找到对应的属性,
即可做出修改处理.
ContentBlockHeader就是做UObject定位的.它能唯一标识当前针对哪个UObject进行修改.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831151548900.png" /></p>
<h1 id="ds序列化">DS序列化</h1>
<p>每个需要<code>Replication</code>的<code>UObject</code>都会有一个对应的<code>FObjectReplicator</code>,
在UObject的属性序列化完成之后, 在添加ContentBlockHeader,
将这些属性做归属, 即属于哪个UObject的修改.</p>
<h2 id="contentblockheader信息序列化">ContentBlockHeader信息序列化</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831153429969.png" /></p>
<p>这里还要特殊说明一下,
<code>IsNameStableForNetworking</code>表明客户端是否可以进行创建,
如果为<code>DefaultSubComponent</code>或者其他的默认就会创建的,
该属性为1, 表明不允许客户端创建, 只能查询绑定.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831153548911.png"
alt="填充流程" />
<figcaption aria-hidden="true">填充流程</figcaption>
</figure>
<p>具体代码解析:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831154236951.png" /></p>
<p>这里还需要注意一点是,
当第一次创建UObject对应的<code>ObjectReplicator</code>时,
还将Bunch设置为Reliable. 即该Channel第一次同步(Channel可能会反复创建,
没重新创建Channel会重新生成<code>ObjectReplicator</code>)该属性则Bunch特意设置为<code>ReliableBunch</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230901102650993.png" /></p>
<h2 id="delete信息序列化">Delete信息序列化</h2>
<p>这个很简单, 就是遍历ReplicationMap中所有成员,
针对<code>NotValid</code>的成员就视作删除, 填充Delete信息.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831154959105-1693468503105-14.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831155252543.png" /></p>
<h1 id="客户端反序列化">客户端反序列化</h1>
<p>客户端首先解析ContentBlockHeader,
然后才能确定当前修改的是哪个UObject.</p>
<h2 id="创建">创建</h2>
<p>如果SubObj为空, 则直接创建.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831154744666.png" /></p>
<p><code>bStablyNamed</code>类型只能<code>Find</code>,
不能<code>Create</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831154500539.png" /></p>
<h2 id="删除">删除</h2>
<p>在解析ContentBlockHeader时候, 发现如果ClassGUID为0, 就视作删除消息,
直接删除对应UObject.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230831155548627.png" /></p>
<h1 id="总结">总结</h1>
<ol type="1">
<li>UObject的创建和删除时通过ContentBlockHeader表示的.</li>
<li><code>ReplicationObject</code>的<code>Owner</code>需要为其<span
style="color:red;">创建, Propertie的网络同步, 以及删除</span>负责,
通过<code>ContentBlockHeader</code>实现.
其他对象则只有其GUID的使用权.</li>
<li>自定义UObject进行Replicate请参考文章:<a
href="#自定义UObject进行Replicate">自定义UObject进行Replicate</a>,
这里不再赘述.</li>
<li>如果仅仅使用GUID, 没有ContentBlockHeader, 则只负责映射, 不进行<span
style="color:red;">创建, Propertie的网络同步, 以及删除</span>.</li>
<li>网络时序引起的逻辑问题, 要用逻辑去矫正.
比如使用A的Replication先到了, 但是还没创建,
则需要逻辑去保证其正确性.</li>
<li>其实Delete消息是ContentBlockHeader的特例而已.</li>
<li>Channel第一次同步某个UObject的时候(创建<code>ObjectReplicator</code>),
会将Bunch设置为Reliable.</li>
</ol>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>UObject创建和销毁</tag>
      </tags>
  </entry>
  <entry>
    <title>UE网络-ReplicationActor</title>
    <url>/2023/11/09/UE/%E7%BD%91%E7%BB%9C/UE%E7%BD%91%E7%BB%9C-ReplicationActor/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p><code>ReplicateActor</code>分成三步:
<code>SerializeNewActor</code>+<code>序列化属性</code>+<code>序列化删除的Objs</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913110345472.png" /></p>
<p>其中序列化属性中的属性又分成三类:
<code>Actor自身属性</code>+<code>ActorComponent属性</code>+<code>SubObject属性</code>.
每类属性的序列化都会调用同一个函数:
<code>FObjectReplicator::ReplicateProperties</code>.</p>
<span id="more"></span>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913104905694.png" /></p>
<p><code>FObjectReplicator::ReplicateProperties</code>分成如下几个步骤:</p>
<ol type="1">
<li>UpdateChangelistMgr</li>
<li>MergeNotSendChangeList</li>
<li>MergeResendChangeHistory</li>
<li>CustomDeltaProperties</li>
<li>Replicate Queued (unreliable functions)</li>
<li>拼接ContentBlock</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913110941424.png" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/BunchArchetype-1694577437093-1.png"
alt="整体消息框架" />
<figcaption aria-hidden="true">整体消息框架</figcaption>
</figure>
<h1 id="整体架构">整体架构</h1>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913111721794.png" /></p>
<h2 id="serializenewactor">SerializeNewActor</h2>
<p>当该Channel第一次(<code>OpenPacketId.First</code>为空)发送数据时,
会序列化<code>SerializeNewActor</code>,
将Actor的<code>ArchetypeGUID</code>,
<code>LevelGUID</code>等信息全部进行序列化.
注意大约什么情况下是Channel第一次发送消息呢? 一般而言,
是Actor第一次创建Channel, 或者休眠恢复之后, 重建Channel,
该Channel第一次发送消息, 而不是该Actor第一次发送信息.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913140745487.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913140844477.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913140943887.png" /></p>
<h2 id="序列化属性">序列化属性</h2>
<p>下文详述.</p>
<h2 id="序列化删除objs的属性">序列化删除Objs的属性</h2>
<p>遍历该Actor下所有<code>Replicator</code>(<code>UActorChannel.ReplicationMap</code>),
检测<code>FObjectReplicator.WeakObjectPtr</code>的有效性, 如果失效了,
证明该Obj被销毁了, 需要删除, 然后将其信息记录下来, 序列化到Bunch内.
带有删除信息的<code>Bunch</code>必定是<code>Reliable</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913141813311.png" /></p>
<p>消息结构:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913141913205.png" /></p>
<h1
id="fobjectreplicator.replicateproperties"><code>FObjectReplicator.ReplicateProperties</code></h1>
<p><strong>注意,
以下流程是拼接<code>ContentBlockPayload</code></strong></p>
<p><code>FObjectReplicator::ReplicateProperties</code>分成如下几个步骤:</p>
<ol type="1">
<li>UpdateChangelistMgr</li>
<li>MergeNotSendChangeList</li>
<li>MergeResendChangeHistory</li>
<li>CustomDeltaProperties</li>
<li>Replicate Queued (unreliable functions)</li>
<li>拼接ContentBlock</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913142205079.png" /></p>
<p>最终会组建ContentBlockPayload:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913113511615.png" /></p>
<h2 id="updatechangelistmgr">UpdateChangelistMgr</h2>
<p>遍历所有<code>ParentCmd</code>,
如果<code>PushModel</code>为dirty就进行比较, 否则直接跳过.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913143514270.png" /></p>
<p>遍历<code>ParentCmd</code>对应的<code>Cmd</code>,
使用<code>PropertiesAreIdentical</code>进行比较, 如果确实发生变化,
则将<code>Handle</code>放入<code>ChangedList</code>中. <span
style="color:red;">还会将当前数据放入<code>Shadow</code>中. </span></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913143752353.png" /></p>
<p>对于数组类型, 要展开进行递归处理. 首先递归比较其数组中的每个元素:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913144539833.png" /></p>
<p>如果数组发生了变化,
会将<code>数组的Handle</code>+<code>数组数量</code>+<code>数组中变化元素的Handle</code>+<code>结束符0</code>放入<code>ChangedList</code>中</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913144615659.png" /></p>
<p>如果数组被清空了(数组大小发生了变化, 但是比较结果又是空的,
证明数组被清空了),
会将<code>数组的Handle</code>+<code>数组数量(空数组,数量为0)</code>+<code>结束符0</code>填入<code>ChangedList</code>中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913144840982.png" /></p>
<p>其中数组元素属性的对应<code>Handle</code>的计算方式为<code>ArrayIndex*PropertyNum+PropertyIndex+1</code>.
以<code>FMyTestDataItem</code>为例, 结构体内部有五个属性,
并且有一个<code>TArray&lt;FMyTestDataItem&gt; ItemList;</code>需要网络同步,
当<code>ItemList[0].DataItemBool</code>发生变化时候,
根据公式:<code>ArrayIndex*PropertyNum+PropertyIndex</code>
需要填入的<code>Handle</code>为<code>0*5+1+1=2</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FMyTestDataItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">        int32 DataItemInt = <span class="number">0</span>; <span class="comment">// PropertyIndex为0</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">        <span class="type">bool</span> DataItemBool = <span class="literal">false</span>; <span class="comment">// PropertyIndex为1</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">        FName DataItemName; <span class="comment">// PropertyIndex为2</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">        <span class="type">float</span> DataItemFloat = <span class="number">0.1</span>; <span class="comment">// PropertyIndex为3</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">        EMyTestEnum DataItemEnum = EMyTestEnum::ENone; <span class="comment">// PropertyIndex为4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下类型需要网络同步</span></span><br><span class="line">TArray&lt;FMyTestDataItem&gt; ItemList;</span><br></pre></td></tr></table></figure>
<p>实例:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913152358973.png" /></p>
<p><span style="color:red;">注意:
填入<code>ChangedList</code>中的<code>Handle</code>, 对非数组类型,
其为<code>cmd.RelativeHandle</code>, 对数组类型,
其为:<code>ArrayIndex*PropertyNum+PropertyIndex+1</code>.</span></p>
<h2 id="mergenotsendchangelist">MergeNotSendChangeList</h2>
<p>每个<code>Connection</code>的<code>Repstate</code>中会记录<code>LastChangelistIndex</code>,
每次Replication时,
会将[<code>LastChangelistIndex</code>-最新数据的ChangeIndex]合并.
并且这些数据会合并到HistoryItem中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913171802099.png" /></p>
<p>为什么会有额外未发送(除了当帧的)的Changelist呢?</p>
<p>因为所有<code>Connection</code>共用一套<code>changeList</code>,
某些<code>Actor</code>在某些情况下针对<code>ConnectionA</code>可能不会进行同步,
而其他<code>Connection</code>同步了该<code>Actor</code>,
那么共享的<code>Changelist</code>中就有<code>ConnectionA</code>没有同步的数据,
所以要将这些数据合并到待发送的<code>Changelsit</code>中.</p>
<h2 id="mergeresendchangehistory">MergeResendChangeHistory</h2>
<p>每次收到Nak的时候, 需要将HistoryList中的Item标记为Resend,
在属性同步时将其合并, 进行重发. 并且这些数据会合并到HistoryItem中.
并且将之前的ResendHistoryItem清空, 意味着责任转移, 如果当前包丢失,
只需要重传当前HistoryItem就可以了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913171751636.png" /></p>
<h2 id="buildsharedserialize">BuildSharedSerialize</h2>
<p>根据ChangedData, 将允许<code>SharedSerialize</code>的属性,
放入共享结构<code>FRepSerializationSharedInfo</code>中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913172147556.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913172730911.png" /></p>
<h2 id="customdeltaproperties">CustomDeltaProperties</h2>
<p>FastArray中有详细介绍.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913172844780.png" /></p>
<h2 id="replicate-queuedunreliable-functions">Replicate
Queued(unreliable functions)</h2>
<p>详见:<a href="/2023/11/09/UE/%E7%BD%91%E7%BB%9C/RPC%E6%B5%85%E6%9E%90/" title="RPC浅析">RPC浅析</a>中的<code>QueueBunch</code></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913172920513.png" /></p>
<h2 id="拼接contentblock">拼接ContentBlock</h2>
<p><code>ContentBlockHeader</code></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913173718682.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913173543795.png" /></p>
<h1 id="客户端解析数据">客户端解析数据</h1>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/BunchArchetype-1694609017857-8.png"
alt="BunchArchetype" />
<figcaption aria-hidden="true">BunchArchetype</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913204257268.png"
alt="解析流程" />
<figcaption aria-hidden="true">解析流程</figcaption>
</figure>
<h2 id="解析serializeactor">解析SerializeActor</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913195121972.png" /></p>
<p>当<code>Channel</code>中的<code>Actor</code>为<code>nullptr</code>,
并且<code>Bunch.bOpen</code>为true, 则重新反序列化对应的Actor.
这里反序列化是指将<code>Bunch</code>中对应数据取出,
是否重新<code>spawn</code>要看<code>Actor</code>是否真正存在,
如果不存在会<code>Spawn</code>, 否则直接引用. 一般在Dormancy时,
Channel会回收, 当<code>FlushDormancy</code>时会重新将Channel和Actor绑定,
这时候客户端就不会创建, 仅仅将消息处理掉,
并将<code>Channel</code>和<code>Actor</code>绑定.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913194237028.png" /></p>
<p>无论怎么样,
都会将Bunch中的<code>SerializeNewActor</code>数据读取出来.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913194956799.png" /></p>
<h2 id="解析contentblockheader">解析ContentBlockHeader</h2>
<p>解析ContentBlock中的数据,
<code>GUID</code>表示当前处理的是哪个<code>UObject</code>,
当UObject不存在时, 使用<code>ClassGUID</code>直接创建,
<code>bHasReplayout</code>表示<code>ContentBlockPayload</code>中是否包含属性.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913174337920.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913174103300.png" /></p>
<h2 id="解析netfieldindex">解析NetFieldIndex</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913195306126.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913195829490.png" /></p>
<h2 id="解析property">解析Property</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913195322520.png" /></p>
<p>如果<code>ContentBlock</code>中<code>bHasRepLayout</code>为true ,
则表明有属性传输, 则进行属性反序列化.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913154805986.png" /></p>
<p>首先解析<code>PropertyHandle</code>,
然后递归解析<code>Property属性</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913155122231.png" /></p>
<p>每次在函数<code>ReceiveProperties_r</code>尾部,
继续读取<code>Handle</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913155234338.png" /></p>
<p>函数<code>ReceivePropertyHelper</code>真正解析属性:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913155852011.png" /></p>
<p><strong>处理数组类型:</strong></p>
<p>数组的<code>Handle</code>从0开始.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913163826280.png" /></p>
<p>每次比较, <code>Handle</code>都会+1.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913163951903.png" /></p>
<p>最终, 如果和DS发来的<code>Handle</code>一致, 则表明是同一个Handle,
解析其后面的属性.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913164034686.png" /></p>
<h1 id="思考">思考</h1>
<h2
id="actor首次同步在进行比较时候和谁进行对比">Actor首次同步在进行比较时候和谁进行对比?</h2>
<p>该问题换一种说法是<code>ReplicationObj</code>的Shadow初始化对象是什么?</p>
<p>Actor首次同步, 在进行比较时候和谁进行对比?(UObject的CDO). 从代码上看,
是其<code>Archetype</code>, 即一般情况下就是CDO.</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">在首次ReplicationActor时, 首次并初始化`FRepChangelistState.StaticBuffer`的流程</span><br><span class="line">--UActorChannel.ReplicateActor.if </span><br><span class="line">|<span class="string">--ABasePlayerController.ReplicateSubobjects </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--AActor.ReplicateSubobjects.for.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReplicateSubobject </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.FindOrCreateReplicator</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.StartReplicating</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UNetDriver.GetReplicationChangeListMgr</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 在这里会传入ShadowStateSource, 其值为InObject-&gt;GetArchetype();, 可以理解为CDO</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.CreateReplicationChangelistMgr</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FReplicationChangelistMgr::FReplicationChangelistMgr</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepChangelistState::FRepChangelistState</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--InRepLayout-&gt;CreateShadowBuffer(InSource)</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.InitRepStateStaticBuffer()</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ShadowData.Buffer.SetNumZeroed(ShadowDataBufferSize);</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ConstructProperties(ShadowData);</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 遍历所有Parent.Property, 进行初始化</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--Parent.Property-&gt;InitializeValue(ShadowData + Parent);</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--CopyProperties(ShadowData, Source);</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 遍历所有Parent.Property, 拷贝Source数据到Shadow中</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--Parent.Property-&gt;InitializeValue(ShadowData + Parent);</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230913103248166.png" /></p>
<h2
id="为什么会mergenotsendchangelist">为什么会MergeNotSendChangeList</h2>
<p>因为所有<code>Connection</code>共用一套<code>changeList</code>,
某些<code>Actor</code>在某些情况下针对<code>ConnectionA</code>可能不会进行同步,
而其他<code>Connection</code>同步了该<code>Actor</code>,
那么共享的<code>Changelist</code>中就有<code>ConnectionA</code>没有同步的数据,
所以要将这些数据合并到待发送的<code>Changelsit</code>中.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/HistoryListArchitecture-1694596089462-3.png"
alt="HistoryListArchitecture" />
<figcaption aria-hidden="true">HistoryListArchitecture</figcaption>
</figure>
<h2
id="freplayoutcmd.relativehandle和changelist中的handle是一个吗"><code>FRepLayoutCmd.RelativeHandle</code>和<code>ChangeList</code>中的<code>Handle</code>是一个吗?</h2>
<p><span style="color:red;">不完全是.
填入<code>ChangedList</code>中的<code>Handle</code>, 对非数组类型,
其为<code>cmd.RelativeHandle</code>, 对数组类型,
其为:<code>ArrayIndex*PropertyNum+PropertyIndex+1</code>.</span></p>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>ReplicationActor</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>ReplicationActor</tag>
      </tags>
  </entry>
  <entry>
    <title>开启Replicate</title>
    <url>/2023/11/13/UE/%E7%BD%91%E7%BB%9C/%E5%BC%80%E5%90%AFReplicate/</url>
    <content><![CDATA[<h1
id="actor开启replicate"><code>Actor</code>开启<code>Replicate</code></h1>
<p>UE中, 对于需要<code>Replicate</code>的<code>Actor</code>,
需要将<code>AActor.bReplicates</code>设置为<code>true</code>.</p>
<p>方法1:
<code>SpawnActor</code>之后调用<code>AActor.SetReplicates</code>将其变成可<code>Replicate</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113170458249.png" /></p>
<p>方法2:
在构造函数中将<code>AActor.bReplicates</code>设置为<code>true</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113170547324.png" /></p>
<p><code>AActor.bReplicates</code>控制的是哪里的流程?</p>
<p>对于动态创建的<code>Actor</code>,
在将其添加到<code>ReplicationGraph</code>的时候,
会检测其是否需要<code>Replicate</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113174511881.png" /></p>
<table>
<tr>
<td bgcolor="#D5E8D4">
<p style="line-height:1.5;">
--UWorld::SpawnActor() <br> |--UWorld::AddNetworkActor() <br> | |--//
遍历所有NetDriver, 并将Actor添加到其中 <br> |
|--Driver-&gt;AddNetworkActor(Actor); <br> | |
|--UNetDriver::AddNetworkActor() <br> | | |
|--GetNetworkObjectList().FindOrAdd(Actor, this); <br> | | | |--//
向ReplicationGraph中添加NetworkActor <br> | | |
|--ReplicationDriver-&gt;AddNetworkActor(Actor); //
UReplicationGraph::AddNetworkActor <br> | | | | |--//
检测是否需要进行Replicate <br> | | | |
|--IsActorValidForReplicationGather() <br> | | | | | |--<span
style="color:red;">AActor.GetIsReplicated() // 检测AActor的Replication
</span> <br> | | | | |--//
添加Actor对应的描述信息FGlobalActorReplicationInfo <br> | | | |
|--FGlobalActorReplicationInfo&amp; GlobalInfo =
GlobalActorReplicationInfoMap.Get(Actor); <br> | | | | |--//
设置Dormant属性 <br> | | | | |--GlobalInfo.bWantsToBeDormant =
Actor-&gt;NetDormancy &gt; DORM_Awake; <br> | | | |
|--UReplicationGraph::RouteAddNetworkActorToNodes() <br> | | | | | |--//
针对ActorInfo.Actor-&gt;bAlwaysRelevant, 添加到AlwaysRelevantNode中 <br>
| | | | | |--AlwaysRelevantNode-&gt;NotifyAddNetworkActor(ActorInfo);
<br> | | | | | |--// 针对ActorInfo.Actor-&gt;bOnlyRelevantToOwner,
添加到ActorsWithoutNetConnection中 <br> | | | | |
|--ActorsWithoutNetConnection.Add(ActorInfo.Actor); <br> | | | | | |--//
其他情况添加到GridNode中 <br> | | | | |
|--GridNode-&gt;AddActor_Dormancy(ActorInfo, GlobalInfo); <br> | | | | |
| |--UReplicationGraphNode_GridSpatialization2D::AddActor_Dormancy <br>
| | | | | | |--// 如果要想要休眠, 调用AddActorInternal_Static函数 <br> |
| | | | | |--AddActorInternal_Static(ActorInfo, ActorRepInfo, true);
<br> | | | | | | | |--如果Actor没有Init,
则添加到UReplicationGraphNode_GridSpatialization2D.PendingStaticSpatializedActors中.
<br> | | | | | | | |--否则添加到Static中 <br> | | | | | | |
|--UReplicationGraphNode_GridSpatialization2D.AddActorInternal_Static_Implementation()
<br> | | | | | | |
|--UReplicationGraphNode_GridSpatialization2D.AddActorInternal_Static_Implementation()
<br> | | | | | | |--// 否则, 调用AddActorInternal_Dynamic <br> | | | | |
| |--AddActorInternal_Dynamic(ActorInfo); <br> | | | | | | | |--//
放入了UReplicationGraphNode_GridSpatialization2D.DynamicSpatializedActors中
<br> | | | | | | | |--DynamicSpatializedActors.Emplace(ActorInfo.Actor,
ActorInfo); <br>
</p>
</td>
</tr>
</table>
<h1
id="actorcomponent开启replicate"><code>ActorComponent</code>开启<code>Replicate</code></h1>
<p>UE中, 对于需要<code>Replicate</code>的<code>ActorComponent</code>,
需要将<code>UActorComponent.bReplicates</code>设置为<code>true</code>.</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">UActorComponent<span class="selector-class">.SetIsReplicatedByDefault</span> </span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113194229321.png" /></p>
<h1
id="自定义uobject开启replicate">自定义<code>UObject</code>开启<code>Replicate</code></h1>
<p>参考:<a href="/2023/11/09/UE/%E7%BD%91%E7%BB%9C/%E8%87%AA%E5%AE%9A%E4%B9%89UObject%E8%BF%9B%E8%A1%8CReplicate/" title="自定义UObject进行Replicate">自定义UObject进行Replicate</a></p>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>SpawnActor</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>NetworkGUID</tag>
        <tag>SpawnActor</tag>
      </tags>
  </entry>
  <entry>
    <title>网络同步中, Package异步加载</title>
    <url>/2023/11/09/UE/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E4%B8%AD,%20Package%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="背景">背景</h1>
<p>UE中加载机制是, 加载会有一个队列,
一个同步加载会flush掉前面所有的异步加载, 进而造成卡顿. 例如:
当前存在异步加载A和B, 此时我调用同步加载C, 会立即将A和B flush掉,
然后执行C.</p>
<p><strong>UE NetAsyncLoad大致流程:</strong></p>
<p>在TickDispatch(收包)阶段,
针对所有ExportNetGUID(这里就指其所对应的UObject, 下同)进行异步加载,
并将其填入<code>PendingGuidResolves</code>中. 在接收Bunch中,
如果需要等待GUID加载或者QueuedBunch还没处理完,
就将该Bunch添加到QueueBunch中.</p>
<p>在TickFlush(发包)阶段, 解析GUID,
如果<code>PendingGuidResolves</code>为空, 并且其他条件也满足了,
就会处理QueueBunches.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116120153377.png" /></p>
<p>可以看到上述流程中, 如果PendingGUID都已经被解析了,
那么走的流程和正规流程没什么区别. 如果存在没有被解析的PendingGUID,
则会将Bunch放入QueuedBunches中.</p>
<span id="more"></span>
<h1 id="关键变量">关键变量</h1>
<h2 id="isexportingnetguidbunch">IsExportingNetGUIDBunch</h2>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 在对应的逻辑处理期间, 是否需要将被处理的Bunch视作ExportGuidBunch.</span><br><span class="line">FNetGUIDCache.IsExportingNetGUIDBunch </span><br></pre></td></tr></table></figure>
<p>当DS导出ExportGuid时候, 需要将该Bunch视作ExportBunch.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830105009618.png" /></p>
<p>当客户端收到NetGUIDBunch时候, 也需要将其视作ExportGUIDBunch.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830105223363.png" /></p>
<h2 id="bhasmustbemappedguids">bHasMustBeMappedGUIDs</h2>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该bunch是否存在在该Bunch处理之前必须被映射的GUID. 即处理该bunch之前,其内部使用的某些GUID是否必须被映射. 后面会紧跟着需要被映射的GUID列表</span></span><br><span class="line"><span class="built_in">uint8</span> bHasMustBeMappedGUIDs:<span class="number">1</span>; <span class="comment">// This bunch has guids that must be mapped before we can process this bunch</span></span><br></pre></td></tr></table></figure>
<h3 id="ds端处理mustbemappedguids">DS端处理MustBeMappedGUIDs</h3>
<p>如果开启NetAsyncLoading,
DS会将该Bunch(非ExportGuidBunch)中用到的GUID放入Bunch头部,
记作MustBeMappedGuids.</p>
<p>填充UPackageMapClient.MustBeMappedGuidsInLastBunch:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830120307500.png" /></p>
<p>将MustBeGUIDs序列化到Bunch中:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830120502095.png" /></p>
<h3 id="客户端处理mustbemappedguid">客户端处理MustBeMappedGUID</h3>
<p>当客户端收到的Bunch中含有MusMappedGUID时,
会将本地确实没有的但是还需要映射的GUID添加到UActorChannel.PendingGuidResolves中,
等待解析完成后处理该Bunch.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830115033063.png" /></p>
<h1 id="开启netasyncloading">开启NetAsyncLoading</h1>
<p>当开启NetAsyncLoading并且客户端收到新Bunch时,
会检测MustBeMappedGUID是否已经全部已经映射完成, 如果完成则处理Bunch,
否则放入QueueBunch中等待处理.</p>
<p>命令:</p>
<figure class="highlight smalltalk"><table><tr><td class="code"><pre><span class="line">static <span class="type">TAutoConsoleVariable</span>&lt;int32&gt; <span class="type">CVarAllowAsyncLoading</span>(</span><br><span class="line">    <span class="type">TEXT</span>(<span class="comment">&quot;net.AllowAsyncLoading&quot;</span>),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="type">TEXT</span>(<span class="comment">&quot;Allow async loading of unloaded assets referenced in packets.&quot;</span></span><br><span class="line">        <span class="comment">&quot; If false the client will hitch and immediately load the asset,&quot;</span></span><br><span class="line">        <span class="comment">&quot; if true the packet will be delayed while the asset is async loaded.&quot;</span></span><br><span class="line">        <span class="comment">&quot; net.DelayUnmappedRPCs can be enabled to delay RPCs relying on async loading assets.&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在ini中配置:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830123502966.png" /></p>
<p>在程序中调用:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830123524106.png" /></p>
<h1 id="ds处理">DS处理</h1>
<p>在序列化Bunch时, 如果存在还没被客户端ACK的GUID,
则将其放入ExportGUIDBunch中. 当开启NetAsyncLoading后, 在序列化Bunch时,
还会将其放入MustBeMappedGUIDs中,
最后再将MustBeMappedGUIDs放在Bunch的头部.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830125407131.png" /></p>
<p>当开启NetAsyncLoading后, 在DS端, 如果该Bunch并不是ExportGUIDBunch,
并且GUID需要客户端加载, 则将之放入MustBeMappedGuidsInLastBunch中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830124020193.png" /></p>
<p><strong>哪些GUID又需要客户端加载呢?</strong></p>
<ol type="1">
<li>静态GUID</li>
<li>非地图GUID</li>
<li>非NoLoad的GUID(不加载只find的GUID)</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830124340388.png" /></p>
<p>将MustMapGUID序列化到Bunch中:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830120502095.png" /></p>
<p>最后, 将Bunch发送给客户端.</p>
<h1 id="客户端处理">客户端处理</h1>
<p>UE NetAsyncLoad大致流程:</p>
<p>在TickDispatch(收包)阶段,
针对所有ExportNetGUID(这里就指其所对应的UObject, 下同)进行异步加载,
并将其填入<code>PendingGuidResolves</code>中. 在接收Bunch中,
如果需要等待GUID加载或者QueuedBunch还没处理完,
就将该Bunch添加到QueueBunch中.</p>
<p>在TickFlush(发包)阶段, 解析GUID,
如果<code>PendingGuidResolves</code>为空, 并且其他条件也满足了,
就会处理QueueBunches.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830171046744-1693386964261-4.png" /></p>
<h2 id="异步加载资源">异步加载资源</h2>
<p>在处理<code>ExportGUIDBunch</code>时候,
会调用<code>UPackageMapClient::InternalLoadObject</code>,
在里面会触发<code>FNetGUIDCache.GetObjectFromNetGUID</code>,
进而调用<code>FNetGUIDCache.StartAsyncLoadingPackage</code>,
即触发异步加载.</p>
<p>反序列化ExportGUIDBunch里面所有的GUID:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830131303721.png" /></p>
<p>如果开启<code>NetAsyncLoading</code>, 会触发异步加载.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830131031805.png" /></p>
<p><strong>注意:</strong>UPackage加载完成后并不设置<code>FNetGuidCacheObject.Object</code>,
而是在<code>UNetConnection.Tick</code>中每帧重新查找(<code>StaticFindObject</code>)绑定.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830172146688.png" /></p>
<h2
id="将guid添加到pendingguidresolves中">将GUID添加到PendingGuidResolves中</h2>
<h3
id="ds收到的bunch不允许为bhasmustbemappedguids类型bunch">DS收到的Bunch不允许为bHasMustBeMappedGUIDs类型Bunch</h3>
<p>DS不允许有bHasMustBeMappedGUIDs, 否则直接报错, 返回.
因为DS端是Guid的配置者, 它不可能收到新的GUID, 所有GUID由它分配.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830114741816.png" /></p>
<h3
id="客户端将guid添加到pendingguidresolves">客户端将GUID添加到PendingGuidResolves</h3>
<p>当客户端收到MusMappedGUID时,
会将本地确实没有加载的但是还需要映射的GUID添加到UActorChannel.PendingGuidResolves中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830115033063.png" /></p>
<h2 id="将bunch存入queuebunch中">将Bunch存入QueueBunch中</h2>
<p>满足以下条件, Bunch会放入QueueBunch中,等待处理.</p>
<ol type="1">
<li>PendingGuidResolves已经有了待解析的GUID.</li>
<li>QueuedBunches中还有待解析Bunch.</li>
<li>想要ShutDown的Actor, 但是在处理一些事情之前还想处理bunch.</li>
<li>Driver范围内需要针对该Actor进行QueueBunch</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830111504210.png" /></p>
<h2 id="处理queuebunch">处理QueueBunch</h2>
<h3
id="清理pendingguidresolves中元素">清理PendingGuidResolves中元素</h3>
<p>客户端在<code>UNetConnection.Tick</code>时,
每次查询GUID对应的Obj是否存在, 如果存在进行绑定,
并删除PendingGuidResolves中的元素.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830160654662.png"
alt="堆栈" />
<figcaption aria-hidden="true">堆栈</figcaption>
</figure>
<p>通过<code>StaticFindObject</code>查找GUID对应的Obj, 然后进行绑定:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830160921240.png" /></p>
<h3 id="处理queuebunch-1">处理QueueBunch</h3>
<p>当条件都满足时, 就可以处理Bunch了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830161047241.png" /></p>
<h3 id="注意">注意</h3>
<p>通过上文可以发现, UE并不是针对每个Bunch单独记录其MustBeMappedGUID,
而是统一记录, 直至清空. 这样做虽然简单, 但是会产生一个问题,
就是如果一直有需要MustBeMappedGUID的Bunch,
那么客户端就会阻塞Bunch的处理, 这个可能引发连锁反应, 就是虽然不卡,
但是游戏仿佛停止了. <span style="color:red;">目前,
UE是针对ActorChannel做Bunch的阻塞,
即不同AcotrChannel是相互独立的.</span></p>
<p><code>UActorChannel.QueuedBunches</code>归属于ActorChannel.
<code>UActorChannel.ProcessQueuedBunches</code>也是在ChannelTick中执行的.
即Bunch已经存储在对应的Channel中了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116141751473.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116141848770.png" /></p>
<p>进一步优化方法: 针对Bunch, 单独记录其<code>MustBeMappedGUID</code>,
load完一个, 处理一个, 这样可以保证游戏正常运行.</p>
<h1 id="构建复现环境">构建复现环境</h1>
<p>首先, 编辑器下无法复现. 原因: DS和客户端同处一份环境中,
资源加载是共享的, 所以无法复现DS加载但是客户端还没加载的情况.</p>
<p>了解了原因, 可以专门启用命令行DS, 然后客户端一定要保证没加载过该资源,
例如第一次启动编辑器, 并且默认地图的相关引用没有引用到该资源.</p>
<p>在一个空场景使用Standalone方式启动客户端连接DS.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830162523657.png" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830162549477.png"
alt="连接DS" />
<figcaption aria-hidden="true">连接DS</figcaption>
</figure>
<p>DS端专门创建了一个Actor, 并开启Replication.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (LocalFrameIndex==<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    FVector Loc = FVector::ZeroVector;</span><br><span class="line">    FRotator Rot = FRotator::ZeroRotator;</span><br><span class="line">    FActorSpawnParameters Par;</span><br><span class="line">    Par.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;</span><br><span class="line">    UClass *pClass = <span class="built_in">LoadObject</span>&lt;UClass&gt;(<span class="keyword">this</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Blueprint&#x27;/Game/GamePlay/BP_TestDormancy.BP_TestDormancy_C&#x27;&quot;</span>));</span><br><span class="line">    TestActor = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AActor&gt;(pClass, Loc, Rot, Par);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830162648201.png" /></p>
<p>客户端下断点, 并连接DS.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230830163204235.png" /></p>
<h1 id="总结">总结</h1>
<ol type="1">
<li>NetAsyncLoading仅仅在客户端网络层触发异步加载. 在DS端是不需要的,
因为DS不会存在网络层加载UObject的情况,
一般都是主动Load后<code>Spawn/NewObject</code>.</li>
<li>需要异步加载的Guid对应的资源全部都是静态的,
并且是客户端可以加载的(非Level, 非NoLoad).</li>
<li>开启NetAsyncLoading,
DS会将MustedMappedGUID放入Bunch(非ExportGUIDBunch)头部,
用bHasMustBeMappedGUIDs表示.</li>
<li>开启NetAsyncLoading,
客户端会异步加载GUID对应的Package(当前还没加载),
在此期间收到的Bunch都放入BunchQueue中,
等待GUID对应的Package加载完成后处理.</li>
<li>必须等所有MustBeMappedGUID都处理完成后才会处理BunchQueue.(ActorChannel级别的阻塞,
不同ActorChannel是相互独立的.)</li>
<li>UPackage加载完成后并不设定<code>FNetGuidCacheObject.Object</code>,
而是在<code>UNetConnection.Tick</code>中每帧重新查找(<code>StaticFindObject</code>)绑定.</li>
</ol>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>Package异步加载</tag>
      </tags>
  </entry>
  <entry>
    <title>网络日志,丢包,延迟等相关命令</title>
    <url>/2023/11/14/UE/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97,%E4%B8%A2%E5%8C%85,%E5%BB%B6%E8%BF%9F%E7%AD%89%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="网络相关日志">网络相关日志</h1>
<p>开启网络相关日志:</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">log</span> LogNetTraffic <span class="built_in">log</span></span><br><span class="line"><span class="built_in">log</span> LogNetPackageMap <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>关闭网络相关日志:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">log</span> LogNetTraffic <span class="keyword">off</span></span><br><span class="line"><span class="keyword">log</span> LogNetPackageMap <span class="keyword">off</span></span><br></pre></td></tr></table></figure>
<p>开启DS端络相关日志:</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">ServerExec <span class="built_in">log</span> LogNetTraffic <span class="built_in">log</span></span><br><span class="line">ServerExec <span class="built_in">log</span> LogNetPackageMap <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h1 id="丢包延迟">丢包/延迟</h1>
<p>注意, 一下命令等号两端不能有空格</p>
<ol type="1">
<li>Net pktLag=，模拟延迟，单位是毫秒</li>
<li>Net
PktLagVariance=300，在模拟延迟的基础上，再上下浮动300毫秒。加上这个就会出现移动瞬移卡顿的效果</li>
<li>Net PKtLoss=，丢包，单位是百分比，Net
PKtLoss=90就是90%会丢包，也会出现移动瞬移卡顿</li>
<li>Net PktOrder=1，乱序发包，会出现一定的移动瞬移，但不太明显</li>
<li>Net PktDup=，重复发包，单位是百分比，Net
PktDup=20表示20%会出现重复发包。</li>
</ol>
<p>[<a
href="https://www.cnblogs.com/timy/p/9895354.html"><strong>[UE4]模拟网络延迟和丢包</strong>](https://www.cnblogs.com/timy/p/9895354.html)</a></p>
<h1 id="serverexec">ServerExec</h1>
<p>ServerExe相关实现:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231114114630407.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231114114709854.png" /></p>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>日志</category>
        <category>丢包</category>
        <category>延迟</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>日志</tag>
        <tag>丢包</tag>
        <tag>延迟</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义UObject进行Replicate</title>
    <url>/2023/11/09/UE/%E7%BD%91%E7%BB%9C/%E8%87%AA%E5%AE%9A%E4%B9%89UObject%E8%BF%9B%E8%A1%8CReplicate/</url>
    <content><![CDATA[<p>UE本身有一套自创的网络框架,
在这个框架里UObject类型默认是无法进行属性同步的.
如果想要UObject进行属性同步就必须进行一系列重写.</p>
<span id="more"></span>
<h1 id="示例代码">示例代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="built_in">UCLASS</span>(BlueprintType, Blueprintable)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UMyTestObject</span> : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UMyTestObject</span>(<span class="type">const</span> FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::<span class="built_in">Get</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Allows the Object to get a valid UWorld from it&#x27;s outer.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UWorld* <span class="title">GetWorld</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allow replicate data</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsSupportedForNetworking</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allow rpc</span></span><br><span class="line">    <span class="function">int32 <span class="title">GetFunctionCallspace</span><span class="params">(UFunction* Function, FFrame* Stack)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CallRemoteFunction</span><span class="params">(UFunction* Function, <span class="type">void</span>* Parameters, <span class="keyword">struct</span> FOutParmRec* OutParams, FFrame* Stack)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">    uint32 bReplicatedFlag : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line">UMyTestObject::<span class="built_in">UMyTestObject</span>(<span class="type">const</span> FObjectInitializer&amp; ObjectInitializer <span class="comment">/*= FObjectInitializer::Get()*/</span>)</span><br><span class="line">    :<span class="built_in">UObject</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UWorld* <span class="title">UMyTestObject::GetWorld</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> UObject* MyOuter = <span class="built_in">GetOuter</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> MyOuter-&gt;<span class="built_in">GetWorld</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UMyTestObject::IsSupportedForNetworking</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyTestObject::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">    <span class="built_in">DOREPLIFETIME</span>(UMyTestObject, bReplicatedFlag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UMyTestObject::CallRemoteFunction</span><span class="params">(UFunction* Function, <span class="type">void</span>* Parameters, <span class="keyword">struct</span> FOutParmRec* OutParams, FFrame* Stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AActor* OuterActor = <span class="built_in">Cast</span>&lt;AActor&gt;(<span class="built_in">GetOuter</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        UNetDriver* NetDriver = OuterActor-&gt;<span class="built_in">GetNetDriver</span>();</span><br><span class="line">        <span class="keyword">if</span> (NetDriver)</span><br><span class="line">        &#123;</span><br><span class="line">            NetDriver-&gt;<span class="built_in">ProcessRemoteFunction</span>(OuterActor, Function, Parameters, OutParams, Stack, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">int32 <span class="title">UMyTestObject::GetFunctionCallspace</span><span class="params">(UFunction* Function, FFrame* Stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AActor* OuterActor = <span class="built_in">Cast</span>&lt;AActor&gt;(<span class="built_in">GetOuter</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> OuterActor-&gt;<span class="built_in">GetFunctionCallspace</span>(Function, Stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FunctionCallspace::Local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在BasePlayerController.h中添加:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623105137222.png" /></p>
<p>由于Replicated, 需要将pTestObj添加到GetLifetimeReplicatedProps中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623111940690.png" /></p>
<p>重写ABasePlayerController::ReplicateSubobjects函数,
将pTestObj添加到ABasePlayerController列表中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623105331465.png" /></p>
<p>在BasePlayerController.cpp中动态创建:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230623105258155.png" /></p>
<p>经过上述步骤, 可以将自定义UMyTestObject进行属性同步.</p>
<h1 id="ue-replicate流程">UE Replicate流程</h1>
<p>UE在进行属性同步时候, 首先进行Actor自身的属性同步, 然后同步SubObject,
最后才同步自定义UObject.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义UObject属性同步流程</span></span><br><span class="line">--UNetDriver.<span class="built_in">TickFlush</span>()</span><br><span class="line"> |--UNetDriver.<span class="built_in">ServerReplicateActors</span>()</span><br><span class="line"> | |--UNetDriver.<span class="built_in">ServerReplicateActors_ProcessPrioritizedActors</span>()</span><br><span class="line"> | | |--UActorChannel.<span class="built_in">ReplicateActor</span>()</span><br><span class="line"> | | | |--<span class="comment">// 同步该Actor自身属性</span></span><br><span class="line"> | | | |--FObjectReplicator.<span class="built_in">ReplicateProperties</span>()</span><br><span class="line"> | | | |--AActor.<span class="built_in">ReplicateSubobjects</span>()</span><br><span class="line"> | | | | |--<span class="comment">// 同步Actor中所有需要Replicated的ActorComponent</span></span><br><span class="line"> | | | | |--UActorComponent.<span class="built_in">ReplicateSubobjects</span>()</span><br><span class="line"> | | | | |--UActorChannel.<span class="built_in">ReplicateSubobject</span>()</span><br><span class="line"> | | | | |--<span class="comment">// 自定义UObject进行属性同步</span></span><br><span class="line"> | | | | |--UActorChannel.<span class="built_in">ReplicateSubobject</span>()</span><br></pre></td></tr></table></figure>
<p>引用:<a href="/2023/11/09/UE/%E7%BD%91%E7%BB%9C/RPC%E6%B5%85%E6%9E%90/" title="RPC浅析">RPC浅析</a></p>
]]></content>
      <categories>
        <category>UE</category>
        <category>UE网络</category>
        <category>属性同步</category>
      </categories>
      <tags>
        <tag>UE网络</tag>
        <tag>属性同步</tag>
        <tag>自定义UObject属性同步</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-TMap</title>
    <url>/2023/11/09/UE/%E5%AE%B9%E5%99%A8/TMap/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p><span style="color:red;">先了解<code>TSet</code>,
再看<code>TMap</code>. </span></p>
<p><code>TMap</code>是继承自<code>TMapBase</code>,
最终操作的也是其成员变量<code>ElementSetType Pairs</code>,
即<code>TSet</code>类型.
<code>TMap</code>将<code>Element</code>类型设置为<code>typedef TPair&lt;KeyType, ValueType&gt; ElementType;</code>,
即Pair类型.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912193952646.png" /></p>
<span id="more"></span>
<p>重写<code>BaseKeyFuncs</code>, 实现<code>TDefaultMapKeyFuncs</code>,
自定义关键函数<code>GetSetKey</code>和<code>Matches</code>,
来进行获取<code>Key</code>和<code>KeyHash</code>以及比较等操作. 这样,
其Element内容就和整个类解耦了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912194205939.png" /></p>
<h1 id="关键变量">关键变量</h1>
<p>从TMap的整体构建来看,
其所有函数都是对<code>ElementSetType Pairs</code>进行操作,
其实就是对<code>TSet</code>的封装.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> TPair&lt;KeyType, ValueType&gt; ElementType;</span><br><span class="line"><span class="keyword">typedef</span> TSet&lt;ElementType, KeyFuncs, SetAllocator&gt; ElementSetType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** A set of the key-value pairs in the map. */</span></span><br><span class="line">ElementSetType Pairs;</span><br></pre></td></tr></table></figure>
<h2 id="find">Find</h2>
<p>详见<code>TSet.Find</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912195115734.png" /></p>
<h2 id="findoradd">FindOrAdd</h2>
<p>先进行<code>Find</code>, 如果没<code>Find</code>到,
则进行<code>Add</code>, 返回<code>Add</code>结果.
<code>Add</code>最终调用的是<code>TSet.EmplaceByHash</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912195217492.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912195251885.png" /></p>
<p>从上述代码可以看出,
<code>FindOrAdd</code>比<code>Find</code>+<code>Add</code>少算一次<code>KeyHash</code>,
并且从使用方式上比<code>Find</code>+<code>Add</code>更简洁.
所以推荐使用<code>FindOrAdd</code>.</p>
<h2 id="contains">Contains</h2>
<p>详见<code>TSet.Contains</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912200401412.png" /></p>
<h2 id="remove">Remove</h2>
<p>详见<code>TSet.Remove</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912200432209.png" /></p>
<h2 id="operator">operator[]</h2>
<p>其核心还是调用<code>TSet.Find</code>.
查询到<code>Item.Value</code>并且返回其引用, 进而可以直接进行操作.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912191924488.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912192013741.png" /></p>
]]></content>
      <categories>
        <category>UE</category>
        <category>Container</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>Container</tag>
        <tag>TMap</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-TSet</title>
    <url>/2023/11/09/UE/%E5%AE%B9%E5%99%A8/TSet/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>核心: <code>HashArray</code>+<code>ElementArray</code></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912115416424.png" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911192653763.png"
alt="关键流程" />
<figcaption aria-hidden="true">关键流程</figcaption>
</figure>
<p>一般Hash的实现一般由以下步骤实现:</p>
<ol type="1">
<li>将Element映射成Hash.</li>
<li>通过Hash值找到对应成员.</li>
</ol>
<p>具体实现:
UE使用两个数组<code>HashArray</code>+<code>ElementArray</code>来实现<code>TSet</code>,
<code>HashArray</code>中存放着<code>ElementArray</code>的<code>Index</code>,
<code>ElementArray</code>中存放着具体的值.</p>
<ol type="1">
<li>TSet将映射方式暴露给用户,
由程序员自定义实现:<code>uint32 GetTypeHash(...)</code>,
最终返回类型为<code>uint32</code>的<code>KeyHash</code>.</li>
<li>TSet内部实现了通过<code>KeyHash</code>找到对应Element的方式:
<ol type="1">
<li>根据<code>HashIndex &amp; (HashSize - 1)</code>,
计算<code>HashIndex</code>, 然后取出<code>HashElementValue</code>,
此处<code>HashElementValue</code>代表<code>ElementArray</code>的<code>Index</code>.</li>
<li>根据<code>Index</code>从<code>ElementArray</code>获取具体的<code>ElementValue</code>,
如果发生冲突, 拉链法解决冲突.
每个<code>Element</code>记录着<code>NextElementIndex</code>,
如果该Element发生冲突,
通过<code>NextElementIndex</code>寻找到下一个Element.</li>
</ol></li>
</ol>
<span id="more"></span>
<h1 id="实现细节">实现细节</h1>
<h2 id="声明">声明</h2>
<p><strong>前置声明</strong>,
默认使用<code>DefaultKeyFuncs&lt;InElementType&gt;</code>作为<code>KeyFuncs</code>,
使用<code>FDefaultSetAllocator</code>作为<code>Allocator</code></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911161319485.png" /></p>
<p><strong>真正实现:</strong>使用四个传入参数作为TSet的模板参数.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911193102258.png" /></p>
<h2 id="add">Add</h2>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911200700442.png" /></p>
<h3 id="tset.add">TSet.Add</h3>
<p>调用Add函数<code>TSet.Add</code>添加元素.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911162930925.png" /></p>
<h3 id="tset.emplace">TSet.Emplace</h3>
<p>进一步调用<code>TSet.Emplace</code>.
在<code>Elements</code>中添加元素,
然后根据参数进行初始化(<code>place new</code>).
根据<code>ElementValue</code>获取<code>Hash</code>值.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911163039172.png" /></p>
<p>根据Hash值,
获取Hash数组中的索引<code>HashIndex &amp; (HashSize - 1)</code>,
根据Hash索引, 取出Element</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911163632098.png"
alt="image-20230911163632098" />
<figcaption aria-hidden="true">image-20230911163632098</figcaption>
</figure>
<h3 id="tset.emplaceimpl">TSet.EmplaceImpl</h3>
<p>调用<code>TSet.EmplaceImpl</code>, 实现真正Add.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911201128318.png" /></p>
<p>讲解一下该函数中的<code>FindIdByHash</code>函数.
通过<code>KeyHash</code>获取到<code>ElementArray</code>中指定元素.
由于不同元素可能定位到同一个<code>ElementIndex</code>上,
UE使用拉链方式解决冲突,
它根据<code>TSetElementBase.HashNextId</code>构成一个链表, 进行存储.
所以需要遍历这个链表, 比较每个元素是否真正相同. 如果真正相同,
则返回其ElementIndex.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911201816846.png" /></p>
<p>如果ElementArray存在对应的元素, 就覆盖, 否则,就添加新的.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911202014254.png" /></p>
<p>添加新元素时, 将新元素插入到链表首位.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911202129420.png" /></p>
<p>注意: 在Add时候会返回之前元素是否已经存在.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911203633007.png" /></p>
<h2 id="find">Find</h2>
<p>首先根据Element生成KeyHash, 根据KeyHash找到HashArray中的Index,
根据<code>ElementIndex(HashArray[HashIndex])</code>定位到<code>ElementArray</code>中的元素,
即链表头, 然后遍历链表, 通过比较方式找到最终的对象.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912115207933.png" /></p>
<p>找到最终的Element元素索引.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912115125157.png" /></p>
<h2 id="contains">Contains</h2>
<p>根据<code>Key(Element本身)</code>计算出<code>KeyHash</code>,
通过<code>KeyHash&amp; (HashSize - 1)</code>得到<code>HashIndex</code>,
取出<code>HashArrayItem(即ElementIndex)</code>,
遍历<code>ElementArray</code>中的链表, 查看其是否真正存在.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912195557175.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912195622278.png" /></p>
<h2 id="remove">Remove</h2>
<p>调用<code>TSet.Remove</code>函数,
使用<code>KeyFuncs::GetKeyHash(Key)</code>计算其<code>KeyHash</code>,
并传入到<code>TSet.RemoveImpl</code>中.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911205738241.png" /></p>
<p>在函数<code>TSet.RemoveImpl</code>中,
使用函数<code>GetTypedHash(KeyHash)</code>计算其<code>ElementArrayIndex</code>,
然后开始该遍历. 使用比较函数<code>KeyFuncs::Matches</code>, 如果相同,
则直接删除, 如果<code>bAllowDuplicateKeys</code>为false, 则直接break,
否则继续遍历.</p>
<p><strong>注意一点, 当<code>bAllowDuplicateKeys</code>为true的时候,
是删除了<code>NextElementId</code>指向的元素,
<code>NextElementId</code>并没有删除,
这就是为什么<code>NextElementId</code>使用指针的原因. 否则代码会非常乱,
没有现在这么简洁</strong></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911210335490.png" /></p>
<p>使用<code>void Remove(FSetElementId ElementId)</code>函数,
真正删除对应的元素.</p>
<p>链表删除逻辑:</p>
<ol type="1">
<li>存储next指针, 指向待处理元素.</li>
<li>通过比较, 检测是否为待删除元素A, 如果是,
则将Next指针的值设置为A的next, 并进行break; 否则继续遍历.</li>
<li>删除元素A.</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912095240012.png" /></p>
<h2 id="rehash">Rehash</h2>
<ol type="1">
<li>释放HashArray所有元素</li>
<li>重建HashArray</li>
<li>将HashArray中元素设置为默认值.</li>
<li>遍历ElementArray, 重建HashArray.</li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911212306750.png" /></p>
<p><code>TSet.HashElement</code>核心逻辑, 如下代码可以理解为:
对于任意新添加的元素Element, 重新计算其HashIndex,
将<code>Element.Next</code>设置为<code>HashArray[HashIndex]</code>,
即<code>Element.Next</code>指向旧的<code>ElementIndex</code>,
然后更新<code>HashArray[HashIndex]</code>,
将其设置为新的<code>ElementIndex</code>. 经过如上分析可知,</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911212557432.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911214905993.png" /></p>
<p>如果将Element插入到自己所在链表中会造成什么样的结果呢? 死循环:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911215026124.png" /></p>
<p>在TSet中, 不会将一个Element插入到自己链表头部. 所以不会有死循环.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230911215125651.png" /></p>
<h3 id="什么时候进行rehash呢">什么时候进行Rehash呢?</h3>
<p>一般而言根据<code>Element</code>的数量计算是否需要<code>Rehash</code>.
根据<code>Element</code>数量计算出目标数量(<code>RoundUpToPowerOfTwo</code>),
如果目标数量大于当前Hash数量, 就进行扩容.</p>
<ol type="1">
<li><strong>添加新元素</strong></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230914103218293.png" /></p>
<ol start="2" type="1">
<li><strong>排序</strong></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230914103724574.png" /></p>
<ol start="3" type="1">
<li><strong>Empty</strong></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230914103820753.png" /></p>
<ol start="4" type="1">
<li><strong>Compact</strong></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230914103905355.png" /></p>
<ol start="5" type="1">
<li><strong>Reserve</strong></li>
</ol>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230914103948863.png" /></p>
<h2 id="hasharray扩容">HashArray扩容</h2>
<p><strong>Reserve时候会进行扩容.</strong></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912103543864.png" /></p>
<p><strong>在添加元素时, 会按需进行扩容.</strong></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912104908446.png" /></p>
<p>扩容的时候, 要执行Rehash.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912105037405.png" /></p>
<h2 id="elementarray扩容">ElementArray扩容</h2>
<p><strong>Reserve时候会进行扩容.</strong></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912103509351.png" /></p>
<p>每当添加元素时候, 会按需进行扩容.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912105340106.png" /></p>
<h1 id="优化">优化</h1>
<p>性能消耗点: 在Add时候, 会进行一次<code>GetTypeHash</code>计算,
并与链表中元素进行比较. 假设<code>HashArray</code>大小为16,
那么每次添加元素的Hash值恰好是16的倍数, 则会形成单链表,
比较结果如下:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912113418959.png" /></p>
<p>那么我们怎么才能节省性能呢?</p>
<p>可以将<code>GetTypeHash</code>生成的<code>KeyHash</code>存储在结构体内部,
只生成一次, 每次比较时候优先比较<code>KeyHash</code>, 如果KeyHash相同,
再比较具体内容. 如果我们能假定生成的<code>KeyHash</code>一定是唯一的,
那么只要比较其<code>KeyHash</code>就可以了.
但是尽量不要用<code>operator ==</code>,
可以仿照<code>DefaultKeyFuncs</code>定制<code>BaseKeyFuncs</code>,
最好进行前向声明, 这样大家就能直接用了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912114550734.png" /></p>
<p>前向声明参考:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20230912114656002.png" /></p>
]]></content>
      <categories>
        <category>UE</category>
        <category>Container</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>Container</tag>
        <tag>TSet</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4移动-MaintainHorizontalGroundVelocity</title>
    <url>/2023/11/09/UE/%E7%A7%BB%E5%8A%A8/MaintainHorizontalGroundVelocity/</url>
    <content><![CDATA[<p><code>bMaintainHorizontalGroundVelocity</code>:</p>
<ul>
<li>为<code>true</code>, 则直接丢弃竖直方向速度, 使用水平方向速度.
速度变小了</li>
<li>为<code>false</code>, 则速度大小不变, 但是竖直方向速度设置为0.
即将竖直方向的速度转移到水平方向, 速度大小不变,
方向发生了变化(竖直方向被丢弃了).</li>
</ul>
<span id="more"></span>
<p>定义:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If true, walking movement always maintains horizontal velocity when moving up ramps, which causes movement up ramps to be faster parallel to the ramp surface.</span></span><br><span class="line"><span class="comment"> * If false, then walking movement maintains velocity magnitude parallel to the ramp surface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Category=<span class="string">&quot;Character Movement: Walking&quot;</span>, EditAnywhere, BlueprintReadWrite)</span><br><span class="line">uint8 bMaintainHorizontalGroundVelocity:<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCharacterMovementComponent::MaintainHorizontalGroundVelocity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Velocity.Z != <span class="number">0.f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bMaintainHorizontalGroundVelocity)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Ramp movement already maintained the velocity, so we just want to remove the vertical component.</span></span><br><span class="line">            Velocity.Z = <span class="number">0.f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Rescale velocity to be horizontal but maintain magnitude of last update.</span></span><br><span class="line">            Velocity = Velocity.<span class="built_in">GetSafeNormal2D</span>() * Velocity.<span class="built_in">Size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上很容易看出,
<code>bMaintainHorizontalGroundVelocity</code>表示:是否保持水平速度.
当开启<code>bMaintainHorizontalGroundVelocity</code>时,
直接丢弃<code>z</code>轴方向速度, 保持水平方向速度.
当关闭<code>bMaintainHorizontalGroundVelocity</code>时, 速度大小不变,
但是将竖直方向速度转移到水平方向上, 并且速度的水平方向保持不变,
数值方向为0.</p>
<table>
<tr>
<td bgcolor="#D5E8D4">
注意: 无论是否开启<em>bMaintainHorizontalGroundVelocity</em>,
竖直方向速度都会被清零, 并且速度方向并不是沿着某个表面的,
而是与<em>xy</em>平面平行的.
</td>
</tr>
</table>
]]></content>
      <categories>
        <category>UE4</category>
        <category>移动</category>
        <category>速度</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>移动</tag>
        <tag>速度</tag>
      </tags>
  </entry>
  <entry>
    <title>Geometry Queries(碰撞检测)--翻译</title>
    <url>/2023/11/09/UE/%E7%A7%BB%E5%8A%A8/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B-%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<p>原文链接<a
href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/3.3.4/Manual/GeometryQueries.html">Geometry
Queries</a>.</p>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p><code>solid half-space</code>:
我对<code>solid half-space</code>的理解是: 正常封闭型固体分成内部和外部,
<code>half-space geometry</code>表示外部与外界相交,
内部也能与外部相交的几何体.
例如平面就可以被当做<code>solid half-space</code>.</p>
<p><code>SPU</code>和<code>PPU</code>是什么? 解释:<a
href="https://zhuanlan.zhihu.com/p/99446588">PS3中的处理器核心</a>.</p>
<h1 id="序言">序言</h1>
<p>这篇文章介绍使用PhysX处理独立几何体的碰撞和形状查询.
碰撞和场景查询形成对比, 后者碰撞或者查询场景中所有的对象.
有四种主要的几何<code>Geometry Query</code>:</p>
<ul>
<li><code>Raycasts(Raycast Queries)</code>: 射线是否与几何体相交</li>
<li><code>Sweeps(Sweep Queries)</code>: 沿着直线移动一个几何体,
找到与之相交的几何体的第一个点</li>
<li><code>Overlaps(Overlap Queries)</code>: 决定两个结合体怎么相交.</li>
<li>渗入深度计算(<code>minimal translational distance queries</code>,
缩写<code>MTD</code>):
查找能使两个<code>Overlap</code>的几何体分开的最小距离的方向.</li>
</ul>
<p>另外,
<code>PhysX</code>提供一个<code>Geometry Object</code>的计算<code>AABB</code>的方法,
以及计算一个点到<code>Geometry Object</code>的距离.</p>
<p>以下所有函数中,
<code>Geometry Object</code>都是以<code>PxGeometry structure</code>定义形状,
以<code>PxTransform structure</code>定义姿势的.
所有的<code>Transform</code>和<code>Vector</code>都被解释为在任意空间,
并且返回该空间中的结果.</p>
<h1 id="raycasts">Raycasts</h1>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/GeomQueryRaycast-1696640665770-26.png" /></p>
<p><code>Raycast Query</code>:沿着一条线段追踪一个点,
并记录与几何体表面相交的信息.
<code>PhysX</code>支持向所有几何体打射线.</p>
<p>下面的代码举例说明如何使用<code>Raycast Query</code>:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">PxRaycastHit</span> hitInfo;</span><br><span class="line"><span class="title class_">PxU32</span> maxHits = <span class="number">1</span>;</span><br><span class="line">bool anyHit = <span class="literal">false</span>;</span><br><span class="line"><span class="title class_">PxHitFlags</span> hitFlags = <span class="title class_">PxHitFlag</span><span class="symbol">:</span><span class="symbol">:ePOSITION|PxHitFlag</span><span class="symbol">:</span><span class="symbol">:eNORMAL|PxHitFlag</span><span class="symbol">:</span><span class="symbol">:eDISTANCE|PxHitFlag</span><span class="symbol">:</span><span class="symbol">:eUV</span>;</span><br><span class="line"><span class="title class_">PxU32</span> hitCount = <span class="title class_">PxGeometryQuery</span><span class="symbol">:</span><span class="symbol">:raycast</span>(origin, unitDir,</span><br><span class="line">                                          geom, pose,</span><br><span class="line">                                          maxDist,</span><br><span class="line">                                          hitFlags,</span><br><span class="line">                                          maxHits, &amp;hitInfo, anyHit);</span><br></pre></td></tr></table></figure>
<p>对参数的解释如下:</p>
<ul>
<li><code>Origin</code>: 射线起始位置.</li>
<li><code>unitDir</code>: 定义射线方向的单位向量.</li>
<li><code>maxDist</code>: 沿射线搜寻的最大距离.
<code>maxDist</code>必须在<span class="math inline">\([0,
inf]\)</span>范围之内. 如果1<code>maxDist</code>为0,
只有当射线起始点在图形内部才会返回一个<code>hit</code>,
下面对每个几何体进行详细说明.</li>
<li><code>geom</code>: 被测试的几何体.</li>
<li><code>pose</code>: 被测试几何体的位置</li>
<li><code>hitFlag</code>: 指定查询应返回的值, 以及处理查询的选项.</li>
<li><code>maxHits</code>: 返回的最大<code>hit</code>数量.</li>
<li><code>hitInfo</code>: 指定射线结果存储的地方,
即<code>PxRaycastHit</code>结构体.</li>
<li><code>anyHit</code>: 已废弃.
它等价于<code>PxHitFlag::eMESH_ANY</code>.
应该使用<code>PxHitFlag::eMESH_ANY</code>.</li>
</ul>
<p>返回结果为交互的数量. 每个交互的信息,
都会用<code>PxRaycastHit</code>存储. 结构体属性如下:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">PxRigidActor*   actor;</span><br><span class="line">PxShape*        <span class="keyword">shape;</span></span><br><span class="line"><span class="keyword"></span>PxVec3          position;</span><br><span class="line">PxVec3          <span class="keyword">normal;</span></span><br><span class="line"><span class="keyword"></span>PxF32           <span class="keyword">distance;</span></span><br><span class="line"><span class="keyword"></span>PxHitFlags      flags;</span><br><span class="line">PxU32           faceIndex;</span><br><span class="line">PxF32           u, v;</span><br></pre></td></tr></table></figure>
<p>某些字段是可选的, <code>flag</code>字段指明哪些成员会被填充到结果中.
如果在输入中设置了相应的字段, 该字段将被填充到输出结构中. 例如,
如果<code>hitFlags</code>被设置成<code>PxHitFlag::ePOSITION</code>,
查询将会填充<code>PxRaycastHit::position</code>字段,
并且在<code>PxRaycastHit::flags</code>中填充<code>PxRaycastHit::position</code>值.
如果<code>Input Flag</code>中没有设置指定的成员,
输出结果中不一定会包含相应成员的数据.
如果输入中不包含<code>eNormal</code>和<code>ePosition</code>标记,
查询会更快.</p>
<p>对于那些最初不与几何体相交的射线,
字段填充如下(可选字段和控制它们的标记列在一起):</p>
<ul>
<li><p><code>actor</code>和<code>shape</code>不会被填充(这些字段只在<code>scene-level raycast</code>中被使用,
详情:<a
href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/3.3.4/Manual/SceneQueries.html#scene-queries">Scene
Queries</a>).</p></li>
<li><p><code>position (PxHitFlag::ePOSITION)</code>:相交的位置.</p></li>
<li><p><code>normal (PxHitFlag::eNORMAL)</code>:交点的表面法线.</p></li>
<li><p><code>distance (PxHitFlag::eDISTANCE)</code>:
射线上找到交点的距离.</p></li>
<li><p><code>flag</code>指明了结构体中哪些字段是可用的.</p></li>
<li><p><code>faceIndex</code>:射线<code>hit</code>到的<code>face</code>的<code>index</code>.
对于<code>三角形网格(triangle mesh)</code>和<code>高度场(height field)</code>相交,
它表示三角形索引. 对于<code>凸多边形(convex mesh)</code>相交,
它是多边形的索引. 对于其他形状,
它永远是<code>0xFFFFFFFF</code>.</p></li>
<li><p><code>u</code>和<code>v</code>(<code>PxHitFlag::eUV</code>)是交点的重心坐标系.
这些字段(以及标记)只支持<code>mesh</code>(不支持<code>高度场(height field)</code>).</p></li>
</ul>
<p><code>Position</code>字段和重心坐标系相关, 公式如下,
其中<code>v0</code>,
<code>v1</code>和<code>v2</code>是被<code>hit</code>的三角形的顶点.</p>
<blockquote>
<p>position = (1 - u - v)<em>v0 + u</em>v1 + v*v2;</p>
</blockquote>
<p>如何在<code>triangle mesh</code>中检索面和顶点数据,
在<code>凸多边形mesh(convex mesh)</code>和<code>高度场(height field)</code>中使用面和顶点索引,
详情请查询<a
href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/3.3.4/Manual/Geometry.html#geometry">Geometry</a>.</p>
<p>当射线起点在几何体内部时, 除了应用上面的行为,
对于某些字段<code>PhysX</code>可能无法计算出有意义的值. 这种情况下,
这些字段不会发生更改, 并且对应的标记也不会被设置.
具体细节因几何类型而异, 如下所述.</p>
<p>射线交点的具体情况如下:</p>
<h2
id="向spheres-capsules-boxs-convex-meshes打射线">向<code>Spheres</code>
<code>Capsules</code> <code>Boxs</code>
<code>Convex Meshes</code>打射线</h2>
<p>当射线原点在固体对象(<code>Spheres</code>, <code>Capsules</code>
<code>Boxs</code>
<code>Convex Meshes</code>)内部时,最多返回一个结果:</p>
<ul>
<li><code>PxHitFlag::eDISTANCE</code>被设置,
并且<code>distance</code>为0.</li>
<li><code>PxHitFlag::eNORMAL</code>被设置,
并且交点法线方向与射线方向相反.</li>
<li><code>PxHitFlag::ePOSITION</code>被设置,
并且<code>position (impact point)</code>设置为射线原点.</li>
</ul>
<p>如果射线的起点和终点与物体表面非常近,
它有可能被看做成<code>surface</code>的任何一边(<code>side</code>).</p>
<h2 id="向平面打射线">向平面打射线</h2>
<p>对于射线检测,
会把平面当做只有半个空间(<code>half-space</code>)的固体,
(和<code>overlap</code>不同, <strong>为什么不同?</strong>).
大多数情况下会返回一个结果, 如果射线原点在平面的后边,
即使射线和平面相交, 也不会有<code>hit</code>点.</p>
<p>如果射线的起始和结束点与平面非常接近,
它可能会被当做平面的任何一边.</p>
<h2
id="向triangle-meshes打射线">向<code>Triangle meshes</code>打射线</h2>
<p>把<code>triangle meshes</code>当做非常薄的三角形面而不是固体对象.
可以通过配置返回一个任意<code>hit</code>点,
或者很多个<code>hit</code>点.</p>
<ul>
<li>如果<code>maxHits</code>为1,
并且没有设置<code>PxHitFlag::eMESH_ANY</code>(或者<code>anyHit</code>为<code>true</code>),
查询将会返回最近的交点.</li>
<li>如果<code>maxHits</code>为1,
并设置了<code>PxHitFlag::eMESH_ANY</code>(并且<code>anyHit</code>为<code>false</code>),
查询将会返回任意<code>hit</code>点.
对于<code>line of sight</code>或者<code>shadow ray</code>而言,
使用它就可以完全可以知道射线是否<code>hit</code>到<code>mesh</code>.</li>
<li>如果如果<code>maxHit</code>大于1, 查询将会返回多个交点,
最多为<code>maxHits</code>个. 如果交点个数超过<code>maxHits</code>,
无法保证结果中包含最近的<code>hit</code>. 使用示例:
击中多个三角行的穿墙(<code>wall-piercing</code>)子弹,
或者要求特定的过滤. 注意,
在这些例子中必须使用<code>PxHitFlag::eMESH_MULTIPLE</code>.
还要注意如果<code>hit</code>点彼此非常接近,
<code>SDK</code>默认返回第一个<code>found</code>到的<code>hit</code>结果.</li>
</ul>
<table>
<tr>
<td bgcolor="#D5E8D4">
<span style="color:red;">通常<em>any hit</em> 比<em>closest hit</em>
更快, <em>closest hit</em> 比<em>multiple hits</em>更快, 即:<em>any
hit</em> 快于<em>closest hit</em> 快于<em>multiple hits</em>.
</span><br>
</td>
</tr>
</table>
<p>默认情况下, 背面<code>hits</code>(<code>back face hits</code>,
三角形外向法线和射线的点乘(<code>dot</code>)结果为负)会被剔除,
<del>所以对于任何命中上述法线的三角形, 与射线方向的点乘结果都为负</del>
如果三角形正面法线(<code>outward-face-normal</code>)与射线的点乘为负,
则<code>hit</code>点被剔除.</p>
<ul>
<li>如果<code>PxMeshGeometryFlag::eDOUBLE_SIDED</code>或者<code>PxHitFlag::eMESH_BOTH_SIDES</code>被设置,
则禁止剔除.</li>
<li>如果<code>PxMeshGeometryFlag::eDOUBLE_SIDED</code>被设置,
<code>back face hit</code>将会把最终结果的法线反转.</li>
</ul>
<p>这句话太难翻译直接贴原文了(<code>reported-normal</code>不知道怎么翻译):</p>
<blockquote>
<p>For example a transparent glass window could be modeled as a
double-sided mesh, so that a ray would hit either side with the reported
normal facing opposite to the ray direction. A raycast tracing the path
of a bullet that may penetrate the front side of a mesh and emerge from
the back could use <em>eMESH_BOTH_SIDES</em> to find both front and back
facing triangles even when the mesh is single-sided.</p>
<p>例如一个类型为<code>double-sided mesh</code>的玻璃窗, so that a ray
would hit either side with the reported normal facing opposite to the
ray direction. 有些子弹可以击穿mesh, 模拟这类子弹路径的射线,
可以使用<code>eMESH_BOTH_SIDES</code>来找正面和背面的三角形,
即使该mesh是<code>single-side</code>.</p>
</blockquote>
<p>下图展示了当单一射线和一个mesh在几个不同的地方相交时,
不同<code>flag</code>会发生什么.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/RayMeshDS_Permutations-1696640665770-28.png" /></p>
<p>只针对某些<code>mesh</code>使用<code>PxHitFlag::eMESH_BOTH_SIDES</code>标志位,
并且该<code>flag</code>在<code>PxQueryFilterCallback</code>中设置.</p>
<p>如果射线开始和结束的点和三角面非常接近,
可能会被当成三角形的任何一边(正面/背面).</p>
<h2 id="向heightfields打射线">向<code>Heightfields</code>打射线</h2>
<ul>
<li>处理<code>Heightfields</code>和<code>triangle meshes</code>不同,
<code>heightfields</code>会一直被当做<code>double side</code>,
意味着无论射线原点在<code>heightfileds surface</code>的上面或者下面,
最终的<code>hits</code>都会被注册.</li>
<li><code>hit normal</code>一直是<code>triangle hit</code>的法线,
当<code>thickness</code> <span class="math inline">\(&lt;=\)</span> 0,
朝向(在<code>heightfields</code>空间)<span
class="math inline">\(+y\)</span>方向; 当<code>thickness</code>大于0,
朝向(在<code>heightfields</code>空间)<span
class="math inline">\(-y\)</span>方向.</li>
<li>除了上述情况,
<code>heightfields thickness</code>对其他方面没有任何影响. 特殊的,
固体的<code>heightfield</code>部分不会生成<code>hit</code>.</li>
<li>当射线<code>hit</code> <code>heightfield</code>时候,
<code>UVs</code>不会被设置,
<code>PxHitFlag::eUV</code>标记也不会被设置.</li>
</ul>
<h1 id="overlap">overlap</h1>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/GeomQueryOverlap-1696640665770-30.png" /></p>
<p><code>overlap</code>查询只是简单的查询两个几何体是否重叠了.
其中一个几何体必须是<code>box</code>,<code>sphere</code>,<code>capsule</code>或者<code>凸多边形</code>,
另一个几何体可以使任意类型.</p>
<p>下面代码说明了如何使用<code>overlap</code>查询:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">bool isOverlapping</span> = overlap(geom0, pose0, geom1, pose1);</span><br></pre></td></tr></table></figure>
<p><code>overlap</code>不支持<code>hit flag</code>,
只是返回一个<code>bool</code>类型的结果.</p>
<ul>
<li>平面被当做<code>solid half-space</code>:
任何处于平面下的都被当做<code>volume</code>的一部分.</li>
<li><code>triangle mesh</code>被当做非常薄的三角形表面,
而不是固体对象.</li>
<li><code>heightfield</code>被当做由其厚度挤压成的三角形表面.
<code>overlap</code>几何体不会与<code>heightfield</code>相交,
但是挤压空间将会上报<code>hit</code></li>
</ul>
<p>如果对于<code>triagnle mesh</code>和<code>heightfield</code>类型不仅仅需要一个<code>bool</code>结果,
使用<a
href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/3.3.4/Manual/GeometryQueries.html#meshquery">PxMeshQuery</a>
API.</p>
<h1 id="penetration-depth">Penetration Depth</h1>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/GeomQueryPenetration-1696853091899-1.png" /></p>
<p>当两个对象相交,
<code>PhysX</code>能够计算通过平移将二者分开的最小距离和方向(分开的量涉及到<code>MTD</code>,
即: <code>最小平移距离(minimum translational distance)</code>,
通过平移将二者分开的长度最小的向量).
其中一个几何体必须是<code>box</code>, <code>sphere</code>,
<code>capsule</code>, 或者<code>convex mesh</code>,
另一个可以是任意类型.</p>
<p>如下代码阐述了如何使用<code>penetration depth</code>的查询:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isPenetrating = PxGeometryQuery::<span class="built_in">computePenetration</span>(direction, depth,</span><br><span class="line">                                                         geom0, pose0,</span><br><span class="line">                                                         geom1, pose1);</span><br></pre></td></tr></table></figure>
<p>参数解释如下:</p>
<ul>
<li><code>direction</code>:
第一个对象通过平移从第二个对象中脱离(<code>depenetrate</code>)出来的方向.</li>
<li><code>distance</code>:
第一个对象从第二个对象中脱离(<code>depenetrate</code>)出来的距离.</li>
<li><code>geom0</code>: 第一个几何体.</li>
<li><code>pos0</code>: 第一个几何体的<code>transform</code>.</li>
<li><code>geom1</code>:第二个几何体.</li>
<li><code>pos1</code>: 第二个几个题的<code>transform</code>.</li>
</ul>
<p>如果对象有渗入, 则返回<code>true</code>, 这种情况下,
会设置其方向和深度字段. 通过平移向量(<span
class="math inline">\(\vec{D}=\vec{Direction}*depth\)</span>)将二者分离开来.
如果函数返回<code>true</code>, <code>depth</code>一定<span
class="math inline">\(&gt;=0\)</span>.
如果几何体没有<code>overlap</code>, 函数返回<code>false</code>,
<code>direction</code>和<code>depth</code>都不会进行设置.</p>
<p>对于简单(<code>convex</code>)的形状, 返回结果是精确的.</p>
<p>对于<code>mesh</code>和<code>heightfields</code>,
在<code>PxExtensions</code>中, 将使用的循环算法和专用函数暴露出来了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PxVec3 direction = <span class="built_in">PxComputeMeshPenetration</span>(maxIter,</span><br><span class="line">                                            geom, geomPose,</span><br><span class="line">                                            meshGeom, meshPose,</span><br><span class="line">                                            nb);</span><br><span class="line"></span><br><span class="line">PxVec3 direction = <span class="built_in">PxComputeHeightFieldPenetration</span>(maxIter,</span><br><span class="line">                                                   geom, geomPose,</span><br><span class="line">                                                   heightFieldGeom, heightFieldPose,</span><br><span class="line">                                                   nb);</span><br></pre></td></tr></table></figure>
<p>这里, <code>maxIter</code>是算法的最大循环次数,
并且<code>nb</code>是真正的循环执行数量,
并且作为<code>output</code>变量输出出来.
如果检测没有<code>overlap</code>, <code>nb</code>将会被设置成0.
代码尝试至多<code>maxIter</code>此循环,
但是如果找到<code>depenetration</code>向量, 可能会提前返回. 通常,
<code>maxIter = 4</code>就会得出一个不错的结果.</p>
<p>这些函数只会计算出一个近似的<code>depenetration</code>向量,
当在几何体和<code>mesh/heightfield</code>之间的<code>overlap</code>数量比较小的时候,
会工作良好. 特别的, 当对象中心在三角形背面时, 将会忽略与三角形的交互.
如果所有相交的三角形都符合上述条件,
该函数将不会计算<code>MTD</code>向量.</p>
<h1 id="sweeps">Sweeps</h1>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/GeomQuerySweep-1696640665770-34.png" /></p>
<p><code>sweep query</code>追踪一个对象横穿空间的过程,
并找到在这个过程中与第二个几何体碰撞的点. 并且上报关于碰撞点的信息.
<code>PhysX</code>只支持第一个对象(贯穿空间的那个对象)为<code>sphere</code>,
<code>box</code>, <code>capsule</code>, 或者<code>convex</code>几何体,
第二个对象可以是任何类型.</p>
<p>下面的代码举例说明如何使用<code>sweep query</code>:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">PxSweepHit</span> hitInfo;</span><br><span class="line"><span class="title class_">PxHitFlags</span> hitFlags = <span class="title class_">PxHitFlag</span><span class="symbol">:</span><span class="symbol">:ePOSITION|PxHitFlag</span><span class="symbol">:</span><span class="symbol">:eNORMAL|PxHitFlag</span><span class="symbol">:</span><span class="symbol">:eDISTANCE</span>;</span><br><span class="line"><span class="title class_">PxReal</span> inflation = <span class="number">0</span>.0f;</span><br><span class="line"><span class="title class_">PxU32</span> hitCount = <span class="title class_">PxGeometryQuery</span><span class="symbol">:</span><span class="symbol">:sweep</span>(unitDir, maxDist,</span><br><span class="line">                                        geomToSweep, poseToSweep,</span><br><span class="line">                                        geomSweptAgainst, poseSweptAgainst,</span><br><span class="line">                                        hitInfo,</span><br><span class="line">                                        hitFlags,</span><br><span class="line">                                        inflation);</span><br></pre></td></tr></table></figure>
<p>这些参数解释如下:</p>
<ul>
<li><code>unitDir</code>: 定义<code>sweep</code>的单位向量.</li>
<li><code>maxDist</code>: 定义了沿着<code>sweep</code>查询的最大距离.
它必须在<span class="math inline">\([0, inf)\)</span>之间,
并且通过SDK会被限制在<code>PX_MAX_SWEEP_DISTANCE</code>之内.
当<code>sweep</code>距离为0时, 等价于<code>overlap</code>检测.</li>
<li><code>geomToSweep</code>: 将要<code>sweep</code>的几何体,
支持<code>box</code>, <code>sphere</code>, <code>capsule</code>,
或者<code>convex mesh</code>类型.</li>
<li><code>PosToSweep</code>:
用于<code>sweep</code>几何体的初始位置.</li>
<li><code>geomSweptAgainst</code>:
<code>sweep against</code>的几何体.</li>
<li><code>hitInfo</code>: 最终返回的结果.
一个<code>sweep</code>最多返回一个<code>hit</code>.</li>
<li><code>hitFlags</code>: 决定<code>sweep</code>将被如何处理,
如果发现<code>impact</code>点, 会返回对应的数据.</li>
<li><code>inflation</code>: 以对象表面向外扩展的方式膨胀第一个几何体,
并将所有角都做成圆角.
当使用<code>sweep</code>来测试<code>movement</code>是否可用时,
它用来保证几何体最小的空间边界.</li>
</ul>
<p>正如射线检测一样,
如果某个<code>flag</code>在<code>hitFlags</code>中设置,
在输出结构体对应的字段会被填充. <code>PxSweepHit</code>的字段如下:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">PxRigidActor*   actor<span class="comment">;</span></span><br><span class="line">PxShape*        shape<span class="comment">;</span></span><br><span class="line">PxVec3          position<span class="comment">;</span></span><br><span class="line">PxVec3          normal<span class="comment">;</span></span><br><span class="line">PxF32           distance<span class="comment">;</span></span><br><span class="line">PxHitFlags      flags<span class="comment">;</span></span><br><span class="line">PxU32           faceIndex<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>actor</code>和<code>shape</code>:
<code>actor</code>和<code>shape</code>不会被设置(这些字段只有在<code>scene-level sweep</code>中才会被使用,
详见: <a
href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/3.3.4/Manual/SceneQueries.html#scenequeries"><em>Scene
Queries</em></a>).</li>
<li><code>position</code>(<code>PxHitFlag::ePOSITION</code>):
交点的位置. 当有多个<code>impact</code>点时, 例如两个<code>box</code>,
面和面相撞, <code>physX</code>将任意选择一个点.
针对<code>meshes</code>或者<code>height fields</code>类型, 使用函数<a
href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/3.3.4/Manual/GeometryQueries.html#meshquery">PxMeshQuery</a>获取详细信息.</li>
<li><code>normal</code>(<code>PxHitFlag::eNORMAL</code>):<code>impact</code>点的表面法线.
他是一个单位向量, 指向被击中对象的外侧, 与<code>sweep</code>方向相反(即:
<code>sweep</code>方向和<code>impact</code>法线的点乘是负数.).</li>
<li><code>distance</code>(<code>PxHitFlag::eDISTANCE</code>):沿着射线方向,
物体与碰撞点的距离.</li>
<li><code>flag</code>: 指定结构体的哪些字段是可用的.</li>
<li><code>faceIndex</code>: <code>sweep hit</code>的面索引.
这个是被击中对象的面, 而不是<code>sweep</code>对象.
对于和<code>triangle mesh</code>和<code>heightfield</code>的<code>sweep</code>交点,
它是三角形顶点索引, 与<code>convex mesh</code>的交点,
它是多边形顶点索引. 对于其他类型, 它是0xffffffff.</li>
</ul>
<p>当<code>sweep</code>
<code>hit</code>到<code>triangle mesh</code>或者<code>convex mesh</code>,
返回的被选择的三角形如下:</p>
<ul>
<li>对于<code>convex</code>和<code>box</code> <code>sweep</code>,
选择距离最短的三角形.</li>
<li>对于<code>capsule</code>和<code>sphere</code>,
最短距离的三角形不一定会被选择, 最短距离在<span
class="math inline">\(10^{-3}f(即1e-3f)\)</span>范围内的都会被考虑,
选择法线(三角形的法线)方向与<code>sweep</code>方向几乎一致的三角形.
如果这些三角形法线相同, 会随机选择他们中的一个然后返回.</li>
</ul>
<p>这些例子中, <code>hit</code>点, 位置(<span
style="color:red;">例如两个<em>box</em>的面和面<code>sweep</code>会随机选择其中一个点</span>),
法线(<span
style="color:red;">对于<code>capsule</code>和<code>sphere</code>,
最短距离的三角形不一定会被选择, 最短距离在<span
class="math inline">\(10^{-3}f(即1e-3f)\)</span>范围内的都会被考虑,
选择法线(三角形的法线)方向与<code>sweep</code>方向几乎一致的三角形.
如果这些三角形法线相同,
会随机选择他们中的一个然后返回.</span>),都会影响最终选择哪个三角形.</p>
<p>与<code>raycast</code>不同, <code>sweep</code>不支持<code>u</code>,
<code>v</code>坐标.</p>
<p>对于几何对象的<code>sweep against</code>:</p>
<ul>
<li>平面被当做半个空间的固体,
也就是说任何在平面后面的物体多会被当做<code>volume</code>的一部分进行<code>sweep against</code>.</li>
<li>相同的背面剔除规则(应用在<code>raycast</code>上的)也会应用到<code>sweep</code>上,
需要注意的是,
不支持<code>eMESH_MULTIPLE</code>和<code>eMESH_BOTH_SIDES</code>.</li>
</ul>
<h2 id="initial-overlaps">Initial Overlaps</h2>
<p>和射线检测相似, 开始就在对象内部,
两个几何体<code>sweep</code>时候可能就已经相交了. 默认情况下,
<code>PhysX</code>会检测并上报<code>overlap</code>.
使用<code>PxSweepHit::hadInitialOverlap()</code>来查看<code>hit</code>是否是<code>initial overlap</code>生成的.</p>
<p>对于<code>triangle mesh</code>和<code>height field</code>,
背面剔除在<code>overlap check</code>之前执行,
因为如果<code>triangle</code>被剔除了,
就不会上报<code>overlap</code>事件了.</p>
<p><code>PhysX</code>是否计算<code>MTD</code>由<code>PxHitFlag::eMTD</code>决定.
如果<code>PxHitFlag::eMTD</code>没有被设置:</p>
<ul>
<li><code>distance</code>将被设置成0,
<code>PxHitFlag::eDISTANCE</code>也会在<code>PxSweepHit</code>结构体中设置.</li>
<li><code>normal</code>和<code>sweep</code>方向相反,
并且在结果<code>PxSweepHit</code>中<code>PxHitFlag::eNORMAL</code>会被设置.</li>
<li><code>position</code>不会被定义,
并且在结果<code>PxSweepHit</code>中<code>PxHitFlag::ePOSITION</code>不会被设置.</li>
<li><code>faceIndex</code>是第二个几何对象的面.
对于<code>heightfield</code>和<code>triangle mesh</code>,
他是第一个被发现的<code>overlap triangle</code>的索引. 对于其他几何类型,
将设置为<code>0xffffffff</code>.</li>
</ul>
<p>如果<code>PxHitFlag::eMTD</code>被设置,
<code>hit</code>结果的定义如下:</p>
<ul>
<li><code>distance</code>被设置成<code>penetrate</code>的深度,
<code>PxSweepHit</code>
中的<code>PxHitFlag::eDISTANCE</code>被设置.</li>
<li><code>normal</code>被设置成<code>penetrate</code>的方向,
<code>PxSweepHit</code>中的<code>PxHitFlag::eNORMAL</code>被设置.</li>
<li><code>position</code>为<code>sweep</code>几何对象上的一个点(即:第一个几何对象参数),
并且<code>PxSweepHit</code>中的<code>PxHitFlag::ePOSITION</code>会被设置.</li>
<li><code>faceIndex</code>是第二个几何对象上的面.
<ul>
<li>对于<code>convex mesh</code>, 它是最小<code>penetrate</code>的面.
如果<code>MTD</code>可以通过<code>edge</code>或者<code>convex</code>顶点分离对象,
将选择法线(面的法线)最接近分开方向的面.</li>
<li>对于<code>triangle mesh</code>和<code>heightfield</code>,
它是在<code>depenetration</code>算法最后一次循环中查找到的最后一个<code>penetrate</code>三角形.</li>
<li>对于其他几何类型,
<code>faceIndex</code>将会被设置成<code>0xffffffff</code>.</li>
</ul></li>
</ul>
<p>在<code>initial overlap</code>中, 这个标志将会带来额外负担的处理操作.
另外, 会启用如下限制:</p>
<ul>
<li><code>PxHitFlag::eMTD</code>与<code>PxHitFlag::ePRECISE_SWEEP</code>和<code>PxHitFlag::eASSUME_NO_INITIAL_OVERLAP</code>(见下文)不兼容.
<code>PxHitFlag::eMTD</code>与他们中的任何一个组合使用都会报错,
并且与<code>PxHitFlag::eMTD</code>不兼容的标志将被忽略.</li>
<li>在<code>PS3</code>中,
<code>PxHitFlag::eMTD</code>不支持<code>SPU(Power Processing Element) sweep</code>.
如果在<code>SPU sweep</code>中包含了<code>PxHitFlag::eMTD</code>,
将会报错.
<code>PPU(Synergistic Processing Elements)</code>完全支持<code>PxHitFlag::eMTD</code>.</li>
</ul>
<p>有时使用定制的代码路径测试<code>initial overlap</code>会带来性能消耗.
有必要保证几何对象不是<code>initially overlapping</code>,
<code>overlap</code>支持使用<code>PxHitFlag::eASSUME_NO_INITIAL_OVERLAP</code>进行检测.
有一些使用该<code>flag</code>的限制, 详见:<a
href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/3.3.4/Manual/GeometryQueries.html#sweep-pitfalls"><em>Pitfalls</em></a>.</p>
<ul>
<li>当<code>initial overlap</code>几何体处理未定义行为时,
会使用<code>PxHitFlag::eASSUME_NO_INITIAL_OVERLAP</code>标志.</li>
<li><code>PxHitFlag::eASSUME_NO_INITIAL_OVERLAP</code>与<code>zero sweep distance</code>组合使用会导致<code>warning</code>和<code>undefined behavior</code>.</li>
</ul>
<table>
<tr>
<td bgcolor="#D5E8D4">
注意:<br> 具有<em>PxHitFlag::eMTD</em>
flag的<em>sweep</em>使用两种针对三角形的背面剔除. 首先,
在<em>Sweep</em>方向上被剔除的三角形决定这是否是一个<em>overlap</em>.
如果检测到<em>overlap</em>,
他们会进一步检测<em>centroid(面心)</em>是否在三角形后面,
如果没找到三角形, <em>direction</em>将设置为<em>sweep
diection</em>的反方向, <em>distance</em>设置为0.
</td>
</tr>
</table>
<table>
<tr>
<td bgcolor="#D5E8D4">
注意:<br> 大多数情况下, 将第一个几何体平移<em>-normal*distance</em>距离,
会将对象分开. 尽管可以使用循环<em>depenetration</em>算法找到<em>triangle
mesh</em>和<em>height field</em>的<em>MTD</em>,
但是有些情况下<em>MTD</em>可能不会将mesh完全分离开. 这种情况下,
在应用平移后, 要调用第二次查询.
</td>
</tr>
</table>
<table>
<tr>
<td bgcolor="#D5E8D4">
注意:<br> 在<em>PhysX
3.3</em>中一个已知的问题是当<em>eMTD</em>没有设置时, <em>sweep against
convex mesh</em>的<em>face index</em>是<em>undefined</em>
</td>
</tr>
</table>
<h2 id="precise-sweeps">Precise Sweeps</h2>
<p><code>PxHitFlag::ePRECISE_SWEEP</code>允许更加精确的<code>sweep</code>代码(默认情况下使用更快的但是精度不高的解决方案).
<code>PxHitFlag::ePRECISE_SWEEP</code>和<code>inflation</code>和<code>PxHitFlag::eMTD</code>不兼容.</p>
<h2 id="sweeps-against-height-fields">Sweeps against Height Fields</h2>
<ul>
<li><code>Height field</code>被当做很薄的三角形面, 而不是固体对象.</li>
<li>厚度不会影响<code>initial overlap</code>检测和点的碰撞.</li>
<li>对于<code>single height field</code>, 如果厚度小于0,
<code>hit</code>的法线方向为本地坐标系中的<code>+Y</code>方向,
如果厚度大于0,
<code>hit</code>的法线方向为本地坐标系中的<code>-Y</code>方向.</li>
<li>如果设置了<code>eDOUBLE_SIDED</code>或者<code>eMESH_BOTH_SIDES</code>,
<code>height field</code>将被认为是双面的.
<ul>
<li>返回的<code>hit</code>会一直朝向<code>sweep</code>方向.</li>
</ul></li>
<li><code>eMESH_ANY</code>不起作用.</li>
<li><code>ePRECISE_SWEEP</code>不起作用.</li>
</ul>
<h2 id="pitfalls">Pitfalls</h2>
<p>在使用<code>sweep</code>时候需要注意一些隐患:</p>
<ul>
<li>由于精度问题, 当两个对象有非常巨大的大小差异, 会返回错误的结果.</li>
<li>由于算法不同,
<code>sweep query</code>可能不仅仅检测到一个<code>overlap</code>查询,
而是会检测一个不同的<code>overlapping</code>形状的初始化集合.
执行一个<code>overlap check</code>还不足以判定<code>PxHitFlag::eIGNORE_INITIAL_OVERLAP</code>标志位的安全性,
需要一系列的<code>overlap/sweep/penetration depth</code>信息的应用程序应该使用带有<code>initial overlap testing</code>和<code>PxHitFlag::eMTD</code>标志的<code>sweep check</code>.</li>
</ul>
<h1 id="additional-pxgeometryquery-functions">Additional PxGeometryQuery
functions</h1>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/GeomQueryPointDistance-1696643163649-41.png" /></p>
<p>下面的函数计算点和几何体之间的距离. 只支持<code>box</code>,
<code>sphere</code>,
<code>capsule</code>和<code>convex shape</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PxReal dist = PxGeometryQuery::<span class="built_in">pointDistance</span>(point, geom, pose, closestPoint);</span><br></pre></td></tr></table></figure>
<p><code>closestPoint</code>是一个可选地输出参数, 它返回最近的点.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/GeomQueryWorldBounds-1696643311796-44.png" /></p>
<p>下面的函数计算几何体轴对齐的包围盒(<code>AABB</code>),
并返回它的姿态.</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">PxBounds3 bounds = PxGeometryQuery::get<span class="constructor">WorldBounds(<span class="params">geom</span>, <span class="params">pose</span>, <span class="params">inflation</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><code>AABB</code>包围盒被<code>inflation</code>缩放,
如果没有显式指定, 它的值为`<code>1.01f</code>.</p>
<h1 id="pxmeshquery">PxMeshQuery</h1>
<p>对于<code>triangle mesh</code>, <code>height field overlap</code>,
以及对<code>triangle</code>数组的<code>sweep</code>,
<code>PhysX</code>提供额外的函数可以获得多个结果.
只有<code>boxes</code>, <code>spheres</code>,
<code>capsules</code>与<code>mesh</code>或<code>heightFields</code>被测试的时候使用这些函数.</p>
<h2 id="mesh-overlaps">Mesh Overlaps</h2>
<p>下面的代码举例说明了如何处理<code>mesh triangle</code>与给定球状体积:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PxU32 triangleIndexBuffer[bufferSize];</span><br><span class="line">PxU32 startIndex = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> bufferOverflowOccured = <span class="literal">false</span>;</span><br><span class="line">PxU32 nbTriangles = PxMeshQuery::<span class="built_in">findOverlapTriangleMesh</span>(sphereGeom, spherePose,</span><br><span class="line">                                                         meshGeom, meshPose,</span><br><span class="line">                                                         triangleIndexBuffer, bufferSize,</span><br><span class="line">                                                         startIndex, bufferOverflowOccured);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(PxU32 i=<span class="number">0</span>; i &lt; nbTriangles; i++)</span><br><span class="line">&#123;</span><br><span class="line">    PxTriangle tri;</span><br><span class="line">    PxU32 vertexIndices[<span class="number">3</span>];</span><br><span class="line">    PxMeshQuery::<span class="built_in">getTriangle</span>(meshGeom, meshPose, triangleIndexBuffer[i], tri, vertexIndices);</span><br><span class="line"></span><br><span class="line">     ...  <span class="comment">// process triangle info</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findOverlapTriangleMesh</code>函数用于额外提取三角形索引.</p>
<ul>
<li><code>sphereGeom</code>和<code>spherePose</code>指定<code>overlap</code>的区域.</li>
<li><code>meshGeom</code>和<code>meshPose</code>指定<code>mesh</code>和它的姿态.</li>
<li><code>triangleIndexBuffer</code>和<code>triangleSize</code>指定<code>buffer</code>以及<code>buffer</code>的大小.</li>
<li>当<code>buffer</code>溢出时,
<code>startIndex</code>用于重新启动查询. 在这里例子中,
为了查询更多的三角形集合, 将该参数设置为目前已检索的数量.</li>
<li>当查询的结果超过<code>buffer</code>的大小,
会设置<code>bufferOverflowOccured</code>标志位.</li>
</ul>
<p><code>height field</code>也存在类似的查询函数.</p>
<h2 id="sweeps-against-triangles">Sweeps against Triangles</h2>
<p>有时候, 例如, 当使用<code>mesh overlap API</code>时,
它会很方便的与一组三角形进行<code>sweep</code>. 为此,
<code>PhysX</code>提供指定的函数. 函数签名如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sweep</span><span class="params">(<span class="type">const</span> PxVec3&amp; unitDir,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> PxReal distance,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> PxGeometry&amp; geom,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> PxTransform&amp; pose,</span></span></span><br><span class="line"><span class="params"><span class="function">           PxU32 triangleCount,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> PxTriangle* triangles,</span></span></span><br><span class="line"><span class="params"><span class="function">           PxSweepHit&amp; sweepHit,</span></span></span><br><span class="line"><span class="params"><span class="function">           PxHitFlags hitFlags = PxHitFlag::eDEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> PxU32* cachedIndex = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> PxReal inflation = <span class="number">0.0f</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">bool</span> doubleSided = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数解释如下:</p>
<ul>
<li><code>unitDir</code>, <code>distance</code>,
<code>geom</code>和<code>pose</code>与<code>PxGeometryQuery::sweep()</code>函数头四个参数一样.
<code>distance</code>的范围限制在<code>PX_MAX_SWEEP_DISTANCE</code>之内.</li>
<li><code>triangleCount</code>为包含在<code>buffer</code>中的三角形数量.</li>
<li><code>triangles</code>为三角形的<code>buffer</code>.</li>
<li><code>hitFlags</code>指定输出所需信息.</li>
<li><code>cachedIndex</code>, 如果设置了,
则该值表示第一个测试的三角形索引.
当重复的与三角形集合<code>sweep</code>时, 它非常有用.</li>
<li><code>inflation</code>与函数<code>PxGeometryQuery::sweep()</code>中的<code>inflation</code>参数一致.</li>
<li><code>doubleSided</code>表示输入的三角形是否为<code>double-side</code>.
它和<code>PxMeshGeometryFlag::eDOUBLE_SIDED</code>标志是等价的.
它支持背面剔除, 对于任何<code>hit</code>,
返回的面法线与<code>sweep</code>方向相反(详见:<a
href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/3.3.4/Manual/GeometryQueries.html#raycasts-vs-meshes"><em>Raycasts
against Triangle Meshes</em></a>).</li>
</ul>
<p>与其他查询相比, 该函数有额外的限制:</p>
<ul>
<li>几何体类型必须是<code>sphere</code>,
<code>capsule</code>或者<code>box</code>.
不支持<code>convex</code>几何体.</li>
<li>该函数返回单一<code>hit</code>.
不支持<code>multiple hits</code>(尤其是<code>PxHitFlag::eMESH_MULTIPLE</code>).</li>
<li>该函数总是返回最近的点.</li>
<li>只支持 <code>PxHitFlag::eASSUME_NO_INITIAL_OVERLAP</code>,
<code>PxHitFlag::ePRECISE_SWEEP</code>和<code>PxHitFlag::eMESH_BOTH_SIDES</code>.</li>
<li>在返回的<code>PxSweepHit</code>结构体中,
不会设置有效标志位(<code>PxHitFlag::ePOSITION</code>,
<code>PxHitFlag::eNORMAL</code>, <code>PxHitFlag::eDISTANCE</code>,
<code>PxHitFlag::eUV</code>)</li>
</ul>
]]></content>
      <categories>
        <category>翻译</category>
        <category>PhysX</category>
        <category>Geometry Queries</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>PhysX</tag>
        <tag>Geometry Queries</tag>
      </tags>
  </entry>
  <entry>
    <title>Pawn,Controller和PawnMovementComponent Tick顺序</title>
    <url>/2023/11/09/UE/%E7%A7%BB%E5%8A%A8/Pawn,Controller%E5%92%8CPawnMovementComponent%20Tick%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>执行顺序:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231016110608952.png" /></p>
<p>注意,
<code>UMovementComponent.bTickBeforeOwner</code>默认为<code>true</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231016112629392.png" /></p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AController::AddPawnTickDependency</span><span class="params">(APawn* NewPawn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (NewPawn != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> bNeedsPawnPrereq = <span class="literal">true</span>;</span><br><span class="line">        UPawnMovementComponent* PawnMovement = NewPawn-&gt;<span class="built_in">GetMovementComponent</span>();</span><br><span class="line">        <span class="keyword">if</span> (PawnMovement &amp;&amp; PawnMovement-&gt;PrimaryComponentTick.bCanEverTick)</span><br><span class="line">        &#123;</span><br><span class="line">            PawnMovement-&gt;PrimaryComponentTick.<span class="built_in">AddPrerequisite</span>(<span class="keyword">this</span>, <span class="keyword">this</span>-&gt;PrimaryActorTick);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don&#x27;t need a prereq on the pawn if the movement component already sets up a prereq.</span></span><br><span class="line">            <span class="keyword">if</span> (PawnMovement-&gt;bTickBeforeOwner || NewPawn-&gt;PrimaryActorTick.<span class="built_in">GetPrerequisites</span>().<span class="built_in">Contains</span>(<span class="built_in">FTickPrerequisite</span>(PawnMovement, PawnMovement-&gt;PrimaryComponentTick)))</span><br><span class="line">            &#123;</span><br><span class="line">                bNeedsPawnPrereq = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bNeedsPawnPrereq)</span><br><span class="line">        &#123;</span><br><span class="line">            NewPawn-&gt;PrimaryActorTick.<span class="built_in">AddPrerequisite</span>(<span class="keyword">this</span>, <span class="keyword">this</span>-&gt;PrimaryActorTick);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMovementComponent::RegisterComponentTickFunctions</span><span class="params">(<span class="type">bool</span> bRegister)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">RegisterComponentTickFunctions</span>(bRegister);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Super may start up the tick function when we don&#x27;t want to.</span></span><br><span class="line">    <span class="built_in">UpdateTickRegistration</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the owner ticks, make sure we tick first</span></span><br><span class="line">    AActor* Owner = <span class="built_in">GetOwner</span>();</span><br><span class="line">    <span class="keyword">if</span> (bTickBeforeOwner &amp;&amp; bRegister &amp;&amp; PrimaryComponentTick.bCanEverTick &amp;&amp; Owner &amp;&amp; Owner-&gt;<span class="built_in">CanEverTick</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Owner-&gt;PrimaryActorTick.<span class="built_in">AddPrerequisite</span>(<span class="keyword">this</span>, PrimaryComponentTick);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上可以看出,
<code>Controller Tick</code>始终排在<code>PawnTick</code>和<code>PawnMovementTick</code>之前.
如果<code>UMovementComponent.bTickBeforeOwner</code>为<code>true</code>,
则先执行<code>PawnMovementTick</code>再执行<code>PawnTick</code>,
否则<code>PawnTick</code>先执行,
<code>PawnMovementTick</code>后执行.</p>
<p><code>Actor</code>和<code>Component</code>的Tick注册顺序.
当<code>UMovementComponent.bTickBeforeOwner</code>为<code>false</code>时,
<code>PawnTick</code>先执行, <code>PawnMovementTick</code>后执行.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pawn,Controller和PawnMovementComponent Tick顺序</span></span><br><span class="line">--AActor.BeginPlay</span><br><span class="line">|--<span class="comment">// 注册Actor自身tick</span></span><br><span class="line">|--AActor.<span class="built_in">RegisterAllActorTickFunctions</span>()</span><br><span class="line">| |--AActor.<span class="built_in">RegisterActorTickFunctions</span>()</span><br><span class="line">| | |--PrimaryActorTick.<span class="built_in">SetTickFunctionEnable</span>()</span><br><span class="line">| | |--PrimaryActorTick.<span class="built_in">RegisterTickFunction</span>()</span><br><span class="line">|--<span class="comment">// 针对所有Components, 都执行RegisterTick</span></span><br><span class="line">|--UActorComponent.<span class="built_in">RegisterAllComponentTickFunctions</span>()</span><br><span class="line">| |--UCharacterMovementComponent.<span class="built_in">RegisterComponentTickFunctions</span>()</span><br><span class="line">| | |--UMovementComponent.<span class="built_in">RegisterComponentTickFunctions</span>()</span><br><span class="line">| | | |--UActorComponent.<span class="built_in">RegisterComponentTickFunctions</span>()</span><br><span class="line">| | | | |--UActorComponent.<span class="built_in">SetupActorComponentTickFunction</span>()</span><br><span class="line">| | | | | |--TickFunction-&gt;<span class="built_in">SetTickFunctionEnable</span>()</span><br><span class="line">| | | | | |--TickFunction-&gt;<span class="built_in">RegisterTickFunction</span>()</span><br><span class="line">| |--Component-&gt;<span class="built_in">BeginPlay</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UE4</category>
        <category>Tick</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Tick</tag>
        <tag>Pawn,Controller和PawnMovementComponent Tick顺序</tag>
      </tags>
  </entry>
</search>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fdcumt.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":true,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="image-20231119110314263">
<meta property="og:type" content="article">
<meta property="og:title" content="InitOnly RPC MulticastRPC(Reliable+Unreliable) BeginPlay的执行顺序">
<meta property="og:url" content="https://fdcumt.github.io/2024/05/15/UE/%E7%BD%91%E7%BB%9C/InitOnly%20RPC%20MulticastRPC%20BeginPlay%E7%9A%84%E9%A1%BA%E5%BA%8F/index.html">
<meta property="og:site_name" content="NoBodyNoOne">
<meta property="og:description" content="image-20231119110314263">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fdcumt.github.io/2024/05/15/UE/%E7%BD%91%E7%BB%9C/InitOnly%20RPC%20MulticastRPC%20BeginPlay%E7%9A%84%E9%A1%BA%E5%BA%8F/assets/image-20231118180041065.png">
<meta property="article:published_time" content="2024-05-15T02:54:53.748Z">
<meta property="article:modified_time" content="2024-04-30T06:45:06.200Z">
<meta property="article:author" content="NoBodyNoOne">
<meta property="article:tag" content="UE网络">
<meta property="article:tag" content="NetworkGUID">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fdcumt.github.io/2024/05/15/UE/%E7%BD%91%E7%BB%9C/InitOnly%20RPC%20MulticastRPC%20BeginPlay%E7%9A%84%E9%A1%BA%E5%BA%8F/assets/image-20231118180041065.png">


<link rel="canonical" href="https://fdcumt.github.io/2024/05/15/UE/%E7%BD%91%E7%BB%9C/InitOnly%20RPC%20MulticastRPC%20BeginPlay%E7%9A%84%E9%A1%BA%E5%BA%8F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://fdcumt.github.io/2024/05/15/UE/%E7%BD%91%E7%BB%9C/InitOnly%20RPC%20MulticastRPC%20BeginPlay%E7%9A%84%E9%A1%BA%E5%BA%8F/","path":"2024/05/15/UE/网络/InitOnly RPC MulticastRPC BeginPlay的顺序/","title":"InitOnly RPC MulticastRPC(Reliable+Unreliable) BeginPlay的执行顺序"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>InitOnly RPC MulticastRPC(Reliable+Unreliable) BeginPlay的执行顺序 | NoBodyNoOne</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">NoBodyNoOne</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">白驹过隙</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%BC%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">导言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#beginplay%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">BeginPlay执行顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#spawnactor"><span class="nav-number">2.1.1.</span> <span class="nav-text">SpawnActor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spawnactorabsolute"><span class="nav-number">2.1.2.</span> <span class="nav-text">SpawnActorAbsolute</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">延迟原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spawnactordeferredfinishspawning"><span class="nav-number">2.1.3.</span> <span class="nav-text">SpawnActorDeferred+FinishSpawning</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#initonly%E5%8F%8A%E5%85%B6onrep%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">InitOnly及其OnRep执行顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#onrep%E4%B8%BA%E4%BD%95%E7%89%A9"><span class="nav-number">2.2.1.</span> <span class="nav-text">OnRep为何物</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E5%BB%BAonrep%E4%BF%A1%E6%81%AF"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">构建OnRep信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onrep%E8%AE%BE%E7%BD%AE%E5%9B%9E%E8%B0%83%E5%92%8C%E6%B8%85%E7%90%86"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">OnRep设置,回调和清理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initonly%E4%B8%BA%E4%BD%95%E7%89%A9"><span class="nav-number">2.2.2.</span> <span class="nav-text">InitOnly为何物</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initonly%E7%9A%84onrep%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.3.</span> <span class="nav-text">InitOnly的OnRep流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%90%AFnet.allowasyncloading"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">开启net.AllowAsyncLoading</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E5%BC%80%E5%90%AFnet.allowasyncloading"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">未开启net.AllowAsyncLoading</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9D%9E%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84initonly"><span class="nav-number">2.2.4.</span> <span class="nav-text">指针类型和非指针类型的InitOnly</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96actor"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">反序列化Actor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96actor%E5%86%85%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">初始化Actor内属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#actorcomponent%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">ActorComponent序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96actorcomponent%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.4.4.</span> <span class="nav-text">初始化ActorComponent属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aactor.postnetinit"><span class="nav-number">2.2.4.5.</span> <span class="nav-text">AActor.PostNetInit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.2.4.6.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rpc%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.3.</span> <span class="nav-text">RPC执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multicastrpc-reliable%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.4.</span> <span class="nav-text">MulticastRPC Reliable执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multicastrpc-unreliable%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.5.</span> <span class="nav-text">MulticastRPC Unreliable执行顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#actor%E6%83%85%E5%BD%A2"><span class="nav-number">3.</span> <span class="nav-text">Actor情形</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#default-sub-actorcomponent%E6%83%85%E5%BD%A2"><span class="nav-number">4.</span> <span class="nav-text">Default Sub ActorComponent情形</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%89%E9%9C%80%E5%88%9B%E5%BB%BA%E7%9A%84subactorcomponent%E6%83%85%E5%BD%A2"><span class="nav-number">5.</span> <span class="nav-text">按需创建的SubActorComponent情形</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">5.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E8%A8%80"><span class="nav-number">7.</span> <span class="nav-text">附言</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">NoBodyNoOne</p>
  <div class="site-description" itemprop="description">欢迎来到我的世界</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/fdcumt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fdcumt" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/fdcumt" title="知 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;fdcumt" rel="noopener me" target="_blank"><i class="fa zhihu fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fdcumt.github.io/2024/05/15/UE/%E7%BD%91%E7%BB%9C/InitOnly%20RPC%20MulticastRPC%20BeginPlay%E7%9A%84%E9%A1%BA%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="NoBodyNoOne">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NoBodyNoOne">
      <meta itemprop="description" content="欢迎来到我的世界">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="InitOnly RPC MulticastRPC(Reliable+Unreliable) BeginPlay的执行顺序 | NoBodyNoOne">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          InitOnly RPC MulticastRPC(Reliable+Unreliable) BeginPlay的执行顺序
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-15 10:54:53" itemprop="dateCreated datePublished" datetime="2024-05-15T10:54:53+08:00">2024-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-30 14:45:06" itemprop="dateModified" datetime="2024-04-30T14:45:06+08:00">2024-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/UE/UE%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">UE网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/UE/UE%E7%BD%91%E7%BB%9C/%E6%97%B6%E5%BA%8F/" itemprop="url" rel="index"><span itemprop="name">时序</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231119110314263.png"
alt="image-20231119110314263" />
<figcaption aria-hidden="true">image-20231119110314263</figcaption>
</figure>
<span id="more"></span>
<h1 id="导言">导言</h1>
<p>需要验证的情况大致分成两类,
开启/未开启<code>net.AllowAsyncLoading</code>,
每类又包含如下细分情况:</p>
<ol type="1">
<li><p><code>SpawnActor</code>, <code>BeginPlay</code>,
<code>InitOnly</code> <code>RPC</code>
<code>MulticastRPC(Reliable+Unreliable)</code>的详细流程</p></li>
<li><p>针对<code>Actor</code>本身, <code>InitOnly</code>
<code>RPC</code> <code>MulticastRPC(Reliable+Unreliable)</code>
<code>BeginPlay</code>的执行顺序</p>
<ul>
<li><p>动态创建的<code>Actor</code></p></li>
<li><p>场景中摆放的<code>Actor</code></p></li>
</ul></li>
<li><p>针对非指针类型的变量, 例如<code>int32</code>,
<code>float</code>等.</p></li>
<li><p>针对指针类型<code>Replicate</code>变量:</p>
<ul>
<li>指针对象已经存在.</li>
<li>指针对象不存在.</li>
<li>特殊的, 要详细说明以下类型:
<ul>
<li>针对<code>Default Sub ActorComponent</code>, <code>InitOnly</code>
<code>RPC</code> <code>MulticastRPC(Reliable+Unreliable)</code>
<code>BeginPlay</code>的执行顺序</li>
<li>针对按需创建的<code>SubActorComponent</code>, <code>InitOnly</code>
<code>RPC</code> <code>MulticastRPC(Reliable+Unreliable)</code>
<code>BeginPlay</code>的执行顺序</li>
</ul></li>
</ul></li>
</ol>
<h1 id="前置知识">前置知识</h1>
<p>想要了解清楚上述各种情况下的执行顺序,
必须先搞清楚<code>BeginPlay</code>, <code>InitOnly</code>,
<code>RPC</code>,
<code>MulticastRPC(Reliable+Unreliable)</code>自身的执行顺序,
然在再将情况变得复杂, 即<code>控制变量法</code>:先了解清楚简单情况,
再加入各种变量, 逐步扩延展到各种复杂情况.</p>
<h2 id="beginplay执行顺序"><code>BeginPlay</code>执行顺序</h2>
<p>官方给出的<code>Actor</code>生命周期中<code>BeginPlay</code>所处的时机(<a
target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/ActorLifecycle/">Actor
生命周期</a>).</p>
<figure>
<img
src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/ActorLifecycle/ActorLifeCycle1.jpg"
alt="ActorLifeCycle.png" />
<figcaption aria-hidden="true">ActorLifeCycle.png</figcaption>
</figure>
<p>UE中有三种SpawnActor的方法, 针对这三种创建Actor的方式,
依次查看其BeginPlay的时机.</p>
<ol type="1">
<li>主动创建:UWorld.SpawnActor</li>
<li>网络同步过来需要创建的Actor: SpawnActorAbsolute</li>
<li>UWorld.SpawnActorDeferred+AActor.FinishSpawning</li>
</ol>
<h3 id="spawnactor"><code>SpawnActor</code></h3>
<p>DS端, 主动使用<code>UWorld.SpawnActor</code>创建<code>Actor</code>,
<code>Actor</code>和<code>DefaultSubActorComponent</code>的<code>BeginPlay</code>执行顺序.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113162832584.png" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALSV: ATestRepFlowActor::ATestRepFlowActor FrameIndex[<span class="number">1113</span>] RoleType[ROLE_Authority]</span><br><span class="line">ALSV: UTestRepFlowDefaultCmp::BeginPlay FrameIndex[<span class="number">1113</span>] RoleType[ROLE_Authority] Owner[BPTestRepFlowSpawnedActor_C_0]</span><br><span class="line">ALSV: ATestRepFlowActor::BeginPlay FrameIndex[<span class="number">1113</span>] RoleType[ROLE_Authority]</span><br></pre></td></tr></table></figure>
<p>从日志上可以看出,
在<code>DS</code>端执行顺序为:<code>UTestRepFlowDefaultCmp::BeginPlay</code>-&gt;<code>ATestRepFlowActor::BeginPlay</code>.
详细堆栈为:</p>
<table>
<tr>
<td bgcolor="#D5E8D4">
<p style="line-height:1.5;">
创建Actor的BeginPlay堆栈+DefaultSubComp BeginPlay的堆栈 <br>
--UWorld.SpawnActor <br> |--UWorld.SpawnActor <br> |
|--AActor.PostSpawnInitialize.if <br> | | |--<span
style="color:red;">AActor.FinishSpawning //
这个函数可以独立出来执行</span> <br> | | |
|--AActor.PostActorConstruction <br> | | | | |--AActor.DispatchBeginPlay
<br> | | | | | |--ATestRepFlowSpawnedActor.BeginPlay <br> | | | | | |
|--AActor.BeginPlay <br> | | | | | | | |--// for all components
BeginPlay <br> | | | | | | | |--UTestRepFlowDefaultCmp.BeginPlay &lt;br
</p>
</td>
</tr>
</table>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231114093421518.png" /></p>
<h3 id="spawnactorabsolute"><code>SpawnActorAbsolute</code></h3>
<p>当网络数据中需要创建Actor, 则会调用该函数进行创建. 详细堆栈:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远端, 根据Bunch被动创建, 不会立即执行BeginPlay, 而是等待处理完这个Bunch的所有消息才执行BeginPlay</span></span><br><span class="line">--UActorChannel.ProcessBunch.<span class="keyword">if</span> </span><br><span class="line">|--UPackageMapClient.SerializeNewActor</span><br><span class="line">| |--UWorld.SpawnActorAbsolute </span><br><span class="line">| | |--UWorld.SpawnActor </span><br><span class="line">| | | |--AActor.PostSpawnInitialize.<span class="keyword">if</span> </span><br><span class="line">| | | | |--AActor.FinishSpawning.<span class="keyword">if</span>.&#123; </span><br><span class="line">| | | | | |--AActor.PostActorConstruction</span><br><span class="line">| | | | | | |--<span class="comment">// 对于根据Bunch创建的Actor, 不会立即执行BeginPlay</span></span><br><span class="line">| | | | | | |--<span class="type">const</span> <span class="type">bool</span> bDeferBeginPlayAndUpdateOverlaps = (bExchangedRoles &amp;&amp; RemoteRole == ROLE_Authority) &amp;&amp; !GIsReinstancing;</span><br><span class="line">| | | | | | |--<span class="type">bool</span> bRunBeginPlay = !bDeferBeginPlayAndUpdateOverlaps &amp;&amp; (BeginPlayCallDepth &gt; <span class="number">0</span> || World-&gt;<span class="built_in">HasBegunPlay</span>());</span><br><span class="line">|--<span class="comment">// 处理Bunch中ContentBlock内容</span></span><br><span class="line">|--<span class="comment">// After all properties have been initialized, call PostNetInit. This should call BeginPlay() so initialization can be done with proper starting values.</span></span><br><span class="line">|--<span class="keyword">if</span> (Actor &amp;&amp; bSpawnedNewActor)</span><br><span class="line">|--&#123;</span><br><span class="line">|--    <span class="built_in">SCOPE_CYCLE_COUNTER</span>(Stat_PostNetInit);</span><br><span class="line">|--    Actor-&gt;<span class="built_in">PostNetInit</span>();</span><br><span class="line">| |--<span class="comment">// 如果Actor没有执行BeginPlay, 就会执行BeginPlay</span></span><br><span class="line">| |--AActor.DispatchBeginPlay </span><br><span class="line">| | |--AActor.BeginPlay </span><br><span class="line">| | | |--ATestRepFlowSpawnedActor.BeginPlay </span><br><span class="line">| | |--AActor.UpdateInitialOverlaps </span><br><span class="line">|--&#125;</span><br></pre></td></tr></table></figure>
<p>UE针对依据Bunch创建的Actor, 特意将BeginPlay延迟. 但是可以看出,
即使延迟执行BeginPlay, 但是Actor和Components也立即进行了Initialize.
即调用了<code>AActor.PreInitializeComponents</code>和<code>AActor.InitializeComponents</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231114102401410.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231114202232062.png" /></p>
<h4 id="延迟原因">延迟原因</h4>
<p>最早的版本就这样, 已经无法再查了. 再查就要往UE3查了.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116152504482.png" /></p>
<h3
id="spawnactordeferredfinishspawning"><code>SpawnActorDeferred+FinishSpawning</code></h3>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231115172952165.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231115173239392.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231115173340401.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231115173715899.png" /></p>
<p>从上图可以清晰看到,
<code>SpawnActorDeferred</code>不会调用<code>FinishSpawning</code>,
也就不会初始化Actor Components, 以及调用BeginPlay了.
<code>FinishSpawning</code>需要手动调用, 即逻辑分开,
UE提供了另一种方式供大家使用, 以便满足千变万化的需求.</p>
<h2
id="initonly及其onrep执行顺序"><code>InitOnly</code>及其<code>OnRep</code>执行顺序</h2>
<h3 id="onrep为何物"><code>OnRep</code>为何物</h3>
<p>OnRep为何物, 依据什么填充的, 又是怎么触发回调的, 以及怎么清除的?</p>
<h4 id="构建onrep信息">构建OnRep信息</h4>
<p>在Replayout中构建需要同步属性的Onrep信息,
<code>RepNotifyCondition</code>+<code>RepNotifyNumParams</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replayout中OnRep相关设置初始化流程</span></span><br><span class="line">--FRepLayout.InitFromClass </span><br><span class="line">|--<span class="comment">// 遍历所有LifetimeProps, 设置其RepNotifyCondition和RepNotifyNumParams</span></span><br><span class="line">|--Parents[ParentIndex].RepNotifyCondition = LifetimeProps[i].RepNotifyCondition;</span><br><span class="line">|--<span class="keyword">if</span> (UFunction* RepNotifyFunc = InObjectClass-&gt;<span class="built_in">FindFunctionByName</span>(Parents[ParentIndex].Property-&gt;RepNotifyFunc))</span><br><span class="line">|--&#123;</span><br><span class="line">|--    Parents[ParentIndex].RepNotifyNumParams = RepNotifyFunc-&gt;NumParms;</span><br><span class="line">|--&#125;</span><br></pre></td></tr></table></figure>
<h4 id="onrep设置回调和清理">OnRep设置,回调和清理</h4>
<p>在客户端收到DS发来的Bunch解析后, 设置属性内容, 并记录其OnRep信息.
如果需要OnRep, 则放入<code>FReceivingRepState.RepNotifies</code>中.
佐证代码:</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118125441054.png"
alt="image-20231118125441054" />
<figcaption aria-hidden="true">image-20231118125441054</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnRep设置以及回调堆栈</span></span><br><span class="line">--UNetDriver.TickFlush.<span class="keyword">if</span> </span><br><span class="line">|--UIpConnection.Tick </span><br><span class="line">| |--UNetConnection.Tick.<span class="keyword">else</span>.<span class="keyword">if</span>.<span class="keyword">for</span> </span><br><span class="line">| | |--UActorChannel.ProcessQueuedBunches.<span class="keyword">if</span>.<span class="keyword">if</span>.<span class="keyword">for</span> </span><br><span class="line">| | | |--UActorChannel.ProcessBunch.<span class="keyword">while</span> </span><br><span class="line">| | | | |--FObjectReplicator.ReceivedBunch.<span class="keyword">if</span> </span><br><span class="line">| | | | | |--FRepLayout.ReceiveProperties </span><br><span class="line">| | | | | | |--ReceiveProperties_r.<span class="keyword">for</span>.<span class="keyword">else</span>.<span class="keyword">else</span> </span><br><span class="line">| | | | | | | |--ReceivePropertyHelper.<span class="keyword">if</span> </span><br><span class="line">| | | | | | | | |--<span class="comment">// Read the property</span></span><br><span class="line">| | | | | | | | |--Cmd.Property-&gt;<span class="built_in">NetSerializeItem</span>(Bunch, Bunch.PackageMap, Data + SwappedCmd);</span><br><span class="line">| | | | | | | | |--<span class="comment">// 如果需要, 则将Property放入RepNotify中</span></span><br><span class="line">| | | | | | | | |--RepNotifies-&gt;<span class="built_in">AddUnique</span>(Parent.Property);</span><br><span class="line">| | |--UActorChannel.ProcessQueuedBunches.<span class="keyword">if</span>.<span class="keyword">if</span> </span><br><span class="line">| | | |--FObjectReplicator.CallRepNotifies </span><br><span class="line">| | | | |--FRepLayout.CallRepNotifies.<span class="keyword">for</span>.<span class="keyword">switch</span>.&#123; </span><br><span class="line">| | | | | |--<span class="keyword">for</span> (FProperty* RepProperty : RepState-&gt;RepNotifies) &#123;</span><br><span class="line">| | | | | |--    <span class="comment">// 遍历所有FReceivingRepState.RepNotifies, 执行OnRep</span></span><br><span class="line">| | | | | |--    <span class="comment">// 找到OnRep对应的UFunction</span></span><br><span class="line">| | | | | |--    UFunction* RepNotifyFunc = Object-&gt;<span class="built_in">FindFunction</span>(RepProperty-&gt;RepNotifyFunc);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="comment">// 如果0个参数, 直接调用OnRep</span></span><br><span class="line">| | | | | |--    Object-&gt;<span class="built_in">ProcessEvent</span>(RepNotifyFunc, <span class="literal">nullptr</span>);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="comment">// 如果一个参数, 则该参数为旧历史数据</span></span><br><span class="line">| | | | | |--    FRepShadowDataBuffer PropertyData = ShadowData + Parent;</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="keyword">if</span> (<span class="built_in">EnumHasAnyFlags</span>(Parent.Flags, ERepParentFlags::IsCustomDelta))</span><br><span class="line">| | | | | |--    &#123;</span><br><span class="line">| | | | | |--        Object-&gt;<span class="built_in">ProcessEvent</span>(RepNotifyFunc, PropertyData);</span><br><span class="line">| | | | | |--    &#125;</span><br><span class="line">| | | | | |--    <span class="keyword">else</span></span><br><span class="line">| | | | | |--    &#123;</span><br><span class="line">| | | | | |--        <span class="comment">// Handle bitfields.</span></span><br><span class="line">| | | | | |--        <span class="type">const</span> FBoolProperty* BoolProperty = <span class="built_in">CastField</span>&lt;<span class="type">const</span> FBoolProperty&gt;(Parent.Property);</span><br><span class="line">| | | | | |--        <span class="keyword">if</span> (BoolProperty &amp;&amp; !BoolProperty-&gt;<span class="built_in">IsNativeBool</span>())</span><br><span class="line">| | | | | |--        &#123;</span><br><span class="line">| | | | | |--            <span class="type">bool</span> BoolPropertyValue = BoolProperty-&gt;<span class="built_in">GetPropertyValue</span>(PropertyData);</span><br><span class="line">| | | | | |--            Object-&gt;<span class="built_in">ProcessEvent</span>(RepNotifyFunc, &amp;BoolPropertyValue);</span><br><span class="line">| | | | | |--        &#125;</span><br><span class="line">| | | | | |--        <span class="keyword">else</span></span><br><span class="line">| | | | | |--        &#123;</span><br><span class="line">| | | | | |--            Object-&gt;<span class="built_in">ProcessEvent</span>(RepNotifyFunc, PropertyData);</span><br><span class="line">| | | | | |--        &#125;</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--        <span class="comment">// now store the complete value in the shadow buffer</span></span><br><span class="line">| | | | | |--        <span class="keyword">if</span> (!<span class="built_in">EnumHasAnyFlags</span>(Parent.Flags, ERepParentFlags::IsNetSerialize))</span><br><span class="line">| | | | | |--        &#123;</span><br><span class="line">| | | | | |--            RepProperty-&gt;<span class="built_in">CopyCompleteValue</span>(ShadowData + Parent, ObjectData + Parent);</span><br><span class="line">| | | | | |--        &#125;</span><br><span class="line">| | | | | |--    &#125;</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="comment">// 如果为两个参数, 则</span></span><br><span class="line">| | | | | |--    <span class="built_in">check</span>(<span class="built_in">EnumHasAnyFlags</span>(Parent.Flags, ERepParentFlags::IsCustomDelta));</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="comment">// Fixme: this isn&#x27;t as safe as it could be. Right now we have two types of parameters: MetaData (a TArray&lt;uint8&gt;)</span></span><br><span class="line">| | | | | |--    <span class="comment">// and the last local value (pointer into the Recent[] array).</span></span><br><span class="line">| | | | | |--    <span class="comment">//</span></span><br><span class="line">| | | | | |--    <span class="comment">// Arrays always expect MetaData. Everything else, including structs, expect last value.</span></span><br><span class="line">| | | | | |--    <span class="comment">// This is enforced with UHT only. If a ::NetSerialize function ever starts producing a MetaData array thats not in FArrayProperty,</span></span><br><span class="line">| | | | | |--    <span class="comment">// we have no static way of catching this and the replication system could pass the wrong thing into ProcessEvent here.</span></span><br><span class="line">| | | | | |--    <span class="comment">//</span></span><br><span class="line">| | | | | |--    <span class="comment">// But this is all sort of an edge case feature anyways, so its not worth tearing things up too much over.</span></span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="function">FMemMark <span class="title">Mark</span><span class="params">(FMemStack::Get())</span></span>;</span><br><span class="line">| | | | | |--    uint8* Parms = <span class="built_in">new</span>(FMemStack::<span class="built_in">Get</span>(), MEM_Zeroed, RepNotifyFunc-&gt;ParmsSize)uint8;</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    <span class="function">TFieldIterator&lt;FProperty&gt; <span class="title">Itr</span><span class="params">(RepNotifyFunc)</span></span>;</span><br><span class="line">| | | | | |--    <span class="built_in">check</span>(Itr);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    FRepShadowDataBuffer PropertyData = ShadowData + Parent;</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    Itr-&gt;<span class="built_in">CopyCompleteValue</span>(Itr-&gt;<span class="built_in">ContainerPtrToValuePtr</span>&lt;<span class="type">void</span>&gt;(Parms), PropertyData);</span><br><span class="line">| | | | | |--    ++Itr;</span><br><span class="line">| | | | | |--    <span class="built_in">check</span>(Itr);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    TArray&lt;uint8&gt; *NotifyMetaData = RepState-&gt;RepNotifyMetaData.<span class="built_in">Find</span>(RepProperty);</span><br><span class="line">| | | | | |--    <span class="built_in">check</span>(NotifyMetaData);</span><br><span class="line">| | | | | |--    Itr-&gt;<span class="built_in">CopyCompleteValue</span>(Itr-&gt;<span class="built_in">ContainerPtrToValuePtr</span>&lt;<span class="type">void</span>&gt;(Parms), NotifyMetaData);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    Object-&gt;<span class="built_in">ProcessEvent</span>(RepNotifyFunc, Parms);</span><br><span class="line">| | | | | |--    </span><br><span class="line">| | | | | |--    Mark.<span class="built_in">Pop</span>();</span><br><span class="line">| | | | | |--    <span class="keyword">break</span>;</span><br><span class="line">| | | | | |--&#125;</span><br><span class="line">| | | | | |--<span class="comment">// for循环遍历之后, 清理OnRep</span></span><br><span class="line">| | | | | |--RepState-&gt;RepNotifies.<span class="built_in">Empty</span>();</span><br><span class="line">| | | | | |--RepState-&gt;RepNotifyMetaData.<span class="built_in">Empty</span>();</span><br></pre></td></tr></table></figure>
<p>通过如上堆栈可以清晰看出,
在for循环遍历所有<code>FReceivingRepState.RepNotifies</code>处理完回调之后,
调用<code>RepState-&gt;RepNotifies.Empty();</code>清理本次的OnRep数据.
这样OnRep的设置和回调是可以分开进行的.</p>
<h3 id="initonly为何物"><code>InitOnly</code>为何物</h3>
<p><code>InitOnly</code>对应的枚举类型为<code>COND_InitialOnly</code>,
只随创建<code>Actor</code>的<code>Bunch</code>一起发送,
错过了就永远不会发送(Dormancy重新唤醒<code>RepFlags.bNetInitial</code>会为true,
会触发<code>COND_InitialOnly</code>的<code>OnRep</code>). 佐证代码:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113211817531.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113212226498.png" /></p>
<p><code>CompareParentProperty</code>返回<code>true</code>,
证明变量没有发生改变, 所以不会进行属性同步, 也就不会触发OnRep.
并且也可以反推出,
创建Actor的bunch一定包含<code>InitOnly</code>的所有数据.</p>
<h3
id="initonly的onrep流程"><code>InitOnly</code>的<code>OnRep</code>流程</h3>
<p><code>InitOnly</code>的<code>OnRep</code>流程和其他属性的OnRep流程完全一样,
UE是不会区分其是否为<code>InitOnly</code>的.
只不会<code>InitOnly</code>数据会和<code>SerializeActor</code>的数据放在同一个Bunch中.
这里再贴一下Bunch的结构, 参考: :<a href="/2024/05/15/UE/%E7%BD%91%E7%BB%9C/UE%E7%BD%91%E7%BB%9C-ReplicateActor/" title="UE网络-ReplicateActor">UE网络-ReplicationActor</a>及其相关文章.</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/BunchArchetype-1694577437093-1.png"
alt="整体消息框架" />
<figcaption aria-hidden="true">整体消息框架</figcaption>
</figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116095559293.png" /></p>
<p><span style="color:red;">这里要特意指出一下</span>,
<code>AActor.PostNetInit</code>是特意为网络初始化时没有进行<code>BeginPlay</code>而添加的补充阶段,
即在网路层, 根据远端创建的Actor, 在这个bunch处理的末尾, 调用BeginPlay,
但是这时候, <code>OnRep</code>可能还没有进行调用.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116100250076.png" /></p>
<h4
id="开启net.allowasyncloading">开启<code>net.AllowAsyncLoading</code></h4>
<p>开启<code>net.AllowAsyncLoading</code>后,
SpawnActor+SerializeProperty+OnRep+BeginPlay详细堆栈</p>
<table>
<tr>
<td bgcolor="#D5E8D4">
--UNetDriver.TickFlush.if <br> |--UIpConnection.Tick <br> |
|--UNetConnection.Tick.else.if.for <br> | |
|--UActorChannel.ProcessQueuedBunches <br> | | |
|--UActorChannel.ProcessBunch.if <span style="color:red;"> <br> | | | |
|--// 创建Actor <br> | | | | |--UPackageMapClient.SerializeNewActor <br>
| | | | | |--UWorld.SpawnActorAbsolute </span> <br> | | | |
|--FObjectReplicator.ReceivedBunch.if <span style="color:red;"> <br> | |
| | | |--// 根据远端数据序列化本地变量 <br> | | | | |
|--FRepLayout.ReceiveProperties <br> | | | | | |
|--ReceiveProperties_r.for.else.else <br> | | | | | | |
|--ReceivePropertyHelper.if <br> | | | | | | | |
|--FProperty.NetSerializeItem </span> <br> | |
|--UActorChannel.ProcessQueuedBunches.if.if.for <span
style="color:red;"><br> | | | |--// 调用OnRep <br> | | |
|--FObjectReplicator.CallRepNotifies<br> | | | | |-- //这里特殊说明一下,
如果为QueuedBunches(即开启了net.AllowAsyncLoading),
则会在QueuedBunches为空的时候, 才执行. <br> | | | | |--if
(bSkipIfChannelHasQueuedBunches &amp;&amp; (OwningChannel &amp;&amp;
OwningChannel-&gt;QueuedBunches.Num() &gt; 0)) <br> | | | | |--{ <br> |
| | | |-- return; <br> | | | | |--} <br> | | | | |--// 调用 OnRep <br> |
| | | |--FRepLayout.CallRepNotifies </span><br />
| | |--UActorChannel.ProcessQueuedBunches.if.if.for <br> | | |
|--UActorChannel.ProcessBunch.if <span style="color:red;"><br> | | | |
|--// 调用BeginPlay <br> | | | | |--AActor.PostNetInit.if.if<br />
| | | | | |--AActor.DispatchBeginPlay.if </span><br>
</td>
</tr>
</table>
<p><span style="color:red;">这里要特意指出一下:</span>
当开启<code>net.AllowAsyncLoading</code>后,
在<code>FObjectReplicator.CallRepNotifies</code>中,
会判断<code>QueuedBunches</code>大小, 如果为0, 才会进行OnRep回调.
佐证代码:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116110325697.png" /></p>
<p>那<code>OnRep</code>什么时候回调呢?</p>
<p>答案: <code>ActorChannel</code>内,
<code>QueuedBunches</code>为0的时候, 即当前最后一个.</p>
<h4
id="未开启net.allowasyncloading">未开启<code>net.AllowAsyncLoading</code></h4>
<p>未开启<code>net.AllowAsyncLoading</code>后,
SpawnActor+SerializeProperty+OnRep+BeginPlay详细堆栈</p>
<table>
<tr>
<td bgcolor="#D5E8D4">
// 未开启net.AllowAsyncLoading后,
SpawnActor+SerializeProperty+OnRep+BeginPlay详细堆栈 <br>
--UIpNetDriver.TickDispatch <br>
|--UNetConnection.ReceivedRawPacket.if.if.if <br> |
|--UNetConnection.ReceivedPacket.while.{ <br> | |
|--UChannel.ReceivedRawBunch.else <br> | | |
|--UChannel.ReceivedNextBunch.if <br> | | | |
|--UChannel.ReceivedSequencedBunch <br> | | | | |
|--UActorChannel.ReceivedBunch <br> | | | | | |
|--UActorChannel.ProcessBunch.if <span style="color:red;"> <br> | | | |
| | | |--// 创建Actor <br> | | | | | | |
|--UPackageMapClient.SerializeNewActor.if.if.if.if.if <br> | | | | | | |
| |--UWorld.SpawnActorAbsolute <br> | | | | | | | | |
|--UWorld.SpawnActor </span> <br> | | | | | |
|--UActorChannel.ProcessBunch.if <br> | | | | | | |
|--FObjectReplicator.ReceivedBunch.if <span style="color:red;"> <br> | |
| | | | | | |--// 根据远端数据序列化本地变量 <br> | | | | | | | |
|--FRepLayout.ReceiveProperties <br> | | | | | | | | |
|--ReceiveProperties_r.for.else.else <br> | | | | | | | | | |
|--ReceivePropertyHelper.if <br> | | | | | | | | | | |
|--FProperty.NetSerializeItem </span> <br> | | | | | |
|--UActorChannel.ProcessBunch.if <span style="color:red;"> <br> | | | |
| | | |--// 调用OnRep <br> | | | | | | |
|--FObjectReplicator.CallRepNotifies <br> | | | | | | | |
|--FRepLayout.CallRepNotifies.for.switch.{ </span> <br> | | | | | |
|--UActorChannel.ProcessBunch.if <span style="color:red;"> <br> | | | |
| | | |--// 调用BeginPlay <br> | | | | | | | |--AActor.PostNetInit.if.if
<br> | | | | | | | | |--AActor.DispatchBeginPlay.if <br> | | | | | | | |
| |--ATestRepFlowSpawnedActor.BeginPlay </span> <br>
</td>
</tr>
</table>
<h4 id="总结">总结</h4>
<p>可以看出无论是否开启<code>net.AllowAsyncLoading</code>,
调用堆栈最后都是用<code>UActorChannel.ProcessBunch</code>处理bunch.
其中有所区别的地方为:开启<code>net.AllowAsyncLoading</code>可能会导致<code>QueuedBunches</code>中有数据,
造成<code>OnRep</code>延迟回调,
最终导致OnRep回调可能晚于<code>BeginPlay</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116145654549.png" /></p>
<p><span style="color:red;">针对QueuedBunches还有数据, 就不能执行OnRep,
这段代码作用是什么呢?</span> 通过查询提交记录得知, 是为了修复Replay
scrubbing后, Actor传送问题.</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Github上搜索这个唯一编号:db9ddd66282065b33e9b71ffb7c58ed<span class="number">5f042b146</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116144752893.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231116144821213.png" /></p>
<p><span style="color:red;">所以, 对于正常不需要Replay的情景,
可以直接干掉, 对于需要Replay的, 加上Replay判定.</span></p>
<h3
id="指针类型和非指针类型的initonly">指针类型和非指针类型的<code>InitOnly</code></h3>
<p>如果一个UObject指针也设置成了<code>InitOnly</code>类型,
那么它一定会传输吗?</p>
<p>当UObject在Actor创建时候就已经设置对应的值, 那么可能会被传输.
测试代码(这里还引申出ActorComponent网络归属权问题,
详见:<a href="/2024/05/15/UE/%E7%BD%91%E7%BB%9C/Component%20Replication%E5%BD%92%E5%B1%9E%E6%9D%83/" title="Component Replication归属权">Component Replication归属权</a>):</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118170437535.png" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">开启net.AllowAsyncLoading后, 执行流程的一种情况为:</span><br><span class="line">ATestRepFlowSpawnedActor::ATestRepFlowSpawnedActor</span><br><span class="line">-&gt;ATestRepFlowSpawnedActor.mTestNumber Init</span><br><span class="line">-&gt;UTestRepFlowSpawnedCmp::UTestRepFlowSpawnedCmp</span><br><span class="line">-&gt;UTestRepFlowSpawnedCmp.TestNumber Init</span><br><span class="line">-&gt;AActor.PostNetInit</span><br><span class="line">-&gt;ATestRepFlowSpawnedActor.BeginPlay </span><br><span class="line">-&gt;Super::<span class="built_in">BeginPlay</span>(); <span class="comment">// Actor::BeginPlay()</span></span><br><span class="line">-&gt;UTestRepFlowSpawnedCmp.BeginPlay </span><br><span class="line">-&gt;ATestRepFlowSpawnedActor.OnRep_TestNumber </span><br><span class="line">-&gt;UTestRepFlowSpawnedCmp.OnRep_TestNumber </span><br><span class="line">-&gt;ATestRepFlowSpawnedActor.OnRep_TestRepFlowSpawnedCmp </span><br></pre></td></tr></table></figure>
<p>首先把DS端ReplicateActor时序列化各种属性的顺序贴出来;</p>
<figure>
<img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118171033062.png"
alt="ReplicateActor" />
<figcaption aria-hidden="true">ReplicateActor</figcaption>
</figure>
<h4 id="反序列化actor">反序列化Actor</h4>
<p>首先<code>ATestRepFlowSpawnedActor::ATestRepFlowSpawnedActor</code>执行堆栈:</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 未触发异步加载, `ATestRepFlowSpawnedActor::ATestRepFlowSpawnedActor`执行堆栈:</span><br><span class="line">--UIpNetDriver.TickDispatch </span><br><span class="line">|<span class="string">--UNetConnection.ReceivedRawPacket.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.ReceivedPacket.while.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedRawBunch.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedNextBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedSequencedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReceivedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UPackageMapClient.SerializeNewActor.if.if.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActorAbsolute </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActor </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ATestRepFlowSpawnedActor.ATestRepFlowSpawnedActor </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 触发异步加载, 创建`ATestRepFlowSpawnedActor`堆栈</span></span><br><span class="line"><span class="string">--UNetDriver.TickFlush.if </span></span><br><span class="line"><span class="string"></span>|<span class="string">--UIpConnection.Tick </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.Tick.else.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UPackageMapClient.SerializeNewActor.if.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActorAbsolute </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActor </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ATestRepFlowSpawnedActor.ATestRepFlowSpawnedActor </span></span><br></pre></td></tr></table></figure>
<p>核心关键代码: 在处理bunch时, 由于ActorChannel的Actor为空,
需要根据Bunch内容重新创建.
这也对应了图ReplicateActor内填充Bunch的顺序(第一个填充的就是SerializeActor的信息).</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118175334982.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118180126799.png" /></p>
<h4 id="初始化actor内属性">初始化Actor内属性</h4>
<p>初始化<code>ATestRepFlowSpawnedActor.mTestNumber</code>.</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 未触发异步加载, 初始化`ATestRepFlowSpawnedActor.mTestNumber`.</span><br><span class="line">--UIpNetDriver.TickDispatch </span><br><span class="line">|<span class="string">--UNetConnection.ReceivedRawPacket.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.ReceivedPacket.while.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedRawBunch.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedNextBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedSequencedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReceivedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 触发异步加载, 初始化`ATestRepFlowSpawnedActor.mTestNumber`.</span></span><br><span class="line"><span class="string">--UNetDriver.TickFlush.if </span></span><br><span class="line"><span class="string"></span>|<span class="string">--UIpConnection.Tick </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.Tick.else.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br></pre></td></tr></table></figure>
<p>此时处理ActorProperties对应的ContentBlock.</p>
<figure>
<img src="./assets/image-20231118180041065.png"
alt="image-20231118180041065" />
<figcaption aria-hidden="true">image-20231118180041065</figcaption>
</figure>
<p>这也和代码能对应上: 循环处理ContentBlock.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118180329837.png" /></p>
<h4 id="actorcomponent序列化">ActorComponent序列化</h4>
<p>创建<code>UTestRepFlowSpawnedCmp</code>:
UTestRepFlowSpawnedCmp::UTestRepFlowSpawnedCmp</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 未触发异步加载, 创建`UTestRepFlowSpawnedCmp`堆栈</span><br><span class="line">--UIpNetDriver.TickDispatch </span><br><span class="line">|<span class="string">--UNetConnection.ReceivedRawPacket.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.ReceivedPacket.while.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedRawBunch.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedNextBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedSequencedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReceivedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockPayload </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockHeader.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UTestRepFlowSpawnedCmp.UTestRepFlowSpawnedCmp </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 触发异步加载, 创建`UTestRepFlowSpawnedCmp`堆栈</span></span><br><span class="line"><span class="string">--UNetDriver.TickFlush.if </span></span><br><span class="line"><span class="string"></span>|<span class="string">--UIpConnection.Tick </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.Tick.else.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockPayload </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockHeader.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UTestRepFlowSpawnedCmp.UTestRepFlowSpawnedCmp </span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231118180759208.png" /></p>
<h4 id="初始化actorcomponent属性">初始化ActorComponent属性</h4>
<p>UTestRepFlowSpawnedCmp.TestNumber Init</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 未触发异步加载, UTestRepFlowSpawnedCmp.TestNumber init堆栈</span><br><span class="line">--UIpNetDriver.TickDispatch </span><br><span class="line">|<span class="string">--UNetConnection.ReceivedRawPacket.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.ReceivedPacket.while.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedRawBunch.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedNextBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UChannel.ReceivedSequencedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReceivedBunch </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 触发异步加载, UTestRepFlowSpawnedCmp.TestNumber init堆栈</span></span><br><span class="line"><span class="string">--UNetDriver.TickFlush.if </span></span><br><span class="line"><span class="string"></span>|<span class="string">--UIpConnection.Tick </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.Tick.else.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br></pre></td></tr></table></figure>
<h4 id="aactor.postnetinit">AActor.PostNetInit</h4>
<p>由于开启了<code>net.AllowAsyncLoading</code>, 一般而言,
此时还会有Bunch未处理, 所以, 跳过OnRep阶段, 执行AActor.PostNetInit</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发异步加载后,ATestRepFlowSpawnedActor.BeginPlay堆栈</span></span><br><span class="line">--UNetDriver.TickFlush.<span class="keyword">if</span> </span><br><span class="line">|--UIpConnection.Tick </span><br><span class="line">| |--UNetConnection.Tick.<span class="keyword">else</span>.<span class="keyword">if</span>.<span class="keyword">for</span> </span><br><span class="line">| | |--UActorChannel.ProcessQueuedBunches.<span class="keyword">if</span>.<span class="keyword">if</span>.<span class="keyword">for</span> </span><br><span class="line">| | | |--UActorChannel.ProcessBunch.<span class="keyword">if</span> </span><br><span class="line">| | | | |--AActor.PostNetInit.<span class="keyword">if</span>.<span class="keyword">if</span> </span><br><span class="line">| | | | | |--AActor.DispatchBeginPlay.<span class="keyword">if</span> </span><br><span class="line">| | | | | | |--ATestRepFlowSpawnedActor.BeginPlay </span><br><span class="line"></span><br><span class="line"><span class="comment">// 未触发异步加载后,ATestRepFlowSpawnedActor::BeginPlay堆栈</span></span><br><span class="line">--UIpNetDriver.TickDispatch </span><br><span class="line">|--UNetConnection.ReceivedRawPacket.<span class="keyword">if</span>.<span class="keyword">if</span>.<span class="keyword">if</span> </span><br><span class="line">| |--UNetConnection.ReceivedPacket.<span class="keyword">while</span>.&#123; </span><br><span class="line">| | |--UChannel.ReceivedRawBunch.<span class="keyword">else</span> </span><br><span class="line">| | | |--UChannel.ReceivedNextBunch.<span class="keyword">if</span> </span><br><span class="line">| | | | |--UChannel.ReceivedSequencedBunch </span><br><span class="line">| | | | | |--UActorChannel.ReceivedBunch </span><br><span class="line">| | | | | | |--UActorChannel.ProcessBunch.<span class="keyword">if</span> </span><br><span class="line">| | | | | | | |--AActor.PostNetInit.<span class="keyword">if</span>.<span class="keyword">if</span> </span><br><span class="line">| | | | | | | | |--AActor.DispatchBeginPlay.<span class="keyword">if</span> </span><br><span class="line">| | | | | | | | | |--ATestRepFlowSpawnedActor.BeginPlay </span><br></pre></td></tr></table></figure>
<h4 id="总结-1">总结</h4>
<p>开启<code>net.AllowAsyncLoading</code>后, 执行顺序一定吗? 不一定,
因为开启它之后, 可能会因为异步加载导致在QueueBunch中处理,
也可能没有触发异步加载, 还在原来流程中处理. 所以各种情况都会存在.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231119110314263.png" /></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// 触发异步加载后, 执行堆栈的一种情况</span><br><span class="line">--UNetDriver.TickFlush.if </span><br><span class="line">|<span class="string">--UIpConnection.Tick </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UNetConnection.Tick.else.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载, 创建`ATestRepFlowSpawnedActor`堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UPackageMapClient.SerializeNewActor.if.if.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActorAbsolute </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UWorld.SpawnActor </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ATestRepFlowSpawnedActor.ATestRepFlowSpawnedActor </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载, 初始化`ATestRepFlowSpawnedActor.mTestNumber`.</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockPayload </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载, 创建`UTestRepFlowSpawnedCmp`堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReadContentBlockHeader.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--NewObject</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--StaticConstructObject_Internal.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UTestRepFlowSpawnedCmp.UTestRepFlowSpawnedCmp </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.while </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReceivedBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载, UTestRepFlowSpawnedCmp.TestNumber init堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceiveProperties_r.for.else.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ReceivePropertyHelper.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FProperty.NetSerializeItem </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessBunch.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--AActor.PostNetInit.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载后,ATestRepFlowSpawnedActor.BeginPlay堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--AActor.DispatchBeginPlay.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ATestRepFlowSpawnedActor.BeginPlay </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--AActor.BeginPlay.for.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载后,UTestRepFlowSpawnedCmp.BeginPlay堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UTestRepFlowSpawnedCmp.BeginPlay  </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UActorChannel.ProcessQueuedBunches.if.if.for </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.CallRepNotifies </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.CallRepNotifies.for.switch.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--AActor.ProcessEvent.if.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UObject.ProcessEvent.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UFunction.Invoke </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载后,ATestRepFlowSpawnedActor::OnRep_TestNumber堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--ATestRepFlowSpawnedActor.OnRep_TestNumber </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.CallRepNotifies </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.CallRepNotifies.for.switch.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UObject.ProcessEvent.&#123; </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UFunction.Invoke </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--// 触发异步加载后, UTestRepFlowSpawnedCmp::OnRep_TestNumber堆栈</span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UTestRepFlowSpawnedCmp.OnRep_TestNumber </span></span><br><span class="line"><span class="string">--UNetDriver.TickFlush</span></span><br><span class="line"><span class="string"></span>|<span class="string">--// 处理UnmappedObject</span></span><br><span class="line"><span class="string"></span>|<span class="string">--FObjectReplicator.UpdateUnmappedObjects </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--FRepLayout.ReceiveProperties_BackwardsCompatible_r.while.FRepLayout.UpdateUnmappedObjects.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.UpdateUnmappedObjects_r.for.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectPropertyBase.NetSerializeItem </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectProperty.SetObjectPropertyValue </span></span><br><span class="line"><span class="string"></span>|<span class="string">--FObjectReplicator.UpdateUnmappedObjects </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.CallRepNotifies </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.CallRepNotifies</span></span><br></pre></td></tr></table></figure>
<h2 id="rpc执行顺序"><code>RPC</code>执行顺序</h2>
<p>TODO</p>
<h2
id="multicastrpc-reliable执行顺序"><code>MulticastRPC Reliable</code>执行顺序</h2>
<p>TODO</p>
<h2
id="multicastrpc-unreliable执行顺序"><code>MulticastRPC Unreliable</code>执行顺序</h2>
<p>TODO</p>
<h1 id="actor情形"><code>Actor</code>情形</h1>
<p>TODO</p>
<h1
id="default-sub-actorcomponent情形"><code>Default Sub ActorComponent</code>情形</h1>
<p>TODO</p>
<h1
id="按需创建的subactorcomponent情形">按需创建的<code>SubActorComponent</code>情形</h1>
<p>如果<code>SpawnSubActorComponent</code>中有<code>COND_InitialOnly</code>类型的属性,
那么这类属性如果在SerializeActorBunch之前还没有设置对应的值,
那么该属性以后都无法进行同步(除非Dormancy后重新唤醒). 示例:</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113210943174.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113211431219.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113211452821.png" /></p>
<p>原因: <code>COND_InitialOnly</code>的意思是,
只有网络上第一次(<code>Dormancy</code>之后再次重新使用, 也算第一次,
因为<code>Dormancy</code>是将其从网络中移除.)同步某一个<code>Actor</code>时候,
才会将这次同步的<code>Bunch</code>标记为<code>bNetInitial</code>,
并且将其设置为<code>Reliable</code>.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113211817531.png" /></p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113212226498.png" /></p>
<p>具体堆栈:</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--UActorChannel.ReplicateActor.if </span><br><span class="line">|<span class="string">--AActor.ReplicateSubobjects.for.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string">--UActorChannel.ReplicateSubobject </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FObjectReplicator.ReplicateProperties </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FNetSerializeCB.UpdateChangelistMgr </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.UpdateChangelistMgr </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--FRepLayout.CompareProperties.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--CompareParentProperties.if.else </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--UE4_RepLayout_Private.CompareParentPropertyHelper </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--CompareParentProperty.if </span></span><br><span class="line"><span class="string"></span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">--const bool bShouldSkip = !bIsLifetime </span>||<span class="string"> !bIsActive </span>||<span class="string"> (Parent.Condition == COND_InitialOnly &amp;&amp; !SharedParams.bIsInitial);</span></span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113212448449.png" /></p>
<p>从上图也可以验证, 这个<code>ObjectReplicator</code>为新创建的,
即通过上文<code>NewObject</code>创建的.</p>
<p>那么怎么做才能针对首次动态创建的<code>SubActorComponent</code>,
也可以<code>OnRep</code> <code>COND_InitialOnly</code>属性呢?</p>
<p>答: 如果是新创建的<code>ActorComponent</code>,
将<code>RepFlags.bNetInitial</code>改成true.</p>
<p><img
src="https://raw.githubusercontent.com/fdcumt/ImageBed/master/image-20231113212939120.png" /></p>
<h2 id="总结-2">总结</h2>
<p>延迟创建(和SpawnActor不在同一帧, 并且创建Actor的Bunch已经同步过了),
该Component永远不会进行属性同步, 即客户端永远不会有OnRep的调用了.</p>
<h1 id="总结-3">总结</h1>
<p>TODO</p>
<h1 id="附言">附言</h1>
<ol type="1">
<li><code>net.AllowAsyncLoading</code>可以参考我之前的文章:<a href="/2024/05/15/UE/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E4%B8%AD,%20Package%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/" title="网络同步中, Package异步加载">网络同步中, Package异步加载</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>您的支持将鼓励我持续创作！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="NoBodyNoOne 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="NoBodyNoOne 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/UE%E7%BD%91%E7%BB%9C/" rel="tag"># UE网络</a>
              <a href="/tags/NetworkGUID/" rel="tag"># NetworkGUID</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/05/15/UE/%E7%BD%91%E7%BB%9C/GUID%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/" rel="prev" title="GUID延迟绑定">
                  <i class="fa fa-chevron-left"></i> GUID延迟绑定
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/05/15/UE/%E7%BD%91%E7%BB%9C/NetDormancy/" rel="next" title="NetDormancy">
                  NetDormancy <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2023 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NoBodyNoOne</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">49k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:57</span>
  </span>
</div>
<div class="busuanzi-count">
</div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"fdcumt/fdcumt.github.io","issue_term":"title","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
